{"ast":null,"code":"var _jsxFileName = \"/home/mukeshs/Projects/edurights/src/components/nodeJs/nodeDeep/childs.js\";\nimport React, { Component } from 'react';\nimport Prism from \"prismjs\";\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\nimport '../../ReactJs/styles.css';\nimport Sidebar from '../sidebar';\nimport PrismCode from '../../ReactJs/prismCode';\nconst titles = {\n  backgroundColor: '#F0F8FF',\n  padding: '1px',\n  fontSize: '16px'\n};\n\nconst styles = theme => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1)\n  },\n  smMargin: {\n    margin: theme.spacing(1)\n  },\n  actionDiv: {\n    textAlign: \"center\"\n  }\n});\n\nconst spawns = `\nconst { spawn } = require(\"child_process\");\n\nconst child = spawn(\"find\", [\"/\"]);\n\nchild.stdout.on(\"data\", (data) => {\n  console.log('stdout: '$'{ data }');\n});\n\nchild.stderr.on(\"data\", (data) => {\n  console.log('stderr: '$'{ data } ');\n});\n\nchild.on(\"error\", (error) => console.log('error: '$'{ error.message }'));\n\nchild.on(\"exit\", (code, signal) => {\n  if (code) console.log('Process exit with code: '$'{ code } ');\n  if (signal) console.log('Process killed with signal: '$'{ signal }');\n  console.log('Done âœ…');\n});\n`.trim();\nconst forkChild = `\n//lovechild.js\nprocess.on('message', (msg) => {\n  console.log('Parent said: ', msg);\n  process.send(\"I love you too\");\n});\n\nconst cp = require('child_process');\nconst child = cp.fork(__dirname + '/lovechild.js');\n\nchild.on('message', (msg) => {\n    console.log('Child said: ', msg);\n});\n\nchild.send(\"I love you\");\n\n\n//2\n//child.js\nprocess.on('message', function(msg, server) {\n  console.log(msg);\n\n  server.on('connection', function(socket) {\n      socket.end('Child handled connection');\n  });\n});\n\nvar child = require('child_process').fork('./child.js');\nvar server = require('net').createServer();\n\nserver.on('connection', function(socket) {\n    socket.end('Parent handled connection');\n});\n\nserver.listen(8080, function() {\n    child.send(\"The parent message\", server);\n});`.trim();\nconst execs = `\nconst { exec, execFile } = require(\"child_process\");\n\n//dir generate code human readable byte formate\nexec(\"dir\", (error, stdout, stderr) => {\n  // exec(\"/find /\", (error, stdout, stderr) => {\n  // execFile(\"./somefile.sh\", (error, stdout, stderr) => {\n  // exec(\"pwd\", (error, stdout, stderr) => {\n  if (error) {\n    console.log('error: '$'{error.message}');\n    return;\n  }\n  if (stderr) {\n    console.log('stderr: '$'{stderr}');\n    return;\n  }\n  console.log('stdout: '$'{stdout}');\n});\n`.trim();\nconst execFile = `\n//child_process.execFile(file[, args][, options][, callback])\n\n\nconst { execFile } = require('child_process'); \n\n// Executes the exec.js file \nconst child = execFile('node', ['exec.js'], \n\t\t(error, stdout, stderr) => { \nif (error) { \n\tthrow error; \n} \nconsole.log(stdout); \n}); \n`.trim();\nconst childsFile = `\n//1\nvar id = process.argv[2];\nprocess.on('message', function(n, socket) {\n    socket.write('child ' + id + ' was your server today.\\r\\n');\n    socket.end();\n});\n\n\n//2\nvar spawn = require('child_process').spawn;\nvar php = spawn(\"php\", ['-r', 'print \"Hello from PHP!\";']);\n\nphp.stdout.on('readable', function() {\n    var d;\n    while (d = this.read()) {\n        console.log(d.toString());\n    }\n});`.trim();\nconst clusterModule = `\nvar cluster = require('cluster');\nvar http = require('http');\nvar numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n    for (var i = 0; i < numCPUs; i++) {\n        cluster.fork();\n    }\n}\n\nif (cluster.isWorker) {\n    http.createServer(function(req, res) {\n        res.writeHead(200);\n        res.end(\"Hello from \" + cluster.worker.id);\n    }).listen(8080);\n}`.trim();\nconst spawning_processes = `\nvar writer = fs.createWriteStream(\"./a.out\");\nwriter.on('open', function() {\n    var cp = spawn(\"node\", ['./reader.js'], { stdio: [null, writer, null] });\n});`.trim();\nconst forkFiles = `\nconst { fork } = require(\"child_process\");\n\napp.get(\"/one\", (req, res) => {\n  const sum = longComputation();\n  res.send({ sum: sum });\n});\n\napp.get(\"/two\", async (req, res) => {\n  const sum = await longComputePromise();\n  res.send({ sum: sum });\n});\n\n//this uses child process\napp.get(\"/three\", (req, res) => {\n  const child = fork(\"./longtask.js\");\n  child.send(\"start\");\n  child.on(\"message\", (sum) => {\n    res.send({ sum: sum });\n  });\n});\n\n\nfunction longComputation() {\n  let sum = 0;\n  for (let i = 0; i < 1e9; i++) {\n    sum += i;\n  }\n  return sum;\n}\n\nfunction longComputePromise() {\n  return new Promise((resolve, reject) => {\n    let sum = 0;\n    for (let i = 0; i < 1e9; i++) {\n      sum += i;\n    }\n    resolve(sum);\n  });\n}`.trim();\nconst spawnFiles = `\n`.trim();\nconst clusting = `\nconst cluster = require(\"cluster\");\nconst os = require(\"os\");\n\nconst numCpu = os.cpus().length;\n\napp.get(\"/\", (req, res) => {\n  for (let i = 0; i < 1000; i++) {}\n  res.send('OK '$'{process.pid}');\n  cluster.worker.kill();\n});\n\nif (cluster.isMaster) {\n  for (let i = 0; i < numCpu; i++) {\n    cluster.fork();\n  }\n  cluster.on(\"exit\", (Worker, code, signal) => {\n    console.log('worker '$'{Worker.process.pid} died');\n    cluster.fork();\n  });\n} else {\n  app.listen(5000, () =>\n    console.log('Server running on port 5000')\n  );\n}`.trim();\nconst cpus = `\nconst os = require('os')\nconst cluster = require('cluster')\n\n//check own cpu\nconsole.log(os.cpus())\n\n//master, worker\nif (cluster.isMaster) {\n  let noOcCups = os.cpus().length;\n  console.log('Master Process is running', process.pid)\n  for (let i = 0; i < noOcCups; i++) {\n    cluster.fork()\n  }\n  cluster.on('exit', () => {\n    console.log('One worker destroyed')\n    cluster.fork()\n  })\n}\n`.trim();\n\nclass ChildsPros extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0);\n  }\n\n  render() {\n    const {\n      classes\n    } = this.props;\n    return React.createElement(Grid, {\n      container: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 263\n      },\n      __self: this\n    }, React.createElement(Grid, {\n      item: true,\n      xs: 2,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 264\n      },\n      __self: this\n    }, React.createElement(Paper, {\n      className: classes.paper,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 265\n      },\n      __self: this\n    }, React.createElement(\"h4\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 266\n      },\n      __self: this\n    }, React.createElement(Sidebar, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 266\n      },\n      __self: this\n    })))), React.createElement(Grid, {\n      item: true,\n      xs: 10,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 269\n      },\n      __self: this\n    }, React.createElement(Paper, {\n      className: classes.paper,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 270\n      },\n      __self: this\n    }, React.createElement(List, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 271\n      },\n      __self: this\n    }, React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 272\n      },\n      __self: this\n    }, \"Communicating with your child\"), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 273\n      },\n      __self: this\n    }, \"All ChildProcess object extend EventEmitter. ChildProcess objects expose some useful methods for interacting with children directly.\", React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 276\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 276\n      },\n      __self: this\n    }, \"child.connected :\"), \" When a child is disconnected from its parent via  child.disconnect(), this flag will be set to false.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 278\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 278\n      },\n      __self: this\n    }, \"child.stdin :\"), \" Is a WritableStream.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 279\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 279\n      },\n      __self: this\n    }, \"child.stdout :\"), \" Is a ReadableStream.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 280\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 280\n      },\n      __self: this\n    }, \"child.stderr :\"), \" Is a ReadableStream corresponding to the child's standard error.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 281\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 281\n      },\n      __self: this\n    }, \"child.pid :\"), \" Is an integer representing the process ID (PID) assigned  to the child process.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 282\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 282\n      },\n      __self: this\n    }, \"child.kill :\"), \" Tries to terminate a child process, sending it an optional signal. If no signal is specified, the default is SIGTERM. While the terminal method, it is not guaranteed to kill a process\\u2014it only sends  a signal to a process.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 285\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 285\n      },\n      __self: this\n    }, \"child.disconnect() :\"), \" This command severs the IPC connection between the child and its parent. The child will then die gracefully, as it has no IPC channel to keep it alive. You may also call process.disconnect() from within the child itself. Once a child has disconnected, the connected flag  on that child reference will be set to false.\")), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 289\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 291\n      },\n      __self: this\n    }, \"Create Child\"), React.createElement(\"p\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 292\n      },\n      __self: this\n    }, \"Creating a Child Process with exec(). The exec() function in Node.js creates a new shell process and executes a command in that shell. The output of the command is kept in a buffer in memory, which you can accept via a callback function passed into exec().\"), React.createElement(\"p\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 298\n      },\n      __self: this\n    }, \"In Node.js CPU cannot handle increasing workload so, the child_process module can be used to spawn child processes. The child processes communicate with each other using a built-in messaging system.\"), \"The following are the four different ways to create a child process in Node.js:\", React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 304\n      },\n      __self: this\n    }, React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 305\n      },\n      __self: this\n    }, \"spawn() method\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 306\n      },\n      __self: this\n    }, \"fork() method\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 307\n      },\n      __self: this\n    }, \"exec() method\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 308\n      },\n      __self: this\n    }, \"execFile() method\")), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 310\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 312\n      },\n      __self: this\n    }, \"Spawning Processes\"), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 313\n      },\n      __self: this\n    }, \"it creates a streaming interface between the parent and child process.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 315\n      },\n      __self: this\n    }), \"The method takes three arguments:\", React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 317\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 317\n      },\n      __self: this\n    }, \"command :\"), \" A command to be executed by the OS shell.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 318\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 318\n      },\n      __self: this\n    }, \"arguments (optional) :\"), \" These are command-line arguments, sent as an array.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 319\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 319\n      },\n      __self: this\n    }, \"options :\"), \" An optional map of settings for spawn.\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 320\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 321\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 322\n      },\n      __self: this\n    }, \"The options for spawn allow its behavior to be carefully customized:\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 323\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 323\n      },\n      __self: this\n    }, \"cwd (String) :\"), \" By default, the command will understand its current working directory to be the same as that of the Node process calling spawn. Change that setting using this directive.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 325\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 325\n      },\n      __self: this\n    }, \"env (Object) :\"), \" This is used to pass environment variables to a child process.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 326\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 326\n      },\n      __self: this\n    }, \"detached (Boolean) :\"), \" When a parent spawns a child, both processes form  a group, and the parent is normally the leader of that group. To make a child the group leader, use detached. This will allow the child to continue running even after the parent exits. This is because the parent will wait for the child to exit by default. You can call child.unref() to tell the parent's event loop that it should not count the child reference, and exit if no other work exists.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 331\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 331\n      },\n      __self: this\n    }, \"uid (Number) :\"), \" Set the uid (user identity) directive for the child process, in terms of standard system permissions, such as a UID that has execute privileges on the child process.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 333\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 333\n      },\n      __self: this\n    }, \"gid (Number) :\"), \" Set the gid (group identity) directive for the child process, in terms of standard system permissions, such as a GID that has execute privileges on the child process.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 335\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 335\n      },\n      __self: this\n    }, \"stdio (String or Array) :\"), \" Child processes have file descriptors, the first three being the standard I/O descriptors process.stdin, process.stdout and process.stderr, in order (fds = 0,1,2). This directive allows those descriptors to be redefined, inherited, and so forth. Consider the output of the following child process program:\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 338\n      },\n      __self: this\n    }), \"process.stdout.write(new Buffer(\\\"Hello!\\\"));\")), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 341\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: spawning_processes,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 342\n      },\n      __self: this\n    })), React.createElement(\"p\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 348\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 349\n      },\n      __self: this\n    }, \"1. spawn() method: \"), \"This method spawns a new process using the given command and the command line arguments in args. The ChildProcess instance implements EventEmitterAPI which enables us to register handlers for events on child object directly. Some events that can be registered for handling with the ChildProcess are exit, disconnect, error, close and message.\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 354\n      },\n      __self: this\n    }), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 355\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: spawns,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 356\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 362\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 363\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 365\n      },\n      __self: this\n    }, \"2. fork() method\"), React.createElement(\"p\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 366\n      },\n      __self: this\n    }, \"The child_process.fork() is a special case of child_process.spawn() where the parent and the child process can communicate with each other via send().\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 369\n      },\n      __self: this\n    }), \"It creates a communication channel between the parent and child process.\"), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 372\n      },\n      __self: this\n    }, React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 373\n      },\n      __self: this\n    }, \"first synchronous\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 374\n      },\n      __self: this\n    }, \"npm install loadtest -g\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 375\n      },\n      __self: this\n    }, \"loadtest -n 10 -c 10 http://localhost:5000/first\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 376\n      },\n      __self: this\n    }, \"and see time took to handle total request\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 377\n      },\n      __self: this\n    }), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 378\n      },\n      __self: this\n    }, \"second async\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 379\n      },\n      __self: this\n    }, \"fork method in child-process and do inter-process communication.\")), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 381\n      },\n      __self: this\n    }), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 382\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: forkFiles,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 383\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 389\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 390\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 391\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 393\n      },\n      __self: this\n    }, \"fork() method2\"), React.createElement(\"p\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 394\n      },\n      __self: this\n    }, \"To create a child process one need simply call the fork method of the child_process module, passing it the name of a program file to execute within the new process:\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 396\n      },\n      __self: this\n    }), \"In this way any number of subprocesses can be kept running.\"), React.createElement(\"p\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 398\n      },\n      __self: this\n    }, \"Another very powerful idea is to pass a network server an object to a child. This technique allows multiple processes, including the parent, to share the responsibility for servicing connection requests, spreading load across cores.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 401\n      },\n      __self: this\n    }), \"In addition to passing a message to a child process as the first argument to send, the preceding code also sends the server handle to itself as a second argument. Our child server can now help out with the family's service business:\"), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 406\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: forkChild,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 407\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 413\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 414\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 416\n      },\n      __self: this\n    }, \"3. exec() method\"), React.createElement(\"p\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 417\n      },\n      __self: this\n    }, \"This method creates a shell first and then executes the command.\"), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 418\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: execs,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 419\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 425\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 426\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 428\n      },\n      __self: this\n    }, \"4. execFile() method\"), React.createElement(\"p\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 429\n      },\n      __self: this\n    }, \"The child_process.execFile() function is does not spawn a shell by default. It is slightly more efficient than child_process.exec() as the specified executable file is spawned directly as a new process.\"), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 434\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: execFile,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 435\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 441\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 443\n      },\n      __self: this\n    }, \"Child\"), \"It should be noted that the ability to spawn any system process means that one can use Node to run other application environments installed on the OS. If one had the popular PHP language installed, the following would be possible:\", React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 446\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: childsFile,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 447\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 453\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 455\n      },\n      __self: this\n    }, \"Cluster Module\"), \"Cluster module allows to create child processes that each runs on their own single thread, to handle the load.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 457\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 458\n      },\n      __self: this\n    }), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 459\n      },\n      __self: this\n    }, React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 460\n      },\n      __self: this\n    }, \"Cluster is a process to handle thread execution load while working with multi-core systems.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 463\n      },\n      __self: this\n    }, \"To split a single Node process into multiple processes. The cluster module provides a way of creating child processes that runs simultaneously and share the same server port.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 467\n      },\n      __self: this\n    }, \"But to take advantage of computers multi-core systems, the Cluster module allows you to easily create child processes that each runs on their own single thread, to handle the load.\")), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 472\n      },\n      __self: this\n    }), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 473\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: cpus,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 474\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 480\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 481\n      },\n      __self: this\n    }), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 482\n      },\n      __self: this\n    }, \"The following code creates a cluster of worker processes all sharing  the same HTTP connection.\", React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 484\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 484\n      },\n      __self: this\n    }, \"cluster.isMaster :\"), \" This is the Boolean value indicating whether the process is a master.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 485\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 485\n      },\n      __self: this\n    }, \"cluster.isWorker :\"), \" This is the Boolean value indicating whether the process was forked from a master.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 486\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 486\n      },\n      __self: this\n    }, \"cluster.worker :\"), \" This will bear a reference to the current worker object, only available to a child process.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 487\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 487\n      },\n      __self: this\n    }, \"cluster.workers :\"), \" This is a hash containing references to all active worker objects, keyed by the worker ID. Use this to loop through all worker objects. This only exists within the master process.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 489\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 489\n      },\n      __self: this\n    }, \"cluster.fork([env] ) :\"), \" This creates a new worker process. Only the master process may call this method. To expose a map of key-value pairs to the child's process environment, send an object to env. \"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 491\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 491\n      },\n      __self: this\n    }, \"cluster.disconnect([callback]) :\"), \" This is used to terminate all workers  in a cluster. Once all the workers have died gracefully, the cluster process will itself terminate if it has no further events to wait on. To be notified  when all children have expired, pass callback.\")), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 495\n      },\n      __self: this\n    }, \"cluster.setupMaster([settings]): This is a convenient way of passing a map of default arguments to be used when a child is forked. If all children are going to fork the same file, you will save time by setting it here. The available defaults are as follows:\", React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 499\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 499\n      },\n      __self: this\n    }, \"exec (String) :\"), \" This is the file path to the process file, defaulting  to __filename.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 500\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 500\n      },\n      __self: this\n    }, \"args (Array) :\"), \" This contains Strings sent as arguments to the child process. The default is to fetch arguments with process.argv. slice(2). \"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 502\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 502\n      },\n      __self: this\n    }, \"silent (Boolean) :\"), \" This specifies whether or not to send output  to the master's stdio, defaulting to false.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 504\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 504\n      },\n      __self: this\n    }, \"silent (Boolean) :\"), \" This specifies whether or not to send output  to the master's stdio, defaulting to false.\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 506\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 507\n      },\n      __self: this\n    }, \"Cluster events:\"), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 508\n      },\n      __self: this\n    }, React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 509\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 509\n      },\n      __self: this\n    }, \"fork :\"), \" This is fired when the master tries to fork a new child. This is not the same as online. This receives a worker object. \"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 511\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 511\n      },\n      __self: this\n    }, \"online :\"), \" This is fired when the master receives notification that a child is fully bound. This differs from the fork event and receives a worker object. \\u2022 listening: When the worker performs an action that requires a listen() call (such as starting an HTTP server), this event will be fired in the master. The event emits two arguments: a worker object, and the address object containing the address, port, and addressType values of the connection.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 516\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 516\n      },\n      __self: this\n    }, \"disconnect :\"), \" This is called whenever a child disconnects, which can happen either through process exit events or after calling child.kill(). This will fire prior to the exit event\\u2014they are not the same. This receives a worker object.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 519\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 519\n      },\n      __self: this\n    }, \"exit :\"), \" Whenever a child dies this event is emitted. The event receives three arguments: a worker object, the exit code number, and the signal string, such as SIGNUP, which caused the process to be killed.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 522\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 522\n      },\n      __self: this\n    }, \"setup :\"), \" This is called after cluster.setupMaster has executed.\")), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 524\n      },\n      __self: this\n    }, React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 525\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 526\n      },\n      __self: this\n    }, \"Worker object properties:\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 527\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 527\n      },\n      __self: this\n    }, \"worker.id :\"), \" This is the unique ID assigned to a worker, also representing the worker's key in the cluster.workers index.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 529\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 529\n      },\n      __self: this\n    }, \"worker.process :\"), \" This specifies a ChildProcess object referencing a worker.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 531\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 531\n      },\n      __self: this\n    }, \"worker.suicide :\"), \" The workers that have recently had kill or disconnect called on them will have their suicide attribute set to true.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 533\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 533\n      },\n      __self: this\n    }, \"worker.send(message, [sendHandle]) :\"), \" Refer to child_process.fork(), which is previously mentioned.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 535\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 535\n      },\n      __self: this\n    }, \"worker.kill([signal]) :\"), \" This kills a worker. The master can check this worker's suicide property in order to determine if the death was intentional or accidental. The default signal value that is sent is SIGTERM.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 538\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 538\n      },\n      __self: this\n    }, \"worker.disconnect() :\"), \" This instructs a worker to disconnect. Importantly, existing connections to the worker are not immediately terminated (as with kill), but are allowed to exit normally prior to the worker fully disconnecting. This is because existing connections may stay in existence for a very long time. It is a good pattern to regularly check if the worker has actually disconnected, perhaps using timeouts.\")), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 543\n      },\n      __self: this\n    }, React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 544\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 545\n      },\n      __self: this\n    }, \"Worker events:\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 546\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 546\n      },\n      __self: this\n    }, \"message :\"), \" See child_process.fork.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 547\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 547\n      },\n      __self: this\n    }, \"online :\"), \" This is identical to cluster.online, except that the check is against only the specified worker\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 549\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 549\n      },\n      __self: this\n    }, \"listening :\"), \" This is identical to cluster.listening, except that the check  is against only the specified worker\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 551\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 551\n      },\n      __self: this\n    }, \"disconnect :\"), \" This is identical to cluster.disconnect, except that the check is against only the specified worker\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 553\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 553\n      },\n      __self: this\n    }, \"exit :\"), \" See the exit event for child_process.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 554\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 554\n      },\n      __self: this\n    }, \"setup :\"), \" This is called after cluster.setupMaster has executed.\")), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 556\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: clusterModule,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 557\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 563\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 564\n      },\n      __self: this\n    }), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 565\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: clusting,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 566\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 572\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 574\n      },\n      __self: this\n    }, \"Scaling node js using cluster\"), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 575\n      },\n      __self: this\n    }, React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 576\n      },\n      __self: this\n    }, \"To handle large loads we cant take the advantage of multi-core systems, so we can use a cluster of Node.js processes to handle the load.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 577\n      },\n      __self: this\n    }, \"Cluster creates the copies of our programme and distributes among the process available which means if have four core machine then it will create the four copies of the programme and provides to each core. The cluster module allows easy creation of child processes that all share server ports.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 578\n      },\n      __self: this\n    }, \"Cluster manages with two methods of distributing incoming connections.\"), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 579\n      },\n      __self: this\n    }, React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 580\n      },\n      __self: this\n    }, \"1. Round-robin approach, where the master process listens on a port, accepts new connections and distributes them across the workers in a round-robin fashion, with some built-in smarts to avoid overloading a worker process.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 581\n      },\n      __self: this\n    }, \"2. In the master process creates the listen socket and sends it to interested workers. The workers then accept incoming connections directly. But the issue with that is load is not evenly distributed among all the processes.\")))))));\n  }\n\n}\n\nexport default withStyles(styles)(ChildsPros);","map":{"version":3,"sources":["/home/mukeshs/Projects/edurights/src/components/nodeJs/nodeDeep/childs.js"],"names":["React","Component","Prism","Grid","Paper","withStyles","List","Sidebar","PrismCode","titles","backgroundColor","padding","fontSize","styles","theme","paper","margin","spacing","smMargin","actionDiv","textAlign","spawns","trim","forkChild","execs","execFile","childsFile","clusterModule","spawning_processes","forkFiles","spawnFiles","clusting","cpus","ChildsPros","componentDidMount","setTimeout","highlightAll","render","classes","props"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport Prism from \"prismjs\"\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\n\nimport '../../ReactJs/styles.css'\nimport Sidebar from '../sidebar';\nimport PrismCode from '../../ReactJs/prismCode';\n\n\nconst titles = { backgroundColor: '#F0F8FF', padding: '1px', fontSize: '16px' }\n\nconst styles = theme => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1)\n  },\n  smMargin: {\n    margin: theme.spacing(1)\n  },\n  actionDiv: {\n    textAlign: \"center\"\n  }\n})\n\nconst spawns = `\nconst { spawn } = require(\"child_process\");\n\nconst child = spawn(\"find\", [\"/\"]);\n\nchild.stdout.on(\"data\", (data) => {\n  console.log('stdout: '$'{ data }');\n});\n\nchild.stderr.on(\"data\", (data) => {\n  console.log('stderr: '$'{ data } ');\n});\n\nchild.on(\"error\", (error) => console.log('error: '$'{ error.message }'));\n\nchild.on(\"exit\", (code, signal) => {\n  if (code) console.log('Process exit with code: '$'{ code } ');\n  if (signal) console.log('Process killed with signal: '$'{ signal }');\n  console.log('Done âœ…');\n});\n`.trim();\n\nconst forkChild = `\n//lovechild.js\nprocess.on('message', (msg) => {\n  console.log('Parent said: ', msg);\n  process.send(\"I love you too\");\n});\n\nconst cp = require('child_process');\nconst child = cp.fork(__dirname + '/lovechild.js');\n\nchild.on('message', (msg) => {\n    console.log('Child said: ', msg);\n});\n\nchild.send(\"I love you\");\n\n\n//2\n//child.js\nprocess.on('message', function(msg, server) {\n  console.log(msg);\n\n  server.on('connection', function(socket) {\n      socket.end('Child handled connection');\n  });\n});\n\nvar child = require('child_process').fork('./child.js');\nvar server = require('net').createServer();\n\nserver.on('connection', function(socket) {\n    socket.end('Parent handled connection');\n});\n\nserver.listen(8080, function() {\n    child.send(\"The parent message\", server);\n});`.trim();\n\nconst execs = `\nconst { exec, execFile } = require(\"child_process\");\n\n//dir generate code human readable byte formate\nexec(\"dir\", (error, stdout, stderr) => {\n  // exec(\"/find /\", (error, stdout, stderr) => {\n  // execFile(\"./somefile.sh\", (error, stdout, stderr) => {\n  // exec(\"pwd\", (error, stdout, stderr) => {\n  if (error) {\n    console.log('error: '$'{error.message}');\n    return;\n  }\n  if (stderr) {\n    console.log('stderr: '$'{stderr}');\n    return;\n  }\n  console.log('stdout: '$'{stdout}');\n});\n`.trim();\n\nconst execFile = `\n//child_process.execFile(file[, args][, options][, callback])\n\n\nconst { execFile } = require('child_process'); \n\n// Executes the exec.js file \nconst child = execFile('node', ['exec.js'], \n\t\t(error, stdout, stderr) => { \nif (error) { \n\tthrow error; \n} \nconsole.log(stdout); \n}); \n`.trim();\n\nconst childsFile = `\n//1\nvar id = process.argv[2];\nprocess.on('message', function(n, socket) {\n    socket.write('child ' + id + ' was your server today.\\r\\n');\n    socket.end();\n});\n\n\n//2\nvar spawn = require('child_process').spawn;\nvar php = spawn(\"php\", ['-r', 'print \"Hello from PHP!\";']);\n\nphp.stdout.on('readable', function() {\n    var d;\n    while (d = this.read()) {\n        console.log(d.toString());\n    }\n});`.trim();\n\nconst clusterModule = `\nvar cluster = require('cluster');\nvar http = require('http');\nvar numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n    for (var i = 0; i < numCPUs; i++) {\n        cluster.fork();\n    }\n}\n\nif (cluster.isWorker) {\n    http.createServer(function(req, res) {\n        res.writeHead(200);\n        res.end(\"Hello from \" + cluster.worker.id);\n    }).listen(8080);\n}`.trim();\n\nconst spawning_processes = `\nvar writer = fs.createWriteStream(\"./a.out\");\nwriter.on('open', function() {\n    var cp = spawn(\"node\", ['./reader.js'], { stdio: [null, writer, null] });\n});`.trim();\n\nconst forkFiles = `\nconst { fork } = require(\"child_process\");\n\napp.get(\"/one\", (req, res) => {\n  const sum = longComputation();\n  res.send({ sum: sum });\n});\n\napp.get(\"/two\", async (req, res) => {\n  const sum = await longComputePromise();\n  res.send({ sum: sum });\n});\n\n//this uses child process\napp.get(\"/three\", (req, res) => {\n  const child = fork(\"./longtask.js\");\n  child.send(\"start\");\n  child.on(\"message\", (sum) => {\n    res.send({ sum: sum });\n  });\n});\n\n\nfunction longComputation() {\n  let sum = 0;\n  for (let i = 0; i < 1e9; i++) {\n    sum += i;\n  }\n  return sum;\n}\n\nfunction longComputePromise() {\n  return new Promise((resolve, reject) => {\n    let sum = 0;\n    for (let i = 0; i < 1e9; i++) {\n      sum += i;\n    }\n    resolve(sum);\n  });\n}`.trim();\n\nconst spawnFiles = `\n`.trim();\n\nconst clusting = `\nconst cluster = require(\"cluster\");\nconst os = require(\"os\");\n\nconst numCpu = os.cpus().length;\n\napp.get(\"/\", (req, res) => {\n  for (let i = 0; i < 1000; i++) {}\n  res.send('OK '$'{process.pid}');\n  cluster.worker.kill();\n});\n\nif (cluster.isMaster) {\n  for (let i = 0; i < numCpu; i++) {\n    cluster.fork();\n  }\n  cluster.on(\"exit\", (Worker, code, signal) => {\n    console.log('worker '$'{Worker.process.pid} died');\n    cluster.fork();\n  });\n} else {\n  app.listen(5000, () =>\n    console.log('Server running on port 5000')\n  );\n}`.trim();\n\nconst cpus = `\nconst os = require('os')\nconst cluster = require('cluster')\n\n//check own cpu\nconsole.log(os.cpus())\n\n//master, worker\nif (cluster.isMaster) {\n  let noOcCups = os.cpus().length;\n  console.log('Master Process is running', process.pid)\n  for (let i = 0; i < noOcCups; i++) {\n    cluster.fork()\n  }\n  cluster.on('exit', () => {\n    console.log('One worker destroyed')\n    cluster.fork()\n  })\n}\n`.trim();\n\nclass ChildsPros extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0)\n  }\n  render() {\n    const { classes } = this.props;\n    return (\n      <Grid container>\n        <Grid item xs={2}>\n          <Paper className={classes.paper}>\n            <h4><Sidebar /></h4>\n          </Paper>\n        </Grid>\n        <Grid item xs={10}>\n          <Paper className={classes.paper}>\n            <List>\n              <h3>Communicating with your child</h3>\n              <ul>\n                All ChildProcess object extend EventEmitter.\n                ChildProcess objects expose some useful methods for interacting with children directly.\n                <li><b>child.connected :</b> When a child is disconnected from its parent via  child.disconnect(), this flag will be set to false.\n                </li>\n                <li><b>child.stdin :</b> Is a WritableStream.</li>\n                <li><b>child.stdout :</b> Is a ReadableStream.</li>\n                <li><b>child.stderr :</b> Is a ReadableStream corresponding to the child's standard error.</li>\n                <li><b>child.pid :</b> Is an integer representing the process ID (PID) assigned  to the child process.</li>\n                <li><b>child.kill :</b> Tries to terminate a child process, sending it an optional signal. If no signal is specified, the\n                  default is SIGTERM. While the terminal method, it is not guaranteed to kill a processâ€”it only sends  a signal\n                  to a process.</li>\n                <li><b>child.disconnect() :</b> This command severs the IPC connection between the child and its parent. The child will then die\n                  gracefully, as it has no IPC channel to keep it alive. You may also call process.disconnect() from within the child\n                  itself. Once a child has disconnected, the connected flag  on that child reference will be set to false.</li>\n              </ul>\n              <br />\n\n              <h3>Create Child</h3>\n              <p>\n                Creating a Child Process with exec().\n                The exec() function in Node.js creates a new shell process and executes a command in\n                that shell. The output of the command is kept in a buffer in memory, which\n                you can accept via a callback function passed into exec().\n              </p>\n              <p>\n                In Node.js CPU\n                cannot handle increasing workload so, the child_process module can be used to spawn child\n                processes. The child processes communicate with each other using a built-in messaging system.\n              </p>\n              The following are the four different ways to create a child process in Node.js:\n              <ul>\n                <li>spawn() method</li>\n                <li>fork() method</li>\n                <li>exec() method</li>\n                <li>execFile() method</li>\n              </ul>\n              <br />\n\n              <h3>Spawning Processes</h3>\n              <ul>\n              it creates a streaming interface between the parent and child process.\n              <br/>\n                The method takes three arguments:\n                <li><b>command :</b> A command to be executed by the OS shell.</li>\n                <li><b>arguments (optional) :</b> These are command-line arguments, sent as an array.</li>\n                <li><b>options :</b> An optional map of settings for spawn.</li>\n                <br />\n                <br />\n                <b>The options for spawn allow its behavior to be carefully customized:</b>\n                <li><b>cwd (String) :</b> By default, the command will understand its current working directory to be the same as that of the Node\n                  process calling spawn. Change that setting using this directive.</li>\n                <li><b>env (Object) :</b> This is used to pass environment variables to a child process.</li>\n                <li><b>detached (Boolean) :</b> When a parent spawns a child, both processes form  a group, and the parent is normally the leader\n                  of that group. To make a child the group leader, use detached. This will allow the child to continue running even after\n                  the parent exits. This is because the parent will wait for the child to exit by default. You can call child.unref() to\n                  tell the parent's event loop that it should not count the child reference, and exit if no other work exists.\n                </li>\n                <li><b>uid (Number) :</b> Set the uid (user identity) directive for the child process, in terms of standard system permissions,\n                  such as a UID that has execute privileges on the child process.</li>\n                <li><b>gid (Number) :</b> Set the gid (group identity) directive for the child process, in terms of standard system permissions,\n                  such as a GID that has execute privileges on the child process.</li>\n                <li><b>stdio (String or Array) :</b> Child processes have file descriptors, the first three being the standard I/O descriptors\n                  process.stdin, process.stdout and process.stderr, in order (fds = 0,1,2). This directive allows those descriptors to be\n                  redefined, inherited, and so forth. Consider the output of the following child process program:\n                  <br />\n                  process.stdout.write(new Buffer(\"Hello!\"));</li>\n              </ul>\n              <div style={titles}>\n                <PrismCode\n                  code={spawning_processes}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <p>\n                <b>1. spawn() method: </b>This method spawns a new process using the given command and the command line\n                arguments in args. The ChildProcess instance implements EventEmitterAPI which enables us to\n                register handlers for events on child object directly. Some events that can be registered for\n                handling with the ChildProcess are exit, disconnect, error, close and message.\n              </p>\n              <br />\n              <div style={titles}>\n                <PrismCode\n                  code={spawns}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <br />\n\n              <b>2. fork() method</b>\n              <p>\n                The child_process.fork() is a special case of child_process.spawn() where the parent and the\n                child process can communicate with each other via send(). \n                <br/>\n                It creates a communication channel between the parent and child process.\n              </p>\n              <ul>\n                <li>first synchronous</li>\n                <li>npm install loadtest -g</li>\n                <li>loadtest -n 10 -c 10 http://localhost:5000/first</li>\n                <li>and see time took to handle total request</li>\n                <br />\n                <li>second async</li>\n                <li>fork method in child-process and do inter-process communication.</li>\n              </ul>\n              <br />\n              <div style={titles}>\n                <PrismCode\n                  code={forkFiles}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <br />\n              <br />\n\n              <b>fork() method2</b>\n              <p>To create a child process one need simply call the fork method of the child_process module, passing it the name of a\n                program file to execute within the new process:\n                <br />\n                In this way any number of subprocesses can be kept running.</p>\n              <p>\n                Another very powerful idea is to pass a network server an object to a child. This technique allows multiple processes,\n                including the parent, to share the responsibility for servicing connection requests, spreading load across cores.\n                <br />\n                In addition to passing a message to a child process as the first argument to send, the preceding code also sends the\n                server handle to itself as a second argument. Our child server can now help out with the family's service business:\n\n              </p>\n              <div style={titles}>\n                <PrismCode\n                  code={forkChild}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <br />\n\n              <b>3. exec() method</b>\n              <p>This method creates a shell first and then executes the command.</p>\n              <div style={titles}>\n                <PrismCode\n                  code={execs}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <br />\n\n              <b>4. execFile() method</b>\n              <p>\n                The child_process.execFile() function is does not spawn a shell by default. It is slightly more\n                efficient than child_process.exec() as the specified executable file is spawned directly as a new\n                process.\n              </p>\n              <div style={titles}>\n                <PrismCode\n                  code={execFile}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3>Child</h3>\n              It should be noted that the ability to spawn any system process means that one can use Node to run other application\n              environments installed on the OS. If one had the popular PHP language installed, the following would be possible:\n              <div style={titles}>\n                <PrismCode\n                  code={childsFile}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3>Cluster Module</h3>\n              Cluster module allows to create child processes that each runs on their own single thread, to handle the load.\n              <br />\n              <br />\n              <ul>\n                <li>\n                  Cluster is a process to handle thread execution load while working with multi-core systems.\n                </li>\n                <li>\n                  To split a single Node process into multiple processes. The cluster module provides a way of creating child processes\n                  that runs simultaneously and share the same server port.\n                </li>\n                <li>\n                  But to take advantage of computers multi-core systems, the Cluster module allows you to easily create child processes\n                  that each runs on their own single thread, to handle the load.\n                </li>\n              </ul>\n              <br />\n              <div style={titles}>\n                <PrismCode\n                  code={cpus}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <br />\n              <ul>\n                The following code creates a cluster of worker processes all sharing  the same HTTP connection.\n                <li><b>cluster.isMaster :</b> This is the Boolean value indicating whether the process is a master.</li>\n                <li><b>cluster.isWorker :</b> This is the Boolean value indicating whether the process was forked from a master.</li>\n                <li><b>cluster.worker :</b> This will bear a reference to the current worker object, only available to a child process.</li>\n                <li><b>cluster.workers :</b> This is a hash containing references to all active worker objects, keyed by the worker ID. Use this to\n                  loop through all worker objects. This only exists within the master process.</li>\n                <li><b>cluster.fork([env] ) :</b> This creates a new worker process. Only the master process may call this method. To expose a map\n                  of key-value pairs to the child's process environment, send an object to env. </li>\n                <li><b>cluster.disconnect([callback]) :</b> This is used to terminate all workers  in a cluster. Once all the workers have died\n                  gracefully, the cluster process will itself terminate if it has no further events to wait on. To be notified  when all\n                  children have expired, pass callback.</li>\n              </ul>\n              <ul>\n                cluster.setupMaster([settings]): This is a convenient way of passing a map of default arguments to be used when a child\n                is forked. If all children are going to fork the same file, you will save time by setting it here. The available defaults\n                are as follows:\n                <li><b>exec (String) :</b> This is the file path to the process file, defaulting  to __filename.</li>\n                <li><b>args (Array) :</b> This contains Strings sent as arguments to the child process. The default is to fetch arguments with\n                  process.argv. slice(2). </li>\n                <li><b>silent (Boolean) :</b> This specifies whether or not to send output  to the master's stdio, defaulting to false.\n                </li>\n                <li></li><b>silent (Boolean) :</b> This specifies whether or not to send output  to the master's stdio, defaulting to false.\n              </ul>\n              <br />\n              <b>Cluster events:</b>\n              <ul>\n                <li><b>fork :</b> This is fired when the master tries to fork a new child. This is not the same as online. This receives a worker\n                  object. </li>\n                <li><b>online :</b> This is fired when the master receives notification that a child is fully bound. This differs from the fork\n                  event and receives a worker object. â€¢ listening: When the worker performs an action that requires a listen() call\n                  (such as starting an HTTP server), this event will be fired in the master. The event emits two arguments: a worker object,\n                  and the address object containing the address, port, and addressType values of the connection.\n                </li>\n                <li><b>disconnect :</b> This is called whenever a child disconnects, which can happen either through process exit events or after\n                  calling child.kill(). This will fire prior to the exit eventâ€”they are not the same. This receives a worker object.\n                </li>\n                <li><b>exit :</b> Whenever a child dies this event is emitted. The event receives three arguments: a worker object, the exit code\n                  number, and the signal string, such as SIGNUP, which caused the process to be killed.\n                </li>\n                <li><b>setup :</b> This is called after cluster.setupMaster has executed.</li>\n              </ul>\n              <ul>\n                <br />\n                <b>Worker object properties:</b>\n                <li><b>worker.id :</b> This is the unique ID assigned to a worker, also representing the worker's key in the cluster.workers index.\n                </li>\n                <li><b>worker.process :</b> This specifies a ChildProcess object referencing a worker.\n                </li>\n                <li><b>worker.suicide :</b> The workers that have recently had kill or disconnect called on them will have their suicide attribute\n                  set to true.</li>\n                <li><b>worker.send(message, [sendHandle]) :</b> Refer to child_process.fork(), which is previously mentioned.\n                </li>\n                <li><b>worker.kill([signal]) :</b> This kills a worker. The master can check this worker's suicide property in order to determine\n                  if the death was intentional or accidental. The default signal value that is sent is SIGTERM.\n                </li>\n                <li><b>worker.disconnect() :</b> This instructs a worker to disconnect. Importantly, existing connections to the worker are not\n                  immediately terminated (as with kill), but are allowed to exit normally prior to the worker fully disconnecting. This is\n                  because existing connections may stay in existence for a very long time. It is a good pattern to regularly check if the\n                  worker has actually disconnected, perhaps using timeouts.</li>\n              </ul>\n              <ul>\n                <br />\n                <b>Worker events:</b>\n                <li><b>message :</b> See child_process.fork.</li>\n                <li><b>online :</b> This is identical to cluster.online, except that the check is against only the specified worker\n                </li>\n                <li><b>listening :</b> This is identical to cluster.listening, except that the check  is against only the specified worker\n                </li>\n                <li><b>disconnect :</b> This is identical to cluster.disconnect, except that the check is against only the specified worker\n                </li>\n                <li><b>exit :</b> See the exit event for child_process.</li>\n                <li><b>setup :</b> This is called after cluster.setupMaster has executed.</li>\n              </ul>\n              <div style={titles}>\n                <PrismCode\n                  code={clusterModule}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <br />\n              <div style={titles}>\n                <PrismCode\n                  code={clusting}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3>Scaling node js using cluster</h3>\n              <ul>\n                <li>To handle large loads we cant take the advantage of multi-core systems, so we can use a cluster of Node.js processes to handle the load.</li>\n                <li>Cluster creates the copies of our programme and distributes among the process available which means if have four core machine then it will create the four copies of the programme and provides to each core. The cluster module allows easy creation of child processes that all share server ports.</li>\n                <li>Cluster manages with two methods of distributing incoming connections.</li>\n                <ul>\n                  <li>1. Round-robin approach, where the master process listens on a port, accepts new connections and distributes them across the workers in a round-robin fashion, with some built-in smarts to avoid overloading a worker process.</li>\n                  <li>2. In the master process creates the listen socket and sends it to interested workers. The workers then accept incoming connections directly. But the issue with that is load is not evenly distributed among all the processes.</li>\n                </ul>\n              </ul>\n            </List>\n          </Paper>\n        </Grid>\n      </Grid>\n    )\n  }\n}\n\nexport default (withStyles(styles)(ChildsPros));\n"]},"metadata":{},"sourceType":"module"}