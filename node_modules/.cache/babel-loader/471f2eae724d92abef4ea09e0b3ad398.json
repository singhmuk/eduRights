{"ast":null,"code":"import _classCallCheck from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/createClass\";import _possibleConstructorReturn from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";import _getPrototypeOf from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";import _inherits from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/inherits\";import React,{Component}from\"react\";import Prism from\"prismjs\";import{Grid,Paper,withStyles,List}from\"@material-ui/core\";import\"../../ReactJs/styles.css\";import Sidebar from\"../sidebar\";import PrismCode from\"../../ReactJs/prismCode\";var titles={backgroundColor:\"#F0F8FF\",padding:\"1px\",fontSize:\"16px\"};var styles=function styles(theme){return{paper:{margin:theme.spacing(1),padding:theme.spacing(1)},smMargin:{margin:theme.spacing(1)},actionDiv:{textAlign:\"center\"}};};var basicRouter=\"\\nimport { NgModule } from '@angular/core';\\nimport { Routes, RouterModule, PreloadAllModules } from '@angular/router';\\nimport { SignupComponent } from './order/signup.component';\\n\\nconst routes: Routes = [\\n  { path:'signup', component:SignupComponent }\\n];\\n\\n@NgModule({\\n  imports: [RouterModule.forRoot(routes)],\\n  exports: [RouterModule]\\n})\\nexport class AppRoutingModule { }\\n\\n//\\n<a routerLink='login'>Login</a>\\n<a routerLink='signup'>Signp</a>\\n\\n<router-outlet></router-outlet>\\n\".trim();var addcomponents=\"\\nrouter.navigateByUrl(\\\"/team/1\\\");\\nrouter.navigate(['team' ,1]);\\n\".trim();var forRoots=\"\\nimport { NgModule } from '@angular/core';\\nimport { RouterModule, Routes } from '@angular/router';\\n\\n\\nconst routes: Routes = [\\n  { path: '', component: HomeComponent },\\n  { path: 'contact', component: ContactComponent }\\n];\\n\\n@NgModule({\\n  imports: [RouterModule.forRoot(routes)],\\n  exports: [RouterModule]\\n})\\nexport class AppRoutingModule { }\\n\".trim();var forChilds=\"\\nconst routes: Routes = [\\n  { path: 'products', component: ProductComponent }\\n];\\n\\n@NgModule({\\n  imports: [RouterModule.forChild(routes)],\\n  exports: [RouterModule]\\n})\\nexport class ProductRoutingModule { }\\n\".trim();var routerLink=\"\\n<my-tile [routerLink]=\\\"['/secondPage', item.id, 'item-list']\\\" *ngFor=\\\"let item of listaOfItem\\\" [item]=\\\"item\\\">\\n</my-tile>\\n\".trim();var CanActivate=\"\\nimport { Injectable } from '@angular/core';\\nimport { Router, CanActivate } from '@angular/router';\\nimport { AuthService } from './auth.service';\\n\\n@Injectable()\\nexport class AuthGuardService implements CanActivate {\\n  constructor(public auth: AuthService, public router: Router) {}\\n  canActivate(): boolean {\\n    if (!this.auth.isAuthenticated()) {\\n      this.router.navigate(['login']);\\n      return false;\\n    }\\n    return true;\\n  }\\n}\\n\".trim();var angularRouter=\"import { RouterModule, Routes } from '@angular/router';\".trim();var routerState=\"\\n@Component({templateUrl:'template.html'})\\nclass MyComponent {\\n  constructor(router: Router) {\\n    const state: RouterState = router.routerState;\\n    const root: ActivatedRoute = state.root;\\n    const child = root.firstChild;\\n    const id: Observable<string> = child.params.map(p => p.id);\\n    //...\\n  }\\n}\".trim();var multipleRoute=\"\\nconst routes: Routes = [\\n  { path:\\\"\\\",  component:HomeComponent },\\n  { path:\\\"about\\\", redirectTo:\\\"signup\\\", pathMatch:\\\"full\\\", component:AboutComponent },\\n  { path:'profile/:username', component:ProfileComponent },\\n  { path:'profile/:username/:userid', component:ProfileComponent }\\n];\\n\\n\\n//about.component.ts\\nimport {ActivatedRoute } from '@angular/router';\\n\\nexport class AboutComponent implements OnInit {\\n  username=\\\"\\\";\\n  name1=\\\"\\\";\\n  name2=\\\"\\\";\\n  userid1=\\\"\\\";\\n  userid2=\\\"\\\";\\n  constructor( private route: ActivatedRoute, ) {}\\n \\n\\n  ngOnInit(): void {\\n\\n    this.route.params.subscribe(params => {      //pass data as parameter\\n        this.name1 = params['username'];\\n        this.userid1=params['userid'];\\n     });\\n\\n    this.route.queryParams.subscribe(params => {  //pass data as query string parameter\\n        this.name2 = params['username'];\\n        this.userid2=params['userid'];\\n     });\\n  }\\n}\\n\\n\\n//browser url show through template\\n<h1>Parameter User Profile</h1>\\n<h2>Username:{{name1}}</h2>\\n<h2>User ID:{{userid1}}</h2>\\n\".trim();var currentRoute=\"\\n<router-outlet></router-outlet>                          //Unnamed router outlet as primary outlet\\n<router-outlet name=\\\"second\\\"></router-outlet>            //named router outlet as secondary outlet\\n\\n\\n//app-routing.module.ts\\nconst routes: Routes = [\\n  {\\n    path:'customer', loadChildren:()=>import('./customer/customer.module') .then(mod=>mod.CustomerModule), \\n      component:CustomerComponent\\n  },\\n  { path:'customerdetails',  component:CudtomerdetailsComponent, outlet:'customerList' },\\n  {\\n    path:'order', loadChildren:()=>import('./order/order.module') .then(mod=>mod.OrderModule),\\n      component:OrderComponent\\n  }\\n];\\n\\n\\n//app.component.ts\\nimport {UserdataService} from './userdata.service';\\n\\n@Component({\\n  selector: 'app-root',\\n  template: '\\n      <a routerLink=\\\"customer\\\">Customer</a><br/>\\n      <a [routerLink]=\\\"[{Outlets:{customerList:['customerdetails']}}]\\\">Details</a><br/>\\n\\n      <a routerLink=\\\"order\\\">Order</a>\\n\\n      <router-outlet></router-outlet>\\n      <router-outlet name=\\\"customerList\\\"></router-outlet>\\n  ',\\n  providers:[UserdataService]\\n})\\n\\nexport class AppComponent {}\\n\".trim();var routerLinkActive=\"\\n<a routerLink=\\\"/\\\" routerLinkActive=\\\"active\\\" [routerLinkActiveOptions]=\\\"{exact:true}\\\">Home</a><br/>\\n<a routerLink=\\\"/about\\\" routerLinkActive=\\\"active\\\">About</a><br/>\\n<a routerLink=\\\"/login\\\" routerLinkActive=\\\"active\\\">Login</a><br/>\\n<a routerLink=\\\"/signup\\\" routerLinkActive=\\\"active\\\">SignUp</a><br/>\\n<a routerLink=\\\"/profile\\\" routerLinkActive=\\\"active\\\">Profile</a>\\n\".trim();var routrtDetect=\"\\n//html\\n<p>Current route: {{ currentRoute }}</p>\\n\\n\\nimport { ActivatedRoute } from '@angular/router';\\n\\nexport class MyComponent implements OnInit {\\n  currentRoute: string;\\n\\n  constructor(private route: ActivatedRoute) {}\\n\\n  ngOnInit() {\\n    this.route.params.subscribe(params => {\\n      this.currentRoute = params['id'];\\n      console.log('Route changed to: ', this.currentRoute);\\n    });\\n  }\\n}\\n\".trim();var resolvers=\"\\nconst routes: Routes = [\\n  {\\n    path: 'app', component: RoutesComponent,\\n    resolve: {\\n      exampleData: ExampleResolverService\\n    }\\n  }\\n];\\n\".trim();var NgrxCounter=/*#__PURE__*/function(_Component){_inherits(NgrxCounter,_Component);function NgrxCounter(){_classCallCheck(this,NgrxCounter);return _possibleConstructorReturn(this,_getPrototypeOf(NgrxCounter).apply(this,arguments));}_createClass(NgrxCounter,[{key:\"componentDidMount\",value:function componentDidMount(){setTimeout(function(){return Prism.highlightAll();},0);}},{key:\"render\",value:function render(){var classes=this.props.classes;return React.createElement(Grid,{container:true},React.createElement(Grid,{item:true,xs:2},React.createElement(Paper,{className:classes.paper},React.createElement(\"h4\",null,React.createElement(Sidebar,null)))),React.createElement(Grid,{item:true,xs:10},React.createElement(Paper,{className:classes.paper},React.createElement(List,null,React.createElement(\"h3\",null,\"1. Basic Routing\"),\"Router basically means navigating b/w pages. we have seen many sites with links that direct us to a new page.\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:basicRouter,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"2. Routing with multiple route parameter\"),\"We should define custome route before wildcard route. Otherwise it not work if we define after wildcard route.\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:multipleRoute,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"3. Name & Multiple router-outlets\"),\"Router-outlet work as a placeholder which is used to load the different components dynamically based on the activated component or current route state.\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:currentRoute,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"4. routerLinkActive\"),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:routerLinkActive,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"5. What are the router imports\"),\"The router imports in Angular are used to configure and manage the application's routing functionality. The following are some of the router imports in Angular:\",React.createElement(\"br\",null),React.createElement(\"ul\",null,React.createElement(\"li\",null,React.createElement(\"b\",null,\"RouterModule: \"),\"This is the core Angular module that provides the routing functionality for the application. It includes several classes and methods for configuring routes, navigating between routes, and handling route-related events.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Routes: \"),\"This is an array of route objects that define the application's routing configuration. Each route object specifies a path, a component, and other optional properties such as data, guards, and resolvers.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Router: \"),\"This is the Angular service that provides methods for navigating between routes, accessing the current route, and subscribing to route-related events.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"ActivatedRoute: \"),\"This is a service that provides information about the current route, including the route parameters, query parameters, and route data.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"RouterLink: \"),\"This is a directive that is used in HTML templates to create links between routes. It takes a path as input and generates a link to the corresponding route.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"RouterOutlet: \"),\"This is a directive that is used in HTML templates to define the location where the component corresponding to the current route should be displayed.\"),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"li\",null,\"These router imports are essential for setting up the routing functionality in an Angular application. By configuring the routes, using the router and activated route services, and utilizing the router link and outlet directives, developers can create a seamless and intuitive user experience for their application.\")),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:angularRouter,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"h3\",null,\"6. What are Router Events\"),\"Router Events in Angular are a set of events emitted by the Angular Router whenever the navigation state changes. The Router Events provide a way to track and respond to changes in the application's navigation, and they can be used to perform tasks such as updating the UI, tracking user behavior, or logging navigation events.\",React.createElement(\"br\",null),React.createElement(\"ul\",null,React.createElement(\"li\",null,React.createElement(\"b\",null,\"NavigationStart: \"),\"Emitted when navigation starts.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"RoutesRecognized: \"),\"Emitted when the Router has recognized the new route and is about to activate it.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"RouteConfigLoadStart: \"),\"Emitted when the Router begins loading a lazy-loaded route configuration.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"RouteConfigLoadEnd: \"),\"Emitted when the Router has finished loading a lazy-loaded route configuration.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"NavigationEnd: \"),\"Emitted when navigation has successfully completed.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"NavigationCancel: \"),\"Emitted when navigation has been cancelled.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"NavigationError: \"),\"Emitted when navigation has failed due to an error.\")),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"7. What is the use of router-outlet in angular 8.\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Router outlet is a dynamic component that router uses to display views based on router navigations.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"It tells the router where to display routed views.\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"8. Difference between navigate and navigatebyurl in angular.\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"navigate method accept an array and it construct the root path while, navigateByUrl accept an string which give us root path.\"),React.createElement(\"li\",null,\"Using navigate method we can also achieved relative path by\",\" \",React.createElement(\"b\",null,\"relativeTo\"),\" option while, navigateByUrl can be use only for absolute path.\")),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:addcomponents,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"1. What is the difference between forChild and forRoot? \"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"In Angular, forRoot() and forChild() are two methods provided by the RouterModule to configure the router module. The main difference between them is that forRoot() should be used only in the root AppModule of the application, while forChild() should be used in all the other modules.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"The forRoot() method is used to configure the router at the application level, and it sets up the router with the routes and other configuration options required by the root module.\"),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:forRoots,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"li\",null,\"forChild() method is used to configure the router in feature modules.\"),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:forChilds,language:\"js\",plugins:[\"line-numbers\"]}))),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"9. How do you detect route change in Angular?\"),\"can detect route changes using the ActivatedRoute service and the Router module.\",React.createElement(\"br\",null),React.createElement(\"br\",null),\"One way to detect route changes is to subscribe to the params property of the ActivatedRoute service. This property is an observable that emits a new value whenever the route parameters change.\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:routrtDetect,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"10. What is pathMatch in angular routing?\"),\"In Angular routing, pathMatch is a configuration option that determines how to match the URL segments to the configured route path.\",React.createElement(\"br\",null),React.createElement(\"br\",null),\"There are two possible values for the pathMatch option:\",React.createElement(\"ul\",null,React.createElement(\"li\",null,React.createElement(\"b\",null,\"prefix: \"),\"This value indicates that the router should match the configured route path if the URL starts with the specified path. This is the default value if pathMatch is not specified.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"full: \"),\"This value indicates that the router should match the configured route path if the URL matches the entire path.\")),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"11. Difference between Angular's canLoad and canActivate?\"),\"Both canLoad and canActivate are Angular route guards that can be used to protect routes in an Angular application, but they are used in different scenarios.\",React.createElement(\"ul\",null,React.createElement(\"li\",null,React.createElement(\"b\",null,\"canActivate: \"),\"Is a route guard that is used to protect a route after it has been loaded. When a user navigates to a protected route, canActivate is called before the route is activated. canActivate returns either a boolean value or an observable that resolves to a boolean value. If canActivate returns true, the route is activated, and the user can proceed. If canActivate returns false, the route is not activated, and the user is redirected to a different page.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"canLoad: \"),\" Is a route guard that is used to protect a route before it is loaded. When a user navigates to a route that requires lazy loading, canLoad is called before the module containing the route is loaded. canLoad returns either a boolean value or an observable that resolves to a boolean value. If canLoad returns true, the module is loaded, and the user can proceed. If canLoad returns false, the module is not loaded, and the user is redirected to a different page.\")),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"12. What is router state\"),\"RouterState is a tree of activated routes. Every node in this tree knows about the URL segments, the extracted parameters, and the resolved data.\",React.createElement(\"br\",null),\"You can access the current RouterState from anywhere in the application using the Router service and the routerState property.\",React.createElement(\"br\",null),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:routerState,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"13. How to specify which route to navigate to in NavLink?\"),\"To specify which route to navigate to, use the to prop and pass the path name. The activeClassName prop will add an active class to the link if it\\u2019s currently active. On the browser, the NavLink component is rendered as an tag with an href attribute value that was passed in prop.\",React.createElement(\"br\",null),React.createElement(\"h3\",null,\"14. When to use absolute path in navigate method?\"),\"Navigate Method always uses the absolute path unless you provide a starting point. \",React.createElement(\"b\",null,\"navigate.navigateByUrl\"),\" Use this method if you want to navigate to a URL by using the absolute path. The first argument is a string containing the complete URL.\",React.createElement(\"br\",null),React.createElement(\"h3\",null,\"15. What is Routing Guard in Angular?\"),\"Angular\\u2019s route guards tell the router whether or not it should allow navigation to a requested route. They make this decision by looking for a true or false return value from a class which implements the given guard interface.\",React.createElement(\"br\",null),React.createElement(\"br\",null),\"There are five different types of guards:\",React.createElement(\"ul\",null,React.createElement(\"li\",null,\"CanActivate\"),React.createElement(\"li\",null,\"CanActivateChild\"),React.createElement(\"li\",null,\"CanDeactivate\"),React.createElement(\"li\",null,\"CanLoad\"),React.createElement(\"li\",null,\"Resolve\")),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:CanActivate,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"16. Pass complex JSON via routerLink.\"),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:routerLink,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"What is a resolver in Angular and how is it used?\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"In Angular, a resolver is a service that is used to retrieve data before a route is activated. It allows you to fetch data and perform any necessary operations before the component is rendered. This can be useful for scenarios where you need to fetch data from an API or perform some other async operation before rendering the component.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"When a resolver is added to a route, it ensures that the data is available to the component before it is rendered. This can help prevent issues with data being unavailable or incorrect during rendering, as the resolver ensures that the data is loaded and ready to use.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"To create a resolver in Angular, you can create a service that implements the Resolve interface and defines a resolve() method. This method should return an observable that resolves to the data that you want to load. You can then add the resolver to the resolve property of the route definition.\")),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:resolvers,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"17. Angular by default, uses client-side rendering for its applications. Can one make an angular application to render on the server-side?\"),\"Yes, with\\xA0Angular Universal, Angular application can render on the server-side.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"The advantages of using Angular Universal are :\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"First time users can instantly see a view of the application. This providing\\xA0better user experience.\"),React.createElement(\"li\",null,\"Many search engines expect pages in plain HTML, thus, Universal can make sure that your content is available on every search engine, which leads to\\xA0better SEO.\"),React.createElement(\"li\",null,\"Any server-side rendered application\\xA0loads faster\\xA0since rendered pages are available to the browser sooner.\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"18. How does one share data between components in Angular?\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Parent to child using @Input decorator\"),React.createElement(\"li\",null,\"Child to parent using @Output with EventEmitter and @ViewChild decorator\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"19. What are filters in Angular? Name a few of them.\"),\"Filters are used to format an expression and present it to the user.\",React.createElement(\"ol\",null,React.createElement(\"li\",null,\"Date\"),React.createElement(\"li\",null,\"filter\"),React.createElement(\"li\",null,\"Json\"),React.createElement(\"li\",null,\"limitTo\"),React.createElement(\"li\",null,\"lowercase\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"20. What type of DOM does Angular implement?\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Angular uses the regular DOM. This updates the entire tree structure of HTML tags until it reaches the data to be updated. However, to ensure that the speed and performance are not affected, Angular implements Change Detection.\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"21. What is DOM?\"),\"It is responsible for representing the content of a web page and changes in the architecture of an application. Here, all the objects are organized in the form of a tree, and the document can easily be modified, manipulated, and accessed only with the help of APIs.\",React.createElement(\"br\",null),React.createElement(\"h3\",null,\"22. Shadow DOM\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Shadow DOM is a feature of web components that allows encapsulation of HTML, CSS, and JavaScript. In Angular, Shadow DOM is used to encapsulate component styles and HTML templates, ensuring that they do not leak out and affect other parts of the application.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"When a component is created in Angular, it is rendered within a Shadow DOM root. The Shadow DOM root is a separate DOM tree that is attached to the main document's DOM tree, but is not part of it. This allows the component to have its own isolated CSS styles and HTML structure, which cannot be affected by styles or elements outside of the component.\"),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"li\",null,\"Angular uses the ViewEncapsulation metadata property to control how a component's styles are encapsulated.\",React.createElement(\"br\",null),React.createElement(\"br\",null),\"determines whether the styles defined in a particular component will affect the entire application or not. Angular supports 3 types of ViewEncapsulation:\"),React.createElement(\"br\",null),React.createElement(\"ul\",null,React.createElement(\"li\",null,React.createElement(\"b\",null,\"Emulated: \"),\"This is the default value, and it emulates the behavior of Shadow DOM by adding unique CSS selectors to the component's styles, making it more difficult for them to be overridden by external styles.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Native: \"),\" This value uses the native Shadow DOM implementation to encapsulate a component's styles. This means that the component's styles are completely isolated from the rest of the application.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"None: \"),\"This value disables encapsulation and allows a component's styles to be applied globally, potentially affecting other parts of the application.\"))),React.createElement(\"br\",null),\"Overall, Shadow DOM in Angular provides a powerful way to encapsulate component styles and templates, ensuring that they do not leak out and affect other parts of the application. By using the ViewEncapsulation metadata property, developers can control how a component's styles are encapsulated, and ensure that they behave as expected.\"))));}}]);return NgrxCounter;}(Component);export default withStyles(styles)(NgrxCounter);","map":{"version":3,"sources":["/home/mukeshs/Projects/edurights/src/components/angularjsd/angular 12/flows.js"],"names":["React","Component","Prism","Grid","Paper","withStyles","List","Sidebar","PrismCode","titles","backgroundColor","padding","fontSize","styles","theme","paper","margin","spacing","smMargin","actionDiv","textAlign","basicRouter","trim","addcomponents","forRoots","forChilds","routerLink","CanActivate","angularRouter","routerState","multipleRoute","currentRoute","routerLinkActive","routrtDetect","resolvers","NgrxCounter","setTimeout","highlightAll","classes","props"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport Prism from \"prismjs\";\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\n\nimport \"../../ReactJs/styles.css\";\nimport Sidebar from \"../sidebar\";\nimport PrismCode from \"../../ReactJs/prismCode\";\n\nconst titles = { backgroundColor: \"#F0F8FF\", padding: \"1px\", fontSize: \"16px\" };\n\nconst styles = (theme) => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1),\n  },\n  smMargin: {\n    margin: theme.spacing(1),\n  },\n  actionDiv: {\n    textAlign: \"center\",\n  },\n});\n\nconst basicRouter = `\nimport { NgModule } from '@angular/core';\nimport { Routes, RouterModule, PreloadAllModules } from '@angular/router';\nimport { SignupComponent } from './order/signup.component';\n\nconst routes: Routes = [\n  { path:'signup', component:SignupComponent }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n\n//\n<a routerLink='login'>Login</a>\n<a routerLink='signup'>Signp</a>\n\n<router-outlet></router-outlet>\n`.trim();\n\nconst addcomponents = `\nrouter.navigateByUrl(\"/team/1\");\nrouter.navigate(['team' ,1]);\n`.trim();\n\nconst forRoots = `\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\n\n\nconst routes: Routes = [\n  { path: '', component: HomeComponent },\n  { path: 'contact', component: ContactComponent }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n`.trim();\n\nconst forChilds = `\nconst routes: Routes = [\n  { path: 'products', component: ProductComponent }\n];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule]\n})\nexport class ProductRoutingModule { }\n`.trim();\n\nconst routerLink = `\n<my-tile [routerLink]=\"['/secondPage', item.id, 'item-list']\" *ngFor=\"let item of listaOfItem\" [item]=\"item\">\n</my-tile>\n`.trim();\n\nconst CanActivate = `\nimport { Injectable } from '@angular/core';\nimport { Router, CanActivate } from '@angular/router';\nimport { AuthService } from './auth.service';\n\n@Injectable()\nexport class AuthGuardService implements CanActivate {\n  constructor(public auth: AuthService, public router: Router) {}\n  canActivate(): boolean {\n    if (!this.auth.isAuthenticated()) {\n      this.router.navigate(['login']);\n      return false;\n    }\n    return true;\n  }\n}\n`.trim();\n\nconst angularRouter =\n  `import { RouterModule, Routes } from '@angular/router';`.trim();\n\nconst routerState = `\n@Component({templateUrl:'template.html'})\nclass MyComponent {\n  constructor(router: Router) {\n    const state: RouterState = router.routerState;\n    const root: ActivatedRoute = state.root;\n    const child = root.firstChild;\n    const id: Observable<string> = child.params.map(p => p.id);\n    //...\n  }\n}`.trim();\n\nconst multipleRoute = `\nconst routes: Routes = [\n  { path:\"\",  component:HomeComponent },\n  { path:\"about\", redirectTo:\"signup\", pathMatch:\"full\", component:AboutComponent },\n  { path:'profile/:username', component:ProfileComponent },\n  { path:'profile/:username/:userid', component:ProfileComponent }\n];\n\n\n//about.component.ts\nimport {ActivatedRoute } from '@angular/router';\n\nexport class AboutComponent implements OnInit {\n  username=\"\";\n  name1=\"\";\n  name2=\"\";\n  userid1=\"\";\n  userid2=\"\";\n  constructor( private route: ActivatedRoute, ) {}\n \n\n  ngOnInit(): void {\n\n    this.route.params.subscribe(params => {      //pass data as parameter\n        this.name1 = params['username'];\n        this.userid1=params['userid'];\n     });\n\n    this.route.queryParams.subscribe(params => {  //pass data as query string parameter\n        this.name2 = params['username'];\n        this.userid2=params['userid'];\n     });\n  }\n}\n\n\n//browser url show through template\n<h1>Parameter User Profile</h1>\n<h2>Username:{{name1}}</h2>\n<h2>User ID:{{userid1}}</h2>\n`.trim();\n\nconst currentRoute = `\n<router-outlet></router-outlet>                          //Unnamed router outlet as primary outlet\n<router-outlet name=\"second\"></router-outlet>            //named router outlet as secondary outlet\n\n\n//app-routing.module.ts\nconst routes: Routes = [\n  {\n    path:'customer', loadChildren:()=>import('./customer/customer.module') .then(mod=>mod.CustomerModule), \n      component:CustomerComponent\n  },\n  { path:'customerdetails',  component:CudtomerdetailsComponent, outlet:'customerList' },\n  {\n    path:'order', loadChildren:()=>import('./order/order.module') .then(mod=>mod.OrderModule),\n      component:OrderComponent\n  }\n];\n\n\n//app.component.ts\nimport {UserdataService} from './userdata.service';\n\n@Component({\n  selector: 'app-root',\n  template: '\n      <a routerLink=\"customer\">Customer</a><br/>\n      <a [routerLink]=\"[{Outlets:{customerList:['customerdetails']}}]\">Details</a><br/>\n\n      <a routerLink=\"order\">Order</a>\n\n      <router-outlet></router-outlet>\n      <router-outlet name=\"customerList\"></router-outlet>\n  ',\n  providers:[UserdataService]\n})\n\nexport class AppComponent {}\n`.trim();\n\nconst routerLinkActive = `\n<a routerLink=\"/\" routerLinkActive=\"active\" [routerLinkActiveOptions]=\"{exact:true}\">Home</a><br/>\n<a routerLink=\"/about\" routerLinkActive=\"active\">About</a><br/>\n<a routerLink=\"/login\" routerLinkActive=\"active\">Login</a><br/>\n<a routerLink=\"/signup\" routerLinkActive=\"active\">SignUp</a><br/>\n<a routerLink=\"/profile\" routerLinkActive=\"active\">Profile</a>\n`.trim();\n\nconst routrtDetect = `\n//html\n<p>Current route: {{ currentRoute }}</p>\n\n\nimport { ActivatedRoute } from '@angular/router';\n\nexport class MyComponent implements OnInit {\n  currentRoute: string;\n\n  constructor(private route: ActivatedRoute) {}\n\n  ngOnInit() {\n    this.route.params.subscribe(params => {\n      this.currentRoute = params['id'];\n      console.log('Route changed to: ', this.currentRoute);\n    });\n  }\n}\n`.trim();\n\nconst resolvers = `\nconst routes: Routes = [\n  {\n    path: 'app', component: RoutesComponent,\n    resolve: {\n      exampleData: ExampleResolverService\n    }\n  }\n];\n`.trim();\n\nclass NgrxCounter extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0);\n  }\n  render() {\n    const { classes } = this.props;\n    return (\n      <Grid container>\n        <Grid item xs={2}>\n          <Paper className={classes.paper}>\n            <h4>\n              <Sidebar />\n            </h4>\n          </Paper>\n        </Grid>\n        <Grid item xs={10}>\n          <Paper className={classes.paper}>\n            <List>\n              <h3>1. Basic Routing</h3>\n              Router basically means navigating b/w pages. we have seen many\n              sites with links that direct us to a new page.\n              <div style={titles}>\n                <PrismCode\n                  code={basicRouter}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <h3>2. Routing with multiple route parameter</h3>\n              We should define custome route before wildcard route. Otherwise it\n              not work if we define after wildcard route.\n              <div style={titles}>\n                <PrismCode\n                  code={multipleRoute}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <h3>3. Name & Multiple router-outlets</h3>\n              Router-outlet work as a placeholder which is used to load the\n              different components dynamically based on the activated component\n              or current route state.\n              <div style={titles}>\n                <PrismCode\n                  code={currentRoute}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <h3>4. routerLinkActive</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={routerLinkActive}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <h3>5. What are the router imports</h3>\n              The router imports in Angular are used to configure and manage the\n              application's routing functionality. The following are some of the\n              router imports in Angular:\n              <br />\n              <ul>\n                <li>\n                  <b>RouterModule: </b>This is the core Angular module that\n                  provides the routing functionality for the application. It\n                  includes several classes and methods for configuring routes,\n                  navigating between routes, and handling route-related events.\n                </li>\n                <br />\n                <li>\n                  <b>Routes: </b>This is an array of route objects that define\n                  the application's routing configuration. Each route object\n                  specifies a path, a component, and other optional properties\n                  such as data, guards, and resolvers.\n                </li>\n                <br />\n                <li>\n                  <b>Router: </b>This is the Angular service that provides\n                  methods for navigating between routes, accessing the current\n                  route, and subscribing to route-related events.\n                </li>\n                <br />\n                <li>\n                  <b>ActivatedRoute: </b>This is a service that provides\n                  information about the current route, including the route\n                  parameters, query parameters, and route data.\n                </li>\n                <br />\n                <li>\n                  <b>RouterLink: </b>This is a directive that is used in HTML\n                  templates to create links between routes. It takes a path as\n                  input and generates a link to the corresponding route.\n                </li>\n                <br />\n                <li>\n                  <b>RouterOutlet: </b>This is a directive that is used in HTML\n                  templates to define the location where the component\n                  corresponding to the current route should be displayed.\n                </li>\n                <br />\n                <br />\n                <li>\n                  These router imports are essential for setting up the routing\n                  functionality in an Angular application. By configuring the\n                  routes, using the router and activated route services, and\n                  utilizing the router link and outlet directives, developers\n                  can create a seamless and intuitive user experience for their\n                  application.\n                </li>\n              </ul>\n              <div style={titles}>\n                <PrismCode\n                  code={angularRouter}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <h3>6. What are Router Events</h3>\n              Router Events in Angular are a set of events emitted by the\n              Angular Router whenever the navigation state changes. The Router\n              Events provide a way to track and respond to changes in the\n              application's navigation, and they can be used to perform tasks\n              such as updating the UI, tracking user behavior, or logging\n              navigation events.\n              <br />\n              <ul>\n                <li>\n                  <b>NavigationStart: </b>Emitted when navigation starts.\n                </li>\n                <br />\n                <li>\n                  <b>RoutesRecognized: </b>Emitted when the Router has\n                  recognized the new route and is about to activate it.\n                </li>\n                <br />\n                <li>\n                  <b>RouteConfigLoadStart: </b>Emitted when the Router begins\n                  loading a lazy-loaded route configuration.\n                </li>\n                <br />\n                <li>\n                  <b>RouteConfigLoadEnd: </b>Emitted when the Router has\n                  finished loading a lazy-loaded route configuration.\n                </li>\n                <br />\n                <li>\n                  <b>NavigationEnd: </b>Emitted when navigation has successfully\n                  completed.\n                </li>\n                <br />\n                <li>\n                  <b>NavigationCancel: </b>Emitted when navigation has been\n                  cancelled.\n                </li>\n                <br />\n                <li>\n                  <b>NavigationError: </b>Emitted when navigation has failed due\n                  to an error.\n                </li>\n              </ul>\n              <br />\n              <br />\n              <h3>7. What is the use of router-outlet in angular 8.</h3>\n              <ul>\n                <li>\n                  Router outlet is a dynamic component that router uses to\n                  display views based on router navigations.\n                </li>\n                <br />\n\n                <li>It tells the router where to display routed views.</li>\n              </ul>\n              <br />\n              <h3>\n                8. Difference between navigate and navigatebyurl in angular.\n              </h3>\n              <ul>\n                <li>\n                  navigate method accept an array and it construct the root path\n                  while, navigateByUrl accept an string which give us root path.\n                </li>\n                <li>\n                  Using navigate method we can also achieved relative path by{\" \"}\n                  <b>relativeTo</b> option while, navigateByUrl can be use only\n                  for absolute path.\n                </li>\n              </ul>\n              <div style={titles}>\n                <PrismCode\n                  code={addcomponents}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <br />\n              <h3>1. What is the difference between forChild and forRoot? </h3>\n              <ul>\n                <li>\n                  In Angular, forRoot() and forChild() are two methods provided\n                  by the RouterModule to configure the router module. The main\n                  difference between them is that forRoot() should be used only\n                  in the root AppModule of the application, while forChild()\n                  should be used in all the other modules.\n                </li>\n                <br />\n                <li>\n                  The forRoot() method is used to configure the router at the\n                  application level, and it sets up the router with the routes\n                  and other configuration options required by the root module.\n                </li>\n                <div style={titles}>\n                  <PrismCode\n                    code={forRoots}\n                    language=\"js\"\n                    plugins={[\"line-numbers\"]}\n                  />\n                </div>\n                <br />\n                <li>\n                  forChild() method is used to configure the router in feature\n                  modules.\n                </li>\n                <div style={titles}>\n                  <PrismCode\n                    code={forChilds}\n                    language=\"js\"\n                    plugins={[\"line-numbers\"]}\n                  />\n                </div>\n              </ul>\n              <br />\n              <h3>9. How do you detect route change in Angular?</h3>\n              can detect route changes using the ActivatedRoute service and the\n              Router module.\n              <br />\n              <br />\n              One way to detect route changes is to subscribe to the params\n              property of the ActivatedRoute service. This property is an\n              observable that emits a new value whenever the route parameters\n              change.\n              <div style={titles}>\n                <PrismCode\n                  code={routrtDetect}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <br />\n              <h3>10. What is pathMatch in angular routing?</h3>\n              In Angular routing, pathMatch is a configuration option that\n              determines how to match the URL segments to the configured route\n              path.\n              <br />\n              <br />\n              There are two possible values for the pathMatch option:\n              <ul>\n                <li>\n                  <b>prefix: </b>This value indicates that the router should\n                  match the configured route path if the URL starts with the\n                  specified path. This is the default value if pathMatch is not\n                  specified.\n                </li>\n                <br />\n                <li>\n                  <b>full: </b>This value indicates that the router should match\n                  the configured route path if the URL matches the entire path.\n                </li>\n              </ul>\n              <br />\n              <br />\n              <h3>11. Difference between Angular's canLoad and canActivate?</h3>\n              Both canLoad and canActivate are Angular route guards that can be\n              used to protect routes in an Angular application, but they are\n              used in different scenarios.\n              <ul>\n                <li>\n                  <b>canActivate: </b>Is a route guard that is used to protect a\n                  route after it has been loaded. When a user navigates to a\n                  protected route, canActivate is called before the route is\n                  activated. canActivate returns either a boolean value or an\n                  observable that resolves to a boolean value. If canActivate\n                  returns true, the route is activated, and the user can\n                  proceed. If canActivate returns false, the route is not\n                  activated, and the user is redirected to a different page.\n                </li>\n                <br />\n                <li>\n                  <b>canLoad: </b> Is a route guard that is used to protect a\n                  route before it is loaded. When a user navigates to a route\n                  that requires lazy loading, canLoad is called before the\n                  module containing the route is loaded. canLoad returns either\n                  a boolean value or an observable that resolves to a boolean\n                  value. If canLoad returns true, the module is loaded, and the\n                  user can proceed. If canLoad returns false, the module is not\n                  loaded, and the user is redirected to a different page.\n                </li>\n              </ul>\n              <br />\n              <br />\n              <h3>12. What is router state</h3>\n              RouterState is a tree of activated routes. Every node in this tree\n              knows about the URL segments, the extracted parameters, and the\n              resolved data.\n              <br />\n              You can access the current RouterState from anywhere in the\n              application using the Router service and the routerState property.\n              <br />\n              <div style={titles}>\n                <PrismCode\n                  code={routerState}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <h3>13. How to specify which route to navigate to in NavLink?</h3>\n              To specify which route to navigate to, use the to prop and pass\n              the path name. The activeClassName prop will add an active class\n              to the link if it’s currently active. On the browser, the NavLink\n              component is rendered as an tag with an href attribute value that\n              was passed in prop.\n              <br />\n              <h3>14. When to use absolute path in navigate method?</h3>\n              Navigate Method always uses the absolute path unless you provide a\n              starting point. <b>navigate.navigateByUrl</b> Use this method if\n              you want to navigate to a URL by using the absolute path. The\n              first argument is a string containing the complete URL.\n              <br />\n              <h3>15. What is Routing Guard in Angular?</h3>\n              Angular’s route guards tell the router whether or not it should\n              allow navigation to a requested route. They make this decision by\n              looking for a true or false return value from a class which\n              implements the given guard interface.\n              <br />\n              <br />\n              There are five different types of guards:\n              <ul>\n                <li>CanActivate</li>\n                <li>CanActivateChild</li>\n                <li>CanDeactivate</li>\n                <li>CanLoad</li>\n                <li>Resolve</li>\n              </ul>\n              <div style={titles}>\n                <PrismCode\n                  code={CanActivate}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <br />\n              <h3>16. Pass complex JSON via routerLink.</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={routerLink}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <br />\n              <h3>What is a resolver in Angular and how is it used?</h3>\n              <ul>\n                <li>\n                  In Angular, a resolver is a service that is used to retrieve\n                  data before a route is activated. It allows you to fetch data\n                  and perform any necessary operations before the component is\n                  rendered. This can be useful for scenarios where you need to\n                  fetch data from an API or perform some other async operation\n                  before rendering the component.\n                </li>\n                <br />\n                <li>\n                  When a resolver is added to a route, it ensures that the data\n                  is available to the component before it is rendered. This can\n                  help prevent issues with data being unavailable or incorrect\n                  during rendering, as the resolver ensures that the data is\n                  loaded and ready to use.\n                </li>\n                <br />\n                <li>\n                  To create a resolver in Angular, you can create a service that\n                  implements the Resolve interface and defines a resolve()\n                  method. This method should return an observable that resolves\n                  to the data that you want to load. You can then add the\n                  resolver to the resolve property of the route definition.\n                </li>\n              </ul>\n              <div style={titles}>\n                <PrismCode\n                  code={resolvers}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <br />\n              <h3>\n                17. Angular by default, uses client-side rendering for its\n                applications. Can one make an angular application to render on\n                the server-side?\n              </h3>\n              Yes, with Angular Universal, Angular application can render on the\n              server-side.\n              <br />\n              <br />\n              <b>The advantages of using Angular Universal are :</b>\n              <ul>\n                <li>\n                  First time users can instantly see a view of the application.\n                  This providing better user experience.\n                </li>\n                <li>\n                  Many search engines expect pages in plain HTML, thus,\n                  Universal can make sure that your content is available on\n                  every search engine, which leads to better SEO.\n                </li>\n                <li>\n                  Any server-side rendered application loads faster since\n                  rendered pages are available to the browser sooner.\n                </li>\n              </ul>\n              <br />\n              <h3>\n                18. How does one share data between components in Angular?\n              </h3>\n              <ul>\n                <li>Parent to child using @Input decorator</li>\n\n                <li>\n                  Child to parent using @Output with EventEmitter and @ViewChild\n                  decorator\n                </li>\n              </ul>\n              <br />\n              <h3>19. What are filters in Angular? Name a few of them.</h3>\n              Filters are used to format an expression and present it to the\n              user.\n              <ol>\n                <li>Date</li>\n                <li>filter</li>\n                <li>Json</li>\n                <li>limitTo</li>\n                <li>lowercase</li>\n              </ol>\n              <br />\n              <h3>20. What type of DOM does Angular implement?</h3>\n              <ul>\n                <li>\n                  Angular uses the regular DOM. This updates the entire tree\n                  structure of HTML tags until it reaches the data to be\n                  updated. However, to ensure that the speed and performance are\n                  not affected, Angular implements Change Detection.\n                </li>\n              </ul>\n              <br />\n              <h3>21. What is DOM?</h3>\n              It is responsible for representing the content of a web page and\n              changes in the architecture of an application. Here, all the\n              objects are organized in the form of a tree, and the document can\n              easily be modified, manipulated, and accessed only with the help\n              of APIs.\n              <br />\n              <h3>22. Shadow DOM</h3>\n              <ul>\n                <li>\n                  Shadow DOM is a feature of web components that allows\n                  encapsulation of HTML, CSS, and JavaScript. In Angular, Shadow\n                  DOM is used to encapsulate component styles and HTML\n                  templates, ensuring that they do not leak out and affect other\n                  parts of the application.\n                </li>\n                <br />\n                <li>\n                  When a component is created in Angular, it is rendered within\n                  a Shadow DOM root. The Shadow DOM root is a separate DOM tree\n                  that is attached to the main document's DOM tree, but is not\n                  part of it. This allows the component to have its own isolated\n                  CSS styles and HTML structure, which cannot be affected by\n                  styles or elements outside of the component.\n                </li>\n                <br />\n                <br />\n                <li>\n                  Angular uses the ViewEncapsulation metadata property to\n                  control how a component's styles are encapsulated.\n                  <br />\n                  <br />\n                  determines whether the styles defined in a particular\n                  component will affect the entire application or not. Angular\n                  supports 3 types of ViewEncapsulation:\n                </li>\n                <br />\n                <ul>\n                  <li>\n                    <b>Emulated: </b>This is the default value, and it emulates\n                    the behavior of Shadow DOM by adding unique CSS selectors to\n                    the component's styles, making it more difficult for them to\n                    be overridden by external styles.\n                  </li>\n                  <br />\n                  <li>\n                    <b>Native: </b> This value uses the native Shadow DOM\n                    implementation to encapsulate a component's styles. This\n                    means that the component's styles are completely isolated\n                    from the rest of the application.\n                  </li>\n                  <br />\n                  <li>\n                    <b>None: </b>This value disables encapsulation and allows a\n                    component's styles to be applied globally, potentially\n                    affecting other parts of the application.\n                  </li>\n                </ul>\n              </ul>\n              <br />\n              Overall, Shadow DOM in Angular provides a powerful way to\n              encapsulate component styles and templates, ensuring that they do\n              not leak out and affect other parts of the application. By using\n              the ViewEncapsulation metadata property, developers can control\n              how a component's styles are encapsulated, and ensure that they\n              behave as expected.\n            </List>\n          </Paper>\n        </Grid>\n      </Grid>\n    );\n  }\n}\n\nexport default withStyles(styles)(NgrxCounter);\n"]},"metadata":{},"sourceType":"module"}