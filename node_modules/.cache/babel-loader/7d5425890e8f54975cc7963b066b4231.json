{"ast":null,"code":"var _jsxFileName = \"/home/mukeshs/Projects/edurights/client/src/components/ml/deepMl/perceptron.js\";\nimport React, { Component } from 'react';\nimport Prism from \"prismjs\";\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\nimport '../../ReactJs/styles.css';\nimport Sidebar from '../sidebar';\nimport PrismCode from '../../ReactJs/prismCode';\nimport Equations from '../../../assets/ML/perceptrons.png';\nimport Perceptrons from '../../../assets/ML/perceptrons2.png';\nimport PerceptronsGrapg from '../../../assets/ML/perceptrons3.png';\nimport PerceptronsGraps from '../../../assets/ML/perceptrons4.png';\nconst titles = {\n  backgroundColor: '#F0F8FF',\n  padding: '1px',\n  fontSize: '16px'\n};\nconst redesign = {\n  height: 350,\n  width: 600\n};\n\nconst styles = theme => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1)\n  },\n  smMargin: {\n    margin: theme.spacing(1)\n  },\n  actionDiv: {\n    textAlign: \"center\"\n  }\n});\n\nconst stack = `\nimport numpy as np\n\nclass Perceptron:\n    def __init__(self, learning_rate=0.01, n_iters=1000):\n        self.lr = learning_rate\n        self.n_iters = n_iters\n        self.activation_func = self._unit_step_func\n        self.weights = None\n        self.bias = None\n\n    def fit(self, X, y):\n        n_samples, n_features = X.shape\n\n        # init parameters\n        self.weights = np.zeros(n_features)\n        self.bias = 0\n\n        y_ = np.array([1 if i > 0 else 0 for i in y])\n\n        for _ in range(self.n_iters):\n\n            for idx, x_i in enumerate(X):\n\n                linear_output = np.dot(x_i, self.weights) + self.bias\n                y_predicted = self.activation_func(linear_output)\n\n                # Perceptron update rule\n                update = self.lr * (y_[idx] - y_predicted)\n\n                self.weights += update * x_i\n                self.bias += update\n\n    def predict(self, X):\n        linear_output = np.dot(X, self.weights) + self.bias\n        y_predicted = self.activation_func(linear_output)\n        return y_predicted\n\n    def _unit_step_func(self, x):\n        return np.where(x >= 0, 1, 0)\n`.trim();\nconst label = `\nif 0.5x + 0.5y => 0, then 1\nif 0.5x + 0.5y < 0, then 0.\n`.trim();\nconst testings = `\nif __name__ == \"__main__\":\n    # Imports\n    import matplotlib.pyplot as plt\n    from sklearn.model_selection import train_test_split\n    from sklearn import datasets\n\n    def accuracy(y_true, y_pred):\n        accuracy = np.sum(y_true == y_pred) / len(y_true)\n        return accuracy\n\n    X, y = datasets.make_blobs(\n        n_samples=150, n_features=2, centers=2, cluster_std=1.05, random_state=2\n    )\n    X_train, X_test, y_train, y_test = train_test_split(\n        X, y, test_size=0.2, random_state=123\n    )\n\n    p = Perceptron(learning_rate=0.01, n_iters=1000)\n    p.fit(X_train, y_train)\n    predictions = p.predict(X_test)\n\n    print(\"Perceptron classification accuracy\", accuracy(y_test, predictions))\n\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n    plt.scatter(X_train[:, 0], X_train[:, 1], marker=\"o\", c=y_train)\n\n    x0_1 = np.amin(X_train[:, 0])\n    x0_2 = np.amax(X_train[:, 0])\n\n    x1_1 = (-p.weights[0] * x0_1 - p.bias) / p.weights[1]\n    x1_2 = (-p.weights[0] * x0_2 - p.bias) / p.weights[1]\n\n    ax.plot([x0_1, x0_2], [x1_1, x1_2], \"k\")\n\n    ymin = np.amin(X_train[:, 1])\n    ymax = np.amax(X_train[:, 1])\n    ax.set_ylim([ymin - 3, ymax + 3])\n\n    plt.show()\n    `.trim(); // const stack = ``.trim();\n\nclass Perceptron extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0);\n  }\n\n  render() {\n    const {\n      classes\n    } = this.props;\n    return React.createElement(Grid, {\n      container: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 136\n      },\n      __self: this\n    }, React.createElement(Grid, {\n      item: true,\n      xs: 2,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 137\n      },\n      __self: this\n    }, React.createElement(Paper, {\n      className: classes.paper,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 138\n      },\n      __self: this\n    }, React.createElement(\"h4\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 139\n      },\n      __self: this\n    }, React.createElement(Sidebar, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 139\n      },\n      __self: this\n    })))), React.createElement(Grid, {\n      item: true,\n      xs: 10,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 142\n      },\n      __self: this\n    }, React.createElement(Paper, {\n      className: classes.paper,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 143\n      },\n      __self: this\n    }, React.createElement(List, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 144\n      },\n      __self: this\n    }, React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 145\n      },\n      __self: this\n    }, \"Perceptron \\u2013 Basics of Neural Networks\"), \"A single-layer perceptron is the basic unit of a neural network. A perceptron consists of input values, weights and a bias, a weighted sum and activation function.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 148\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 149\n      },\n      __self: this\n    }), React.createElement(\"i\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 151\n      },\n      __self: this\n    }, \"Perceptron consists of one/ more inputs, a processor, and only one o/p.\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 152\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 153\n      },\n      __self: this\n    }), \"A perceptron works by taking in some numerical i/p along with what is known as weights and a bias. It then multiplies these i/p with the respective weights(weighted sum). These products are then added together along with the bias. The activation function takes the weighted sum and the bias as i/p and returns a final o/p.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 157\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 158\n      },\n      __self: this\n    }), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 160\n      },\n      __self: this\n    }, React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 161\n      },\n      __self: this\n    }, \"A perceptron consists of four parts: input values, weights and a bias, a weighted sum, and activation function.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 163\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 163\n      },\n      __self: this\n    }, \"Function may look like: \"), \"y = xw + x2w2 +...+ xnwn\"), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 164\n      },\n      __self: this\n    }, React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 165\n      },\n      __self: this\n    }, \"bias  is alwase 1.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 166\n      },\n      __self: this\n    }, \"This function is called the weighted sum because it is the sum of the weights and inputs. This looks like a good function, but what if we wanted the outputs to fall into a certain range 0 to 1.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 168\n      },\n      __self: this\n    }, \"We can do this by using an activation function. An \", React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 168\n      },\n      __self: this\n    }, \"activation function\"), \" is a function that converts the i/p into a certain o/p based on a set of rules.\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 170\n      },\n      __self: this\n    }), React.createElement(\"img\", {\n      src: Equations,\n      alt: \"Equations\",\n      className: \"responsive\",\n      style: redesign,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 171\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 172\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 173\n      },\n      __self: this\n    }), \"There are different kinds of activation functions that exist.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 175\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 176\n      },\n      __self: this\n    }, \"1. Hyperbolic Tangent: \"), \"Used to o/p a number from -1 to 1.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 176\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 177\n      },\n      __self: this\n    }, \"2. Logistic Function: \"), \"Used to o/p a number from 0 to 1.\")), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 180\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 182\n      },\n      __self: this\n    }, \"Why are perceptron's used?\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 183\n      },\n      __self: this\n    }), \"Perceptrons are the building blocks of neural networks. It is typically used for supervised learning of binary classifiers.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 186\n      },\n      __self: this\n    }), React.createElement(\"img\", {\n      src: Perceptrons,\n      alt: \"Equations\",\n      className: \"responsive\",\n      style: redesign,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 187\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 188\n      },\n      __self: this\n    }), \"Suppose our goal was to separates this data so that there is a distinction between the blue dots and the red dots.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 191\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 192\n      },\n      __self: this\n    }), \"A perceptron can create a decision boundary for a binary classification, where a decision boundary is regions of space on a graph that separates different data points.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 195\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 196\n      },\n      __self: this\n    }), \"Let wx = -0.5, wy = 0.5 and b = 0\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 198\n      },\n      __self: this\n    }), \"Then the function for the perceptron.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 199\n      },\n      __self: this\n    }), \"0.5x + 0.5y = 0\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 201\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 202\n      },\n      __self: this\n    }), \"and the graph is.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 204\n      },\n      __self: this\n    }), React.createElement(\"img\", {\n      src: PerceptronsGrapg,\n      alt: \"Equations\",\n      className: \"responsive\",\n      style: redesign,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 205\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 206\n      },\n      __self: this\n    }), \"Let\\u2019s suppose that the activation function, in this case, is a simple step function that outputs either 0 or 1. The perceptron function will then label the blue dots as 1 and the red dots as 0.\", React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 209\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: label,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 210\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 216\n      },\n      __self: this\n    }), \"Therefore, the function 0.5x + 0.5y = 0 creates a decision boundary that separates the red and blue points.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 218\n      },\n      __self: this\n    }), React.createElement(\"img\", {\n      src: PerceptronsGraps,\n      alt: \"Equations\",\n      className: \"responsive\",\n      style: redesign,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 219\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 220\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 222\n      },\n      __self: this\n    }, \"Overall, we see that a perceptron can do basic classification using a decision boundary.\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 223\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 225\n      },\n      __self: this\n    }, \"Example\"), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 226\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: stack,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 227\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 233\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 235\n      },\n      __self: this\n    }, \"Testing\"), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 236\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: testings,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 237\n      },\n      __self: this\n    }))))));\n  }\n\n}\n\nexport default withStyles(styles)(Perceptron);","map":{"version":3,"sources":["/home/mukeshs/Projects/edurights/client/src/components/ml/deepMl/perceptron.js"],"names":["React","Component","Prism","Grid","Paper","withStyles","List","Sidebar","PrismCode","Equations","Perceptrons","PerceptronsGrapg","PerceptronsGraps","titles","backgroundColor","padding","fontSize","redesign","height","width","styles","theme","paper","margin","spacing","smMargin","actionDiv","textAlign","stack","trim","label","testings","Perceptron","componentDidMount","setTimeout","highlightAll","render","classes","props"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport Prism from \"prismjs\"\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\n\nimport '../../ReactJs/styles.css'\nimport Sidebar from '../sidebar';\nimport PrismCode from '../../ReactJs/prismCode';\n\nimport Equations from '../../../assets/ML/perceptrons.png'\nimport Perceptrons from '../../../assets/ML/perceptrons2.png'\nimport PerceptronsGrapg from '../../../assets/ML/perceptrons3.png'\nimport PerceptronsGraps from '../../../assets/ML/perceptrons4.png'\n\n\nconst titles = { backgroundColor: '#F0F8FF', padding: '1px', fontSize: '16px' }\n\nconst redesign = {\n  height: 350,\n  width: 600\n}\n\nconst styles = theme => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1)\n  },\n  smMargin: {\n    margin: theme.spacing(1)\n  },\n  actionDiv: {\n    textAlign: \"center\"\n  }\n})\n\n\nconst stack = `\nimport numpy as np\n\nclass Perceptron:\n    def __init__(self, learning_rate=0.01, n_iters=1000):\n        self.lr = learning_rate\n        self.n_iters = n_iters\n        self.activation_func = self._unit_step_func\n        self.weights = None\n        self.bias = None\n\n    def fit(self, X, y):\n        n_samples, n_features = X.shape\n\n        # init parameters\n        self.weights = np.zeros(n_features)\n        self.bias = 0\n\n        y_ = np.array([1 if i > 0 else 0 for i in y])\n\n        for _ in range(self.n_iters):\n\n            for idx, x_i in enumerate(X):\n\n                linear_output = np.dot(x_i, self.weights) + self.bias\n                y_predicted = self.activation_func(linear_output)\n\n                # Perceptron update rule\n                update = self.lr * (y_[idx] - y_predicted)\n\n                self.weights += update * x_i\n                self.bias += update\n\n    def predict(self, X):\n        linear_output = np.dot(X, self.weights) + self.bias\n        y_predicted = self.activation_func(linear_output)\n        return y_predicted\n\n    def _unit_step_func(self, x):\n        return np.where(x >= 0, 1, 0)\n`.trim();\n\nconst label = `\nif 0.5x + 0.5y => 0, then 1\nif 0.5x + 0.5y < 0, then 0.\n`.trim();\n\nconst testings = `\nif __name__ == \"__main__\":\n    # Imports\n    import matplotlib.pyplot as plt\n    from sklearn.model_selection import train_test_split\n    from sklearn import datasets\n\n    def accuracy(y_true, y_pred):\n        accuracy = np.sum(y_true == y_pred) / len(y_true)\n        return accuracy\n\n    X, y = datasets.make_blobs(\n        n_samples=150, n_features=2, centers=2, cluster_std=1.05, random_state=2\n    )\n    X_train, X_test, y_train, y_test = train_test_split(\n        X, y, test_size=0.2, random_state=123\n    )\n\n    p = Perceptron(learning_rate=0.01, n_iters=1000)\n    p.fit(X_train, y_train)\n    predictions = p.predict(X_test)\n\n    print(\"Perceptron classification accuracy\", accuracy(y_test, predictions))\n\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n    plt.scatter(X_train[:, 0], X_train[:, 1], marker=\"o\", c=y_train)\n\n    x0_1 = np.amin(X_train[:, 0])\n    x0_2 = np.amax(X_train[:, 0])\n\n    x1_1 = (-p.weights[0] * x0_1 - p.bias) / p.weights[1]\n    x1_2 = (-p.weights[0] * x0_2 - p.bias) / p.weights[1]\n\n    ax.plot([x0_1, x0_2], [x1_1, x1_2], \"k\")\n\n    ymin = np.amin(X_train[:, 1])\n    ymax = np.amax(X_train[:, 1])\n    ax.set_ylim([ymin - 3, ymax + 3])\n\n    plt.show()\n    `.trim();\n\n// const stack = ``.trim();\n\n\nclass Perceptron extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0)\n  }\n  render() {\n    const { classes } = this.props;\n    return (\n      <Grid container>\n        <Grid item xs={2}>\n          <Paper className={classes.paper}>\n            <h4><Sidebar /></h4>\n          </Paper>\n        </Grid>\n        <Grid item xs={10}>\n          <Paper className={classes.paper}>\n            <List>\n              <h3>Perceptron – Basics of Neural Networks</h3>\n              A single-layer perceptron is the basic unit of a neural network. A perceptron consists of input values, weights\n              and a bias, a weighted sum and activation function.\n              <br />\n              <br />\n\n              <i>Perceptron consists of one/ more inputs, a processor, and only one o/p.</i>\n              <br />\n              <br />\n              A perceptron works by taking in some numerical i/p along with what is known as weights and a bias. It then\n              multiplies these i/p with the respective weights(weighted sum). These products are then added together along\n              with the bias. The activation function takes the weighted sum and the bias as i/p and returns a final o/p.\n              <br />\n              <br />\n\n              <ul>\n                <li>A perceptron consists of four parts: input values, weights and a bias, a weighted sum, and\n                  activation function.</li>\n                <li><b>Function may look like: </b>y = xw + x2w2 +...+ xnwn</li>\n                <ul>\n                  <li>bias  is alwase 1.</li>\n                  <li>This function is called the weighted sum because it is the sum of the weights and inputs. This looks like a\n                    good function, but what if we wanted the outputs to fall into a certain range 0 to 1.</li>\n                  <li>We can do this by using an activation function. An <b>activation function</b> is\n                    a function that converts the i/p into a certain o/p based on a set of rules.</li>\n                  <br />\n                  <img src={Equations} alt=\"Equations\" className=\"responsive\" style={redesign} />\n                  <br />\n                  <br />\n                  There are different kinds of activation functions that exist.\n                  <br />\n                  <b>1. Hyperbolic Tangent: </b>Used to o/p a number from -1 to 1.<br />\n                  <b>2. Logistic Function: </b>Used to o/p a number from 0 to 1.\n                </ul>\n              </ul>\n              <br />\n\n              <b>Why are perceptron's used?</b>\n              <br />\n              Perceptrons are the building blocks of neural networks. It is typically used for supervised learning of\n              binary classifiers.\n              <br />\n              <img src={Perceptrons} alt=\"Equations\" className=\"responsive\" style={redesign} />\n              <br />\n\n              Suppose our goal was to separates this data so that there is a distinction between the blue dots and the red dots.\n              <br />\n              <br />\n              A perceptron can create a decision boundary for a binary classification, where a decision boundary is\n              regions of space on a graph that separates different data points.\n              <br />\n              <br />\n              Let wx = -0.5, wy = 0.5 and b = 0\n              <br />\n              Then the function for the perceptron.<br />\n              0.5x + 0.5y = 0\n              <br />\n              <br />\n              and the graph is.\n              <br />\n              <img src={PerceptronsGrapg} alt=\"Equations\" className=\"responsive\" style={redesign} />\n              <br />\n              Let’s suppose that the activation function, in this case, is a simple step function that outputs either 0 or 1.\n              The perceptron function will then label the blue dots as 1 and the red dots as 0.\n              <div style={titles}>\n                <PrismCode\n                  code={label}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              Therefore, the function 0.5x + 0.5y = 0 creates a decision boundary that separates the red and blue points.\n              <br />\n              <img src={PerceptronsGraps} alt=\"Equations\" className=\"responsive\" style={redesign} />\n              <br />\n\n              <b>Overall, we see that a perceptron can do basic classification using a decision boundary.</b>\n              <br />\n\n              <h3>Example</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={stack}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3>Testing</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={testings}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              {/* <br />\n\n              <h3></h3>\n              <div style={titles}>\n                <PrismCode\n                  code={stack}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3></h3>\n              <div style={titles}>\n                <PrismCode\n                  code={stack}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div> */}\n            </List>\n          </Paper>\n        </Grid>\n      </Grid>\n    )\n  }\n}\n\nexport default (withStyles(styles)(Perceptron));\n"]},"metadata":{},"sourceType":"module"}