{"ast":null,"code":"import _classCallCheck from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/createClass\";import _possibleConstructorReturn from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";import _getPrototypeOf from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";import _inherits from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/inherits\";import React,{Component}from'react';import Prism from\"prismjs\";import{Grid,Paper,withStyles,List}from\"@material-ui/core\";import'../../ReactJs/styles.css';import Sidebar from'../sidebar';import PrismCode from'../../ReactJs/prismCode';var titles={backgroundColor:'#F0F8FF',padding:'1px',fontSize:'16px'};var styles=function styles(theme){return{paper:{margin:theme.spacing(1),padding:theme.spacing(1)},smMargin:{margin:theme.spacing(1)},actionDiv:{textAlign:\"center\"}};};var abstrcts=\"\\nfrom abc import ABC, abstractmethod\\n\\nclass Computer(ABC):\\n    @abstractmethod\\n    def process(self):\\n        pass\\n\\nclass Laptop(Computer):\\n    def process(self):\\n        print(\\\"It's running\\\")\\n\\nobj=Laptop()\\nobj.process()\".trim();var decorator=\"\\ndef decor_result(result_function):\\n    def distinction(marks):\\n        for m in marks:\\n            if m>=75:\\n                print(\\\"Distinction\\\")\\n        result_function(marks)\\n    return distinction\\n\\n@decor_result\\ndef result(marks):\\n    for m in marks:\\n        if m>=33:\\n            pass\\n        else:\\n            print('FAIL')\\n            break\\n    else:\\n        print('PASS')\\nresult([45,67,87,65,78])\".trim();var decorated=\"\\n@my_decorator\\ndef my_function():\\n    pass\".trim();var consequence=\"\\ndef start_end_decorator(func):\\n    \\n    def wrapper():\\n        print('Start')\\n        func()\\n        print('End')\\n    return wrapper\\n\\ndef print_name():\\n    print('Alex')\\n    \\nprint_name()\\n\\nprint()\\n\\nprint_name = start_end_decorator(print_name)\\nprint_name()\".trim();var achieve=\"\\n@start_end_decorator\\ndef print_name():\\n    print('Alex')\\n    \\nprint_name()\".trim();var argumentse=\"\\ndef start_end_decorator_2(func):\\n    \\n    def wrapper(*args, **kwargs):\\n        print('Start')\\n        func(*args, **kwargs)\\n        print('End')\\n    return wrapper\\n\\n@start_end_decorator_2\\ndef add_5(x):\\n    return x + 5\\n\\nresult = add_5(10)\\nprint(result)\".trim();var inner=\"\\ndef start_end_decorator_3(func):\\n    \\n    def wrapper(*args, **kwargs):\\n        print('Start')\\n        result = func(*args, **kwargs)\\n        print('End')\\n        return result\\n    return wrapper\\n\\n@start_end_decorator_3\\ndef add_5(x):\\n    return x + 5\\n\\nresult = add_5(10)\\nprint(result)\".trim();var identity=\"\\nprint(add_5.__name__)\\nhelp(add_5)\".trim();var template=\"\\nimport functools\\n\\ndef my_decorator(func):\\n    @functools.wraps(func)\\n    def wrapper(*args, **kwargs):\\n        result = func(*args, **kwargs)\\n        return result\\n    return wrapper\".trim();var repeats=\"\\ndef repeat(num_times):\\n    def decorator_repeat(func):\\n        @functools.wraps(func)\\n        def wrapper(*args, **kwargs):\\n            for _ in range(num_times):\\n                result = func(*args, **kwargs)\\n            return result\\n        return wrapper\\n    return decorator_repeat\\n\\n@repeat(num_times=3)\\ndef greet(name):\\n    print(f\\\"Hello {name}\\\")\\n    \\ngreet('Alex')\".trim();var executed=\"\\ndef debug(func):\\n    @functools.wraps(func)\\n    def wrapper(*args, **kwargs):\\n        args_repr = [repr(a) for a in args]\\n        kwargs_repr = [f\\\"{k}={v!r}\\\" for k, v in kwargs.items()]\\n        signature = \\\", \\\".join(args_repr + kwargs_repr)\\n        print(f\\\"Calling {func.__name__}({signature})\\\")\\n        result = func(*args, **kwargs)\\n        print(f\\\"{func.__name__!r} returned {result!r}\\\")\\n        return result\\n    return wrapper\\n\\n@debug\\n@start_end_decorator_4\\ndef say_hello(name):\\n    greeting = f'Hello {name}'\\n    print(greeting)\\n    return greeting\\n\\nsay_hello(name='Alex')\".trim();var preserve=\"\\nimport functools\\n\\nclass CountCalls:\\n                                                          # the init needs to have the func as argument and stores it\\n    def __init__(self, func):\\n        functools.update_wrapper(self, func)\\n        self.func = func\\n        self.num_calls = 0\\n    \\n                                                          # extend functionality, execute function, and return the result\\n    def __call__(self, *args, **kwargs):\\n        self.num_calls += 1\\n        print(f\\\"Call {self.num_calls} of {self.func.__name__!r}\\\")\\n        return self.func(*args, **kwargs)\\n\\n@CountCalls\\ndef say_hello(num):\\n    print(\\\"Hello!\\\")\\n    \\nsay_hello(5)\\nsay_hello(5)\".trim();var Abstract=/*#__PURE__*/function(_Component){_inherits(Abstract,_Component);function Abstract(){_classCallCheck(this,Abstract);return _possibleConstructorReturn(this,_getPrototypeOf(Abstract).apply(this,arguments));}_createClass(Abstract,[{key:\"componentDidMount\",value:function componentDidMount(){setTimeout(function(){return Prism.highlightAll();},0);}},{key:\"render\",value:function render(){var classes=this.props.classes;return React.createElement(Grid,{container:true},React.createElement(Grid,{item:true,xs:2},React.createElement(Paper,{className:classes.paper},React.createElement(\"h4\",null,React.createElement(Sidebar,null)))),React.createElement(Grid,{item:true,xs:10},React.createElement(Paper,{className:classes.paper},React.createElement(List,null,React.createElement(\"h3\",null,\"Abstract Class\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Python default don't support abstract class. But with abc module can do.\"),React.createElement(\"li\",null,\"Abstract class has at least one abstract method.\")),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:abstrcts,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"Decorators\"),\"A decorator is a function that takes another function and extends the behavior of this function without explicitly modifying it. It allows to add new functionality to an existing function.\",React.createElement(\"br\",null),React.createElement(\"br\",null),\"There are 2 kinds of decorators:\",React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Function decoratos\"),React.createElement(\"li\",null,\"Class decorators\")),React.createElement(\"br\",null),\"A function is decorated with the \",React.createElement(\"b\",null,\"@\"),\" symbol:\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:decorated,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"Function decorators\"),\"A decorator function takes another function as argument, wraps its behaviour inside an inner function. and returns the wrapped function. The decorated function no has extended functionality.\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:consequence,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"The decorator syntax\"),\"Instead of wrapping our function and asigning it to itself, Achieve same thing by decorating our function with an @.\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:achieve,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"What about function arguments\"),\"If our function has input arguments and we try to wrap it with our decorator above, it will raise a TypeError since we have to call our function inside the wrapper with this arguments, too. However, we can fix this by using *args and **kwargs in the inner function:\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:argumentse,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"Return values\"),\"Above, we do not get the result back, now return the value from our inner function:\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:inner,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"What about the function identity?\"),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:identity,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"The final template for own decorators\"),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:template,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"Decorator function arguments\"),\"functools.wraps is a decorator that takes an argument for itself. We can think of this as 2 inner functions, so an inner function within inner function.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Another example: \"),\"A repeat decorator that takes a number as input. Within this function, we have the actual decorator function that wraps our function and extends its behaviour within another inner function. In this case, it repeats the input function the given number of times.\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:repeats,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"Nested Decorators\"),\"We can apply several decorators to a function by stacking them on top of each other. The decorators are being executed in the order they are listed.\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:executed,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"Class decorators\"),\"We can also use a class as a decorator. Therefore, we have to implement the __call__() method to make our object callable. Class decorators are typically used to maintain a state, e.g. here we keep track of the number of times our function is executed. The __call__ method does essentially the same thing as the wrapper() method we have seen earlier. It adds some functionality, executes the function, and returns its result. Note that here we use functools.update_wrapper() instead of functools.wraps to preserve the information about our function.\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:preserve,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"Some typical use cases\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Use a timer decorator to calculate the execution time of a function.\"),React.createElement(\"li\",null,\"Use a debug decorator to print out some more information about the called function and its arguments.\"),React.createElement(\"li\",null,\"Use a check decorator to check if the arguments fulfill some requirements and adapt the bevaviour accordingly.\"),React.createElement(\"li\",null,\"Register functions (plugins).\"),React.createElement(\"li\",null,\"Slow down code with time.sleep() to check network behaviour.\"),React.createElement(\"li\",null,\"Cache the return values for memoization.\"),React.createElement(\"li\",null,\"Add information or update a state.\"))))));}}]);return Abstract;}(Component);export default withStyles(styles)(Abstract);","map":{"version":3,"sources":["/home/mukeshs/Projects/edurights/src/components/pythone/deeppy/abstract.js"],"names":["React","Component","Prism","Grid","Paper","withStyles","List","Sidebar","PrismCode","titles","backgroundColor","padding","fontSize","styles","theme","paper","margin","spacing","smMargin","actionDiv","textAlign","abstrcts","trim","decorator","decorated","consequence","achieve","argumentse","inner","identity","template","repeats","executed","preserve","Abstract","setTimeout","highlightAll","classes","props"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport Prism from \"prismjs\"\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\n\nimport '../../ReactJs/styles.css'\nimport Sidebar from '../sidebar';\nimport PrismCode from '../../ReactJs/prismCode';\n\n\nconst titles = { backgroundColor: '#F0F8FF', padding: '1px', fontSize: '16px' }\n\nconst styles = theme => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1)\n  },\n  smMargin: {\n    margin: theme.spacing(1)\n  },\n  actionDiv: {\n    textAlign: \"center\"\n  }\n})\n\nconst abstrcts = `\nfrom abc import ABC, abstractmethod\n\nclass Computer(ABC):\n    @abstractmethod\n    def process(self):\n        pass\n\nclass Laptop(Computer):\n    def process(self):\n        print(\"It's running\")\n\nobj=Laptop()\nobj.process()`.trim();\n\nconst decorator = `\ndef decor_result(result_function):\n    def distinction(marks):\n        for m in marks:\n            if m>=75:\n                print(\"Distinction\")\n        result_function(marks)\n    return distinction\n\n@decor_result\ndef result(marks):\n    for m in marks:\n        if m>=33:\n            pass\n        else:\n            print('FAIL')\n            break\n    else:\n        print('PASS')\nresult([45,67,87,65,78])`.trim();\n\nconst decorated = `\n@my_decorator\ndef my_function():\n    pass`.trim();\n\nconst consequence = `\ndef start_end_decorator(func):\n    \n    def wrapper():\n        print('Start')\n        func()\n        print('End')\n    return wrapper\n\ndef print_name():\n    print('Alex')\n    \nprint_name()\n\nprint()\n\nprint_name = start_end_decorator(print_name)\nprint_name()`.trim();\n\nconst achieve = `\n@start_end_decorator\ndef print_name():\n    print('Alex')\n    \nprint_name()`.trim();\n\nconst argumentse = `\ndef start_end_decorator_2(func):\n    \n    def wrapper(*args, **kwargs):\n        print('Start')\n        func(*args, **kwargs)\n        print('End')\n    return wrapper\n\n@start_end_decorator_2\ndef add_5(x):\n    return x + 5\n\nresult = add_5(10)\nprint(result)`.trim();\n\nconst inner = `\ndef start_end_decorator_3(func):\n    \n    def wrapper(*args, **kwargs):\n        print('Start')\n        result = func(*args, **kwargs)\n        print('End')\n        return result\n    return wrapper\n\n@start_end_decorator_3\ndef add_5(x):\n    return x + 5\n\nresult = add_5(10)\nprint(result)`.trim();\n\nconst identity = `\nprint(add_5.__name__)\nhelp(add_5)`.trim();\n\nconst template = `\nimport functools\n\ndef my_decorator(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return wrapper`.trim();\n\nconst repeats = `\ndef repeat(num_times):\n    def decorator_repeat(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            for _ in range(num_times):\n                result = func(*args, **kwargs)\n            return result\n        return wrapper\n    return decorator_repeat\n\n@repeat(num_times=3)\ndef greet(name):\n    print(f\"Hello {name}\")\n    \ngreet('Alex')`.trim();\n\nconst executed = `\ndef debug(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        args_repr = [repr(a) for a in args]\n        kwargs_repr = [f\"{k}={v!r}\" for k, v in kwargs.items()]\n        signature = \", \".join(args_repr + kwargs_repr)\n        print(f\"Calling {func.__name__}({signature})\")\n        result = func(*args, **kwargs)\n        print(f\"{func.__name__!r} returned {result!r}\")\n        return result\n    return wrapper\n\n@debug\n@start_end_decorator_4\ndef say_hello(name):\n    greeting = f'Hello {name}'\n    print(greeting)\n    return greeting\n\nsay_hello(name='Alex')`.trim();\n\nconst preserve = `\nimport functools\n\nclass CountCalls:\n                                                          # the init needs to have the func as argument and stores it\n    def __init__(self, func):\n        functools.update_wrapper(self, func)\n        self.func = func\n        self.num_calls = 0\n    \n                                                          # extend functionality, execute function, and return the result\n    def __call__(self, *args, **kwargs):\n        self.num_calls += 1\n        print(f\"Call {self.num_calls} of {self.func.__name__!r}\")\n        return self.func(*args, **kwargs)\n\n@CountCalls\ndef say_hello(num):\n    print(\"Hello!\")\n    \nsay_hello(5)\nsay_hello(5)`.trim();\n\n\nclass Abstract extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0)\n  }\n  render() {\n    const { classes } = this.props;\n    return (\n      <Grid container>\n        <Grid item xs={2}>\n          <Paper className={classes.paper}>\n            <h4><Sidebar /></h4>\n          </Paper>\n        </Grid>\n        <Grid item xs={10}>\n          <Paper className={classes.paper}>\n            <List>\n              <h3>Abstract Class</h3>\n              <ul>\n                <li>Python default don't support abstract class. But with abc module can do.</li>\n                <li>Abstract class has at least one abstract method.</li>\n              </ul>\n              <div style={titles}>\n                <PrismCode\n                  code={abstrcts}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3>Decorators</h3>\n              A decorator is a function that takes another function and extends the behavior of this function without explicitly modifying it. It allows to add new functionality to an existing function.\n              <br />\n              <br />\n              There are 2 kinds of decorators:\n              <ul>\n                <li>Function decoratos</li>\n                <li>Class decorators</li>\n              </ul>\n              <br />\n              A function is decorated with the <b>@</b> symbol:\n              <div style={titles}>\n                <PrismCode\n                  code={decorated}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3>Function decorators</h3>\n              A decorator function takes another function as argument, wraps its behaviour inside an inner function. and returns the wrapped\n              function. The decorated function no has extended functionality.\n              <div style={titles}>\n                <PrismCode\n                  code={consequence}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3>The decorator syntax</h3>\n              Instead of wrapping our function and asigning it to itself, Achieve same thing by decorating our function with an @.\n              <div style={titles}>\n                <PrismCode\n                  code={achieve}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3>What about function arguments</h3>\n              If our function has input arguments and we try to wrap it with our decorator above, it will raise a TypeError since we have to call our function inside the wrapper with this arguments, too. However, we can fix this by using *args and **kwargs in the inner function:\n              <div style={titles}>\n                <PrismCode\n                  code={argumentse}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3>Return values</h3>\n              Above, we do not get the result back, now return the value from our inner function:\n              <div style={titles}>\n                <PrismCode\n                  code={inner}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3>What about the function identity?</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={identity}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3>The final template for own decorators</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={template}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3>Decorator function arguments</h3>\n              functools.wraps is a decorator that takes an argument for itself. We can think of this as 2 inner functions, so an inner function\n              within inner function.\n              <br />\n              <br />\n              <b>Another example: </b>A repeat decorator that takes a number as input. Within\n              this function, we have the actual decorator function that wraps our function and extends its behaviour within another inner function.\n              In this case, it repeats the input function the given number of times.\n              <div style={titles}>\n                <PrismCode\n                  code={repeats}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3>Nested Decorators</h3>\n              We can apply several decorators to a function by stacking them on top of each other. The decorators are being executed in the order they are listed.\n              <div style={titles}>\n                <PrismCode\n                  code={executed}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3>Class decorators</h3>\n              We can also use a class as a decorator. Therefore, we have to implement the __call__() method to make our object callable. Class decorators are typically used to maintain a state, e.g. here we keep track of the number of times our function is executed. The __call__ method does essentially the same thing as the wrapper() method we have seen earlier. It adds some functionality, executes the function, and returns its result. Note that here we use functools.update_wrapper() instead of functools.wraps to preserve the information about our function.\n              <div style={titles}>\n                <PrismCode\n                  code={preserve}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3>Some typical use cases</h3>\n              <ul>\n                <li>Use a timer decorator to calculate the execution time of a function.</li>\n                <li>Use a debug decorator to print out some more information about the called function and its arguments.</li>\n                <li>Use a check decorator to check if the arguments fulfill some requirements and adapt the bevaviour accordingly.</li>\n                <li>Register functions (plugins).</li>\n                <li>Slow down code with time.sleep() to check network behaviour.</li>\n                <li>Cache the return values for memoization.</li>\n                <li>Add information or update a state.</li>\n              </ul>\n            </List>\n          </Paper>\n        </Grid>\n      </Grid>\n    )\n  }\n}\n\nexport default (withStyles(styles)(Abstract));\n"]},"metadata":{},"sourceType":"module"}