{"ast":null,"code":"import _classCallCheck from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/createClass\";import _possibleConstructorReturn from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";import _getPrototypeOf from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";import _inherits from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/inherits\";import React,{Component}from'react';import Prism from\"prismjs\";import{Grid,Paper,withStyles,List}from\"@material-ui/core\";import'../../ReactJs/styles.css';import Sidebar from'../sidebar';import PrismCode from'../../ReactJs/prismCode';import Logistic from'../../../assets/ML/svms.PNG';import svms2 from'../../../assets/ML/svm2.PNG';import svms3 from'../../../assets/ML/svms3.PNG';import svms4 from'../../../assets/ML/svm4.PNG';import svms5 from'../../../assets/ML/svm5.PNG';import svms6 from'../../../assets/ML/svm6.PNG';import svms7 from'../../../assets/ML/svm7.PNG';var titles={backgroundColor:'#F0F8FF',padding:'1px',fontSize:'16px'};var redesign={height:350,width:600};var styles=function styles(theme){return{paper:{margin:theme.spacing(1),padding:theme.spacing(1)},smMargin:{margin:theme.spacing(1)},actionDiv:{textAlign:\"center\"}};};var machines=\"\\nimport pandas as pd\\nfrom sklearn.datasets import load_iris\\n\\niris = load_iris()\\ndf = pd.DataFrame(iris.data,columns=iris.feature_names)\\n\\ndf['target'] = iris.target\\n\\ndf[df.target==1].head()\\ndf[df.target==2].head()\\n\\ndf['flower_name'] =df.target.apply(lambda x: iris.target_names[x])\\ndf[45:55]\\n\\ndf2 = df[:50]\\ndf2\\n\".trim();var sepal=\"\\nfrom sklearn.svm import SVC\\nfrom sklearn.model_selection import train_test_split \\n\\nplt.xlabel('Sepal Length')\\nplt.ylabel('Sepal Width')\\nplt.scatter(df0['sepal length (cm)'], df0['sepal width (cm)'],color=\\\"green\\\",marker='+')\\nplt.scatter(df1['sepal length (cm)'], df1['sepal width (cm)'],color=\\\"blue\\\",marker='.')\\n\\nplt.xlabel('Petal Length')                                            #Petal length vs Pepal Width (Setosa vs Versicolor)\\nplt.ylabel('Petal Width')\\nplt.scatter(df0['petal length (cm)'], df0['petal width (cm)'],color=\\\"green\\\",marker='+')\\nplt.scatter(df1['petal length (cm)'], df1['petal width (cm)'],color=\\\"blue\\\",marker='.')\\n\\nX = df.drop(['target','flower_name'], axis='columns')\\ny = df.target\\n\\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\\nlen(X_train)\\n\\nmodel = SVC()\\nmodel.fit(X_train, y_train)\\n\\nmodel.score(X_test, y_test)\\nmodel.predict([[4.8,3.0,1.5,0.3]])\\n\".trim();var Regularizations=\"\\nmodel_C = SVC(C=1)\\nmodel_C.fit(X_train, y_train)\\nmodel_C.score(X_test, y_test)\\n\\nmodel_C = SVC(C=10)\\nmodel_C.fit(X_train, y_train)\\nmodel_C.score(X_test, y_test)\\n\".trim();var gammas=\"\\nmodel_g = SVC(gamma=10)\\nmodel_g.fit(X_train, y_train)\\nmodel_g.score(X_test, y_test)\\n\".trim();var kernel=\"\\nmodel_linear_kernal = SVC(kernel='linear')\\nmodel_linear_kernal.fit(X_train, y_train)\\n\\nmodel_linear_kernal.score(X_test, y_test)\\n\".trim();var SvmPy=/*#__PURE__*/function(_Component){_inherits(SvmPy,_Component);function SvmPy(){_classCallCheck(this,SvmPy);return _possibleConstructorReturn(this,_getPrototypeOf(SvmPy).apply(this,arguments));}_createClass(SvmPy,[{key:\"componentDidMount\",value:function componentDidMount(){setTimeout(function(){return Prism.highlightAll();},0);}},{key:\"render\",value:function render(){var classes=this.props.classes;return React.createElement(Grid,{container:true},React.createElement(Grid,{item:true,xs:2},React.createElement(Paper,{className:classes.paper},React.createElement(\"h4\",null,React.createElement(Sidebar,null)))),React.createElement(Grid,{item:true,xs:10},React.createElement(Paper,{className:classes.paper},React.createElement(List,null,React.createElement(\"h3\",null,\"Support Vector Machine(SVM) (supervised machine learning algorithms)\"),\"SVMs are powerful yet flexible ML algorithms which are used both for classification and regression. But generally, they are used in classification problems.\",React.createElement(\"br\",null),\"Lately, they are extremely popular because of their ability to handle multiple continuous and categorical variables.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Working of SVM: \"),\"An SVM model is basically a representation of different classes in a hyperplane in multidimensional space. The hyperplane will be generated in an iterative manner by SVM so that the error can be minimized.\",React.createElement(\"br\",null),\"The goal of SVM is to divide the datasets into classes to find a maximum marginal hyperplane (MMH).\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"i\",null,React.createElement(\"b\",null,\"The followings are important concepts in SVM \\u2212 \")),React.createElement(\"ul\",null,React.createElement(\"li\",null,React.createElement(\"b\",null,\"Support Vectors: \"),\"Datapoints that are closest to the hyperplane is called support vectors. Separating line will be defined with the help of these data points.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Hyperplane: \"),\"It is a decision plane or space which is divided between a set of objects having different classes.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Margin: \"),\"It may be defined as the gap between two lines on the closet data points of different classes. It can be calculated as the perpendicular distance from the line to the support vectors. Large margin is considered as a good margin and small margin is considered as a bad margin. The main goal of SVM is to divide the datasets into classes to find a maximum marginal hyperplane (MMH) and it can be done in the following two steps:\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"1. First, SVM will generate hyperplanes iteratively that segregates the classes in best way. Then, it will choose the hyperplane that separates the classes correctly.\"),React.createElement(\"li\",null,\"SVM Kernels SVM algorithm is implemented with kernel that transforms an input data space into the required form. Kernel converts non-separable problems into separable problems by adding more dimensions to it. It makes SVM more powerful, flexible and accurate. The following are some of the types of kernels used by SVM. Linear Kernel It can be used as a dot product between any two observations. The formula of linear kernel is \\u2212\",React.createElement(\"br\",null),React.createElement(\"i\",null,React.createElement(\"b\",null,\"K(x,xi)=sum(x\\u2217xi)\")),React.createElement(\"br\",null),\"From the above formula, we can see that the product between two vectors \\uD835\\uDC65 & \\uD835\\uDC65\\uD835\\uDC56 is the sum of the multiplication of each pair of input values.\",React.createElement(\"br\",null),React.createElement(\"br\",null),\"Polynomial Kernel It is more generalized form of linear kernel and distinguish curved or nonlinear input space. Following is the formula for polynomial kernel \\u2212\",React.createElement(\"br\",null),React.createElement(\"i\",null,React.createElement(\"b\",null,\"k(X,Xi)=1+sum(X\\u2217Xi)^d\")),React.createElement(\"br\",null),React.createElement(\"br\",null),\"Here d is the degree of polynomial, which we need to specify manually in the learning algorithm.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Radial Basis Function (RBF) Kernel: \"),\" RBF kernel, mostly used in SVM classification, maps input space in indefinite dimensional space. Following formula explains it mathematically \\u2212\",React.createElement(\"br\",null),React.createElement(\"i\",null,React.createElement(\"b\",null,\"K(x,xi)=exp(\\u2212gamma\\u2217sum(x\\u2212xi^2)) \"))),React.createElement(\"br\",null),\"Here, gamma ranges from 0 to 1. We need to manually specify it in the learning algorithm. A good default value of gamma is 0.1. As we implemented SVM for linearly separable data, we can implement it in Python for the data that is not linearly separable. It can be done by using kernels.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Pros: \"),\"SVM classifiers offers great accuracy and work well with high dimensional space. SVM classifiers basically use a subset of training points hence in result uses very less memory.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Cons: \"),\" of SVM classifiers They have high training time hence in practice not suitable for large datasets. Another disadvantage is that SVM classifiers do not work well with overlapping classes.\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"Support Vector Machine (Supervised)\"),\"Used for both classification or regression challenges.\",React.createElement(\"br\",null),\"In the SVM algorithm, we plot each data item as a point in n-dimensional space (where n is a number of features we have) with the value of each feature being the value of a particular coordinate. Then, we perform classification by finding the hyper-plane that differentiates the two classes very well.\",React.createElement(\"br\",null),React.createElement(\"img\",{src:Logistic,alt:\"Equations\",className:\"responsive\",style:redesign}),React.createElement(\"br\",null),\"We got accustomed to the process of segregating the two classes with a hyper-plane. Now, \\u201CHow can we identify the right hyper-plane?\\u201D.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"ul\",null,React.createElement(\"li\",null,React.createElement(\"b\",null,\"Identify the right hyper-plane (Scenario-1): \"),\"We have three hyper-planes (A, B, and C). Now, identify the right hyper-plane to classify stars and circles.\"),React.createElement(\"br\",null),React.createElement(\"img\",{src:svms2,alt:\"Equations\",className:\"responsive\",style:redesign}),React.createElement(\"br\",null),React.createElement(\"i\",null,\"Remember a thumb rule to identify the right hyper-plane: \\u201CSelect the hyper-plane which segregates the two classes better\\u201D. Here, hyper-plane B.\"),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Identify the right hyper-plane (Scenario-2): \")),React.createElement(\"br\",null),React.createElement(\"img\",{src:svms3,alt:\"Equations\",className:\"responsive\",style:redesign}),React.createElement(\"br\",null),React.createElement(\"i\",null,\"Here, maximizing the distances between nearest data point (either class) and hyper-plane will help us to decide the right hyper-plane. This distance is called as Margin.\"),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"i\",null,\"Above, you can see that the margin for hyper-plane C is high as compared to both A and B. Hence, we name the right hyper-plane as C. Another lightning reason for selecting the hyper-plane with higher margin is robustness. If we select a hyper-plane having low margin then there is high chance of miss-classification.\"),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Identify the right hyper-plane (Scenario-3): \")),React.createElement(\"br\",null),React.createElement(\"img\",{src:svms4,alt:\"Equations\",className:\"responsive\",style:redesign}),React.createElement(\"br\",null),React.createElement(\"i\",null,\"Some of you may have selected the hyper-plane B as it has higher margin compared to A. But, here is the catch, SVM selects the hyper-plane which classifies the classes accurately prior to maximizing margin. Here, hyper-plane B has a classification error and A has classified all correctly. Therefore, the right hyper-plane is A.\"),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Can we classify two classes (Scenario-4): \"),\"We unable to segregate the two classes using a straight line, as one of the stars lies in the territory of other(circle) class as an outlier. \"),React.createElement(\"br\",null),React.createElement(\"img\",{src:svms5,alt:\"Equations\",className:\"responsive\",style:redesign}),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Find the hyper-plane to segregate to classes (Scenario-5): \")),React.createElement(\"br\",null),React.createElement(\"img\",{src:svms6,alt:\"Equations\",className:\"responsive\",style:redesign}),\"SVM can solve this problem. Easily! It solves this problem by introducing additional feature. Here, we will add a new feature z=x^2+y^2. Now, let\\u2019s plot the data points on axis x and z.\",React.createElement(\"br\",null),React.createElement(\"img\",{src:svms7,alt:\"Equations\",className:\"responsive\",style:redesign}),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"All values for z would be positive always because z is the squared sum of both x and y.\"),React.createElement(\"li\",null,\"In the original plot, red circles appear close to the origin of x and y axes, leading to lower value of z and star relatively away from the origin result to higher value of z.\"),React.createElement(\"br\",null),\"In the SVM classifier, it is easy to have a linear hyper-plane between these two classes. But, another burning question which arises is, should we need to add this feature manually to have a hyper-plane. No, the SVM  algorithm has a technique called the kernel trick. The SVM kernel is a function that takes low dimensional input space and transforms it to a higher dimensional space i.e. it converts not separable problem to separable problem. It is mostly useful in non-linear separation problem. Simply put, it does some extremely complex data transformations, then finds out the process to separate the data based on the labels or outputs you\\u2019ve defined.\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"Example\"),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:machines,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"Sepal length vs Sepal Width (Setosa vs Versicolor)\"),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:sepal,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"Tune parameters\"),React.createElement(\"b\",null,\"1. Regularization (C)\"),React.createElement(\"br\",null),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:Regularizations,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"b\",null,\"2. Gamma\"),React.createElement(\"br\",null),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:gammas,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"b\",null,\"3. Kernel\"),React.createElement(\"br\",null),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:kernel,language:\"js\",plugins:[\"line-numbers\"]}))))));}}]);return SvmPy;}(Component);export default withStyles(styles)(SvmPy);","map":{"version":3,"sources":["/home/mukeshs/Projects/edurights/src/components/ml/deepMl/svmPy.js"],"names":["React","Component","Prism","Grid","Paper","withStyles","List","Sidebar","PrismCode","Logistic","svms2","svms3","svms4","svms5","svms6","svms7","titles","backgroundColor","padding","fontSize","redesign","height","width","styles","theme","paper","margin","spacing","smMargin","actionDiv","textAlign","machines","trim","sepal","Regularizations","gammas","kernel","SvmPy","setTimeout","highlightAll","classes","props"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport Prism from \"prismjs\"\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\n\nimport '../../ReactJs/styles.css'\nimport Sidebar from '../sidebar';\nimport PrismCode from '../../ReactJs/prismCode';\n\nimport Logistic from '../../../assets/ML/svms.PNG'\nimport svms2 from '../../../assets/ML/svm2.PNG'\nimport svms3 from '../../../assets/ML/svms3.PNG'\nimport svms4 from '../../../assets/ML/svm4.PNG'\nimport svms5 from '../../../assets/ML/svm5.PNG'\nimport svms6 from '../../../assets/ML/svm6.PNG'\nimport svms7 from '../../../assets/ML/svm7.PNG'\n\n\nconst titles = { backgroundColor: '#F0F8FF', padding: '1px', fontSize: '16px' }\n\nconst redesign = {\n  height: 350,\n  width: 600\n}\n\nconst styles = theme => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1)\n  },\n  smMargin: {\n    margin: theme.spacing(1)\n  },\n  actionDiv: {\n    textAlign: \"center\"\n  }\n})\n\nconst machines = `\nimport pandas as pd\nfrom sklearn.datasets import load_iris\n\niris = load_iris()\ndf = pd.DataFrame(iris.data,columns=iris.feature_names)\n\ndf['target'] = iris.target\n\ndf[df.target==1].head()\ndf[df.target==2].head()\n\ndf['flower_name'] =df.target.apply(lambda x: iris.target_names[x])\ndf[45:55]\n\ndf2 = df[:50]\ndf2\n`.trim();\n\nconst sepal = `\nfrom sklearn.svm import SVC\nfrom sklearn.model_selection import train_test_split \n\nplt.xlabel('Sepal Length')\nplt.ylabel('Sepal Width')\nplt.scatter(df0['sepal length (cm)'], df0['sepal width (cm)'],color=\"green\",marker='+')\nplt.scatter(df1['sepal length (cm)'], df1['sepal width (cm)'],color=\"blue\",marker='.')\n\nplt.xlabel('Petal Length')                                            #Petal length vs Pepal Width (Setosa vs Versicolor)\nplt.ylabel('Petal Width')\nplt.scatter(df0['petal length (cm)'], df0['petal width (cm)'],color=\"green\",marker='+')\nplt.scatter(df1['petal length (cm)'], df1['petal width (cm)'],color=\"blue\",marker='.')\n\nX = df.drop(['target','flower_name'], axis='columns')\ny = df.target\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\nlen(X_train)\n\nmodel = SVC()\nmodel.fit(X_train, y_train)\n\nmodel.score(X_test, y_test)\nmodel.predict([[4.8,3.0,1.5,0.3]])\n`.trim();\n\nconst Regularizations = `\nmodel_C = SVC(C=1)\nmodel_C.fit(X_train, y_train)\nmodel_C.score(X_test, y_test)\n\nmodel_C = SVC(C=10)\nmodel_C.fit(X_train, y_train)\nmodel_C.score(X_test, y_test)\n`.trim();\n\nconst gammas = `\nmodel_g = SVC(gamma=10)\nmodel_g.fit(X_train, y_train)\nmodel_g.score(X_test, y_test)\n`.trim();\n\nconst kernel = `\nmodel_linear_kernal = SVC(kernel='linear')\nmodel_linear_kernal.fit(X_train, y_train)\n\nmodel_linear_kernal.score(X_test, y_test)\n`.trim();\n\n\nclass SvmPy extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0)\n  }\n  render() {\n    const { classes } = this.props;\n    return (\n      <Grid container>\n        <Grid item xs={2}>\n          <Paper className={classes.paper}>\n            <h4><Sidebar /></h4>\n          </Paper>\n        </Grid>\n        <Grid item xs={10}>\n          <Paper className={classes.paper}>\n            <List>\n              <h3>Support Vector Machine(SVM) (supervised machine learning algorithms)</h3>\n              SVMs are powerful yet flexible ML algorithms which are used both for classification and regression. But generally, they are used in classification problems.\n              <br />\n\n              Lately, they are extremely popular because of their ability to handle multiple continuous and categorical variables.\n              <br />\n              <br />\n              <b>Working of SVM: </b>\n              An SVM model is basically a representation of different classes in a hyperplane in multidimensional space. The\n              hyperplane will be generated in an iterative manner by SVM so that the error can be minimized.\n              <br />\n              The goal of SVM is to divide the datasets into classes to find a maximum marginal hyperplane (MMH).\n              <br />\n              <br />\n              <i><b>The followings are important concepts in SVM ‚àí </b></i>\n              <ul>\n                <li><b>Support Vectors: </b>Datapoints that are closest to the hyperplane is called support vectors. Separating line\n                  will be defined with the help of these data points.</li>\n                <li><b>Hyperplane: </b>It is a decision plane or space which is divided\n                  between a set of objects having different classes.</li>\n                <li><b>Margin: </b>It may be defined as the gap between two lines on the\n                  closet data points of different classes. It can be calculated as the perpendicular distance from the line to the\n                  support vectors. Large margin is considered as a good margin and small margin is considered as a bad margin. The\n                  main goal of SVM is to divide the datasets into classes to find a maximum marginal hyperplane (MMH) and it can be\n                  done in the following two steps:</li>\n                <ul>\n                  <li>1. First, SVM will generate hyperplanes iteratively that segregates the classes in\n                    best way. Then, it will choose the hyperplane that separates the classes correctly.</li>\n                  <li>SVM Kernels SVM algorithm is\n                    implemented with kernel that transforms an input data space into the required form. Kernel converts non-separable\n                    problems into separable problems by adding more dimensions to it. It makes SVM more powerful, flexible and accurate.\n                    The following are some of the types of kernels used by SVM. Linear Kernel It can be used as a dot product between\n                    any two observations. The formula of linear kernel is ‚àí\n                    <br />\n                    <i><b>K(x,xi)=sum(x‚àóxi)</b></i>\n                    <br />\n                    From the above formula, we can\n                    see that the product between two vectors ùë• & ùë•ùëñ is the sum of the multiplication of each pair of input values.\n                    <br />\n                    <br />\n                    Polynomial Kernel It is more generalized form of linear kernel and distinguish curved or nonlinear input space.\n                    Following is the formula for polynomial kernel ‚àí<br />\n                    <i><b>k(X,Xi)=1+sum(X‚àóXi)^d</b></i>\n                    <br />\n                    <br />\n                    Here d is the degree of polynomial, which we\n                    need to specify manually in the learning algorithm.\n                    <br />\n                    <br />\n                    <b>Radial Basis Function (RBF) Kernel: </b> RBF kernel, mostly used in SVM\n                    classification, maps input space in indefinite dimensional space. Following formula explains it mathematically ‚àí\n                    <br />\n                    <i><b>K(x,xi)=exp(‚àígamma‚àósum(x‚àíxi^2)) </b></i></li>\n                  <br />\n                  Here, gamma ranges from 0 to 1. We need to manually specify it in the learning algorithm. A good default value of\n                  gamma is 0.1. As we implemented SVM for linearly separable data, we can implement it in Python for the data that is\n                  not linearly separable. It can be done by using kernels.\n                  <br />\n                  <br />\n                  <b>Pros: </b>\n                  SVM classifiers offers great accuracy and work well with high dimensional space. SVM classifiers basically use a\n                  subset of training points hence in result uses very less memory.\n\n                  <br />\n                  <br />\n                  <b>Cons: </b> of SVM classifiers They have high training time\n                  hence in practice not suitable for large datasets. Another disadvantage is that SVM classifiers do not work well with\n                  overlapping classes.\n                </ul>\n              </ul>\n              <br />\n\n              <h3>Support Vector Machine (Supervised)</h3>\n              Used for both classification or regression challenges.\n              <br />\n              In the SVM algorithm, we plot each data item as a point in n-dimensional space (where n is a number of features we have)\n              with the value of each feature being the value of a particular coordinate. Then, we perform classification by\n              finding the hyper-plane that differentiates the two classes very well.\n              <br />\n              <img src={Logistic} alt=\"Equations\" className=\"responsive\" style={redesign} />\n              <br />\n\n              We got accustomed to the process of segregating the two classes with a hyper-plane. Now, ‚ÄúHow can we identify the\n              right hyper-plane?‚Äù.\n              <br />\n              <br />\n              <ul>\n                <li><b>Identify the right hyper-plane (Scenario-1): </b>We have three hyper-planes (A, B, and C).\n                  Now, identify the right hyper-plane to classify stars and circles.</li>\n                <br />\n                <img src={svms2} alt=\"Equations\" className=\"responsive\" style={redesign} />\n                <br />\n                <i>Remember a thumb rule to identify the right hyper-plane: ‚ÄúSelect the hyper-plane which segregates\n                  the two classes better‚Äù. Here, hyper-plane B.</i>\n                <br />\n                <br />\n\n                <li><b>Identify the right hyper-plane (Scenario-2): </b></li>\n                <br />\n                <img src={svms3} alt=\"Equations\" className=\"responsive\" style={redesign} />\n                <br />\n                <i>Here, maximizing the distances between nearest data point (either class) and hyper-plane will help us\n                  to decide the right hyper-plane. This distance is called as Margin.</i>\n                <br />\n                <br />\n                <i>Above, you can see that the margin for hyper-plane C is high as compared to both A and B. Hence,\n                  we name the right hyper-plane as C. Another lightning reason for selecting the hyper-plane with\n                  higher margin is robustness. If we select a hyper-plane having low margin then there is high chance\n                  of miss-classification.</i>\n                <br />\n                <br />\n\n                <li><b>Identify the right hyper-plane (Scenario-3): </b></li>\n                <br />\n                <img src={svms4} alt=\"Equations\" className=\"responsive\" style={redesign} />\n                <br />\n                <i>Some of you may have selected the hyper-plane B as it has higher margin compared to A. But, here\n                  is the catch, SVM selects the hyper-plane which classifies the classes accurately prior to\n                  maximizing margin. Here, hyper-plane B has a classification error and A has classified all\n                  correctly. Therefore, the right hyper-plane is A.</i>\n                <br />\n                <br />\n\n                <li><b>Can we classify two classes (Scenario-4): </b>We unable to segregate the two classes using a\n                  straight line, as one of the stars lies in the territory of other(circle) class as an outlier. </li>\n                <br />\n                <img src={svms5} alt=\"Equations\" className=\"responsive\" style={redesign} />\n                <br />\n                <br />\n\n                <li><b>Find the hyper-plane to segregate to classes (Scenario-5): </b></li>\n                <br />\n                <img src={svms6} alt=\"Equations\" className=\"responsive\" style={redesign} />\n                SVM can solve this problem. Easily! It solves this problem by introducing additional feature. Here,\n                we will add a new feature z=x^2+y^2. Now, let‚Äôs plot the data points on axis x and z.\n                <br />\n                <img src={svms7} alt=\"Equations\" className=\"responsive\" style={redesign} />\n                <ul>\n                  <li>All values for z would be positive always because z is the squared sum of both x and y.</li>\n                  <li>In the original plot, red circles appear close to the origin of x and y axes, leading to\n                    lower value of z and star relatively away from the origin result to higher value of z.</li>\n                  <br />\n                  In the SVM classifier, it is easy to have a linear hyper-plane between these two classes. But,\n                  another burning question which arises is, should we need to add this feature manually to have a\n                  hyper-plane. No, the SVM  algorithm has a technique called the kernel trick. The SVM kernel is a\n                  function that takes low dimensional input space and transforms it to a higher dimensional space\n                  i.e. it converts not separable problem to separable problem. It is mostly useful in non-linear\n                  separation problem. Simply put, it does some extremely complex data transformations, then finds\n                  out the process to separate the data based on the labels or outputs you‚Äôve defined.\n                </ul>\n              </ul>\n              <br />\n\n              <h3>Example</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={machines}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3>Sepal length vs Sepal Width (Setosa vs Versicolor)</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={sepal}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3>Tune parameters</h3>\n              <b>1. Regularization (C)</b>\n              <br />\n              <div style={titles}>\n                <PrismCode\n                  code={Regularizations}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <b>2. Gamma</b>\n              <br />\n              <div style={titles}>\n                <PrismCode\n                  code={gammas}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <b>3. Kernel</b>\n              <br />\n              <div style={titles}>\n                <PrismCode\n                  code={kernel}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n            </List>\n          </Paper>\n        </Grid>\n      </Grid>\n    )\n  }\n}\n\nexport default (withStyles(styles)(SvmPy));\n"]},"metadata":{},"sourceType":"module"}