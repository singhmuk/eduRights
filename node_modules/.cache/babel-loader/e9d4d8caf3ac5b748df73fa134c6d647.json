{"ast":null,"code":"import _classCallCheck from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/createClass\";import _possibleConstructorReturn from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";import _getPrototypeOf from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";import _inherits from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/inherits\";import React,{Component}from'react';import Prism from\"prismjs\";import{Grid,Paper,withStyles,List}from\"@material-ui/core\";import'../../ReactJs/styles.css';import Sidebar from'../sidebar';import PrismCode from'../../ReactJs/prismCode';var titles={backgroundColor:'#F0F8FF',padding:'1px',fontSize:'16px'};var styles=function styles(theme){return{paper:{margin:theme.spacing(1),padding:theme.spacing(1)},smMargin:{margin:theme.spacing(1)},actionDiv:{textAlign:\"center\"}};};var buffer=\"\\nvar buf = Buffer.alloc(10);\\nvar buf = new Buffer([10, 20, 30, 40, 50]);\\nvar buf = Buffer.from('abc');\\nvar buf = Buffer.from(\\\"Simply Easy Learning\\\", \\\"utf-8\\\");\\n\\nconsole.log(buf);\\n\".trim();var firstBuf=\"\\nconst firstBuf = Buffer.alloc(1024);\\nconst filledBuf = Buffer.alloc(1024, 1);\\nconst asciiBuf = Buffer.alloc(5, 'a', 'ascii');          //create a buffer five bytes long and stores only ASCII characters\\n\\nconsole.log(asciiBuf);\\n\".trim();var stringBuf=\"\".trim();var code=\"\\nconst stringBuf = Buffer.from('My name is Paul');\\nconsole.log(stringBuf);\\n\\nconst asciiBuf = Buffer.alloc(5, 'a', 'ascii');\\nconst asciiCopy = Buffer.from(asciiBuf);\\nconsole.log(asciiCopy);\\n\\nconst tenZeroes = Buffer.alloc(10);\\nconsole.log(tenZeroes.toString());\\n\".trim();var hiBuf=\"\\nconst hiBuf = Buffer.from('Hi!');\\nconsole.log(hiBuf[0]);\\nconsole.log(hiBuf.toString());\\nconsole.log(hiBuf.toString('hex'));\\nconsole.log(hiBuf.toJSON());\\n\\n\\n//2\\nbuf = new Buffer.alloc(26);\\nfor (var i = 0; i < 26; i++) {\\n  buf[i] = i + 97;\\n}\\n\\nconsole.log(buf.toString(\\\"ascii\\\"));                                           // abcdefghijklmnopqrstuvwxyz.\\nconsole.log(buf.toString(\\\"ascii\\\", 0, 5));                                     // abcde.\\nconsole.log(buf.toString(\\\"utf8\\\", 0, 5));                                      // abcde.\\nconsole.log(buf.toString(undefined, 0, 5));\\n\".trim();var hiBufs=\"\\nconst hiBuf = Buffer.from('Hi!');\\nhiBuf[1] = 'e';\\nconsole.log(hiBuf.toString());\\n\\nhiBuf[1] = 101;\\nconsole.log(hiBuf.toString());\\n\\nconst petBuf = Buffer.alloc(3);\\npetBuf.write('Cats');\\nconsole.log(petBuf.toString());\\n\\n//first two characters are overwritten, but the rest of the buffer is untouched.\\nconst petBuf2 = Buffer.alloc(4);\\npetBuf2.write('Cats');\\npetBuf2.write('Hi');\\nconsole.log(petBuf2.toString());\\n\".trim();var buff=\"\\nbuf = new Buffer.alloc(256);\\nlen = buf.write(\\\"Simply Easy Learning\\\");\\n\\nconsole.log(\\\"Octets written : \\\" + len);\\n\\n\\n//\\nvar buffer1 = new Buffer.from(\\\"ABC\\\");\\nvar buffer2 = new Buffer.from(\\\"ABCD\\\");\\nvar result = buffer1.compare(buffer2);\\n\\nif (result < 0) {\\n  console.log(buffer1 + \\\" comes before \\\" + buffer2);\\n} else if (result === 0) {\\n  console.log(buffer1 + \\\" is same as \\\" + buffer2);\\n} else {\\n  console.log(buffer1 + \\\" comes after \\\" + buffer2);\\n}\\n\\n\\n//\\nvar buffer1 = new Buffer.from(\\\"TutorialsPoint \\\");\\nvar buffer2 = new Buffer.from(\\\"Simply Easy Learning\\\");\\nvar buffer3 = Buffer.concat([buffer1, buffer2]);\\n\\nconsole.log(\\\"buffer3 content: \\\" + buffer3);\\n\\n\\n//copy a buffer\\nvar buffer1 = new Buffer.from(\\\"ABC\\\");\\n\\nvar buffer2 = new Buffer.alloc(3);\\nbuffer1.copy(buffer2);\\nconsole.log(\\\"buffer2 content: \\\" + buffer2.toString());\".trim();var buffJson=\"\\nconst data = [\\n  { name: \\\"John Doe\\\", age: 23 },\\n  { name: \\\"John Doe\\\", age: 2 },\\n  { name: \\\"John Doe\\\", age: 3 },\\n  { name: \\\"John Doe\\\", age: 4 },\\n];\\n\\nconst buff = Buffer.from(data);\\n\\nlet bufferOne = Buffer.from(data);\\n\\nlet json = bufferOne.toJSON();\\n// let json = JSON.stringify(bufferOne);\\nconsole.log(json);\\n\".trim();var BufferNode=/*#__PURE__*/function(_Component){_inherits(BufferNode,_Component);function BufferNode(){_classCallCheck(this,BufferNode);return _possibleConstructorReturn(this,_getPrototypeOf(BufferNode).apply(this,arguments));}_createClass(BufferNode,[{key:\"componentDidMount\",value:function componentDidMount(){setTimeout(function(){return Prism.highlightAll();},0);}},{key:\"render\",value:function render(){var classes=this.props.classes;return React.createElement(Grid,{container:true},React.createElement(Grid,{item:true,xs:2},React.createElement(Paper,{className:classes.paper},React.createElement(\"h4\",null,React.createElement(Sidebar,null)))),React.createElement(Grid,{item:true,xs:10},React.createElement(Paper,{className:classes.paper},React.createElement(List,null,React.createElement(\"h3\",null,\"Buffer\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Pure JavaScript is Unicode friendly, but it is not so for binary data. While dealing with TCP streams or the file system, it's necessary to handle octet streams. Node provides Buffer class which help to store raw data to a raw memory allocation outside the V8 heap.\"),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:buffer,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"i\",null,\"This method returns the number of octets written. If there is not enough space in the buffer to fit the entire string, it will write a part of the string.\"),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"alloc() - \"),\"Creates a Buffer object of the specified length.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"allocUnsafe() - \"),\"Creates a non-zero-filled Buffer of the specified length.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"compare() - \"),\"Compares two Buffer objects.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"concat() - \"),\"Concatenates an array of Buffer objects into one Buffer object.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"copy() - \"),\"Copies the specified number of bytes of a Buffer object\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"entries() - \"),\"Returns an iterator of \\\"index\\\" \\\"byte\\\" pairs of a Buffer object\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"equals() - \"),\"Compares two Buffer objects, and returns true if it is a match, otherwise false\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"fill() - \"),\"Fills a Buffer object with the specified values\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"from() - \"),\"Creates a Buffer object from an object (string/array/buffer)\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"includes() - \"),\"Checks if the Buffer object contains the specified value. Returns true if there is a match, otherwise false\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"indexOf() - \"),\"Checks if the Buffer object contains the specified value. Returns the first occurrence, otherwise -1\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"keys() - \"),\"Returns an array of keys in a Buffer object length - Returns the length of a Buffer object, in bytes\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"slice() - \"),\"Slices a Buffer object into a new Buffer objects starting and ending at the specified positions\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"swap16()- \"),\"Swaps the byte-order of a 16 bit Buffer object\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"toString()- \"),\"Returns a string version of a Buffer object\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"toJSON()- \"),\"Returns a JSON version of a Buffer object\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"values()- \"),\"Returns an array of values in a Buffer object\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"write() - \"),\"Writes a specified string to a Buffer object\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"Buffering process output\"),React.createElement(\"p\",null,\"In cases where the complete buffered output of a child process is sufficient, with no need to manage data through events, child_process offers the exec method. The method takes three arguments: \"),\"command: A command-line string. Unlike spawn and fork, which pass arguments to a command via an array, this first argument accepts a full command string, such as ps aux | grep node.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"ul\",null,React.createElement(\"b\",null,\"options: This is an optional argument.\"),React.createElement(\"li\",null,\"cwd (String): This sets the working directory for the command process.\"),React.createElement(\"li\",null,\"env (Object): This is a map of key-value pairs that will be exposed  to the child process.\"),React.createElement(\"li\",null,\"encoding (String): This is the encoding of the child's data stream.  The default value is 'utf8'.\"),React.createElement(\"li\",null,\"timeout (Number): This specifies the milliseconds to wait for the process to complete, at which point the child process will be sent  the killSignal.maxBuffer value.\"),React.createElement(\"li\",null,\"killSignal.maxBuffer (Number): This is the maximum number  of bytes allowed on stdout or stderr. When this number is exceeded, the process is killed. This default is 200 KB.\"),React.createElement(\"li\",null,\"killSignal (String): The child process receives this signal after  a timeout. This default is SIGTERM.\")),React.createElement(\"br\",null),\"When you want the buffering behavior of exec but are targeting a Node file, use execFile. Importantly, execFile does not spawn a new subshell, which makes  it slightly less expensive to run.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Create Buffer\"),React.createElement(\"p\",null,\"If we store data in memory that we receive, then create a new buffer. In Node.js we use the alloc().\"),React.createElement(\"p\",null,\"The alloc() function takes the size of the buffer as its first and only required argument. The size is an integer representing how many bytes of memory the buffer object will use.\"),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:firstBuf,la:true,nguage:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:buff,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"2 Ways to create buffer\"),React.createElement(\"p\",null,\"Create a buffer from data that already exists, like a string or array.\"),\"To create a buffer from pre-existing data, we use the from() method. We can use that function to create buffers from:\",React.createElement(\"ul\",null,React.createElement(\"li\",null,React.createElement(\"b\",null,\"An array of integers :\"),\" The integer values can be between 0 and 255.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"An ArrayBuffer :\"),\" This is a JavaScript object that stores a fixed length of bytes.\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"A string\"),React.createElement(\"li\",null,\"Another buffer\"))),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:stringBuf,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Reading from buffer\"),React.createElement(\"p\",null,\"To access one byte of a buffer, we pass the index or location of the byte we want. Buffers store data sequentially like arrays.\"),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:hiBuf,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Modify buffer\"),React.createElement(\"p\",null,React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Buffer can only accept an integer value. We can\\u2019t assign it to the letter.\"),React.createElement(\"li\",null,\"If try to write more bytes than a buffer\\u2019s size, the buffer object will only accept what bytes fit.\"))),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:hiBufs,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"Buffer to JSON\"),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:buffJson,language:\"js\",plugins:[\"line-numbers\"]}))))));}}]);return BufferNode;}(Component);export default withStyles(styles)(BufferNode);","map":{"version":3,"sources":["/home/mukeshs/Projects/edurights/src/components/nodeJs/nodeDeep/buffers.js"],"names":["React","Component","Prism","Grid","Paper","withStyles","List","Sidebar","PrismCode","titles","backgroundColor","padding","fontSize","styles","theme","paper","margin","spacing","smMargin","actionDiv","textAlign","buffer","trim","firstBuf","stringBuf","code","hiBuf","hiBufs","buff","buffJson","BufferNode","setTimeout","highlightAll","classes","props"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport Prism from \"prismjs\"\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\n\nimport '../../ReactJs/styles.css'\nimport Sidebar from '../sidebar';\nimport PrismCode from '../../ReactJs/prismCode';\n\n\nconst titles = { backgroundColor: '#F0F8FF', padding: '1px', fontSize: '16px' }\n\nconst styles = theme => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1)\n  },\n  smMargin: {\n    margin: theme.spacing(1)\n  },\n  actionDiv: {\n    textAlign: \"center\"\n  }\n})\n\n\nconst buffer = `\nvar buf = Buffer.alloc(10);\nvar buf = new Buffer([10, 20, 30, 40, 50]);\nvar buf = Buffer.from('abc');\nvar buf = Buffer.from(\"Simply Easy Learning\", \"utf-8\");\n\nconsole.log(buf);\n`.trim();\n\nconst firstBuf = `\nconst firstBuf = Buffer.alloc(1024);\nconst filledBuf = Buffer.alloc(1024, 1);\nconst asciiBuf = Buffer.alloc(5, 'a', 'ascii');          //create a buffer five bytes long and stores only ASCII characters\n\nconsole.log(asciiBuf);\n`.trim();\n\nconst stringBuf = ``.trim();\n\nconst code = `\nconst stringBuf = Buffer.from('My name is Paul');\nconsole.log(stringBuf);\n\nconst asciiBuf = Buffer.alloc(5, 'a', 'ascii');\nconst asciiCopy = Buffer.from(asciiBuf);\nconsole.log(asciiCopy);\n\nconst tenZeroes = Buffer.alloc(10);\nconsole.log(tenZeroes.toString());\n`.trim();\n\nconst hiBuf = `\nconst hiBuf = Buffer.from('Hi!');\nconsole.log(hiBuf[0]);\nconsole.log(hiBuf.toString());\nconsole.log(hiBuf.toString('hex'));\nconsole.log(hiBuf.toJSON());\n\n\n//2\nbuf = new Buffer.alloc(26);\nfor (var i = 0; i < 26; i++) {\n  buf[i] = i + 97;\n}\n\nconsole.log(buf.toString(\"ascii\"));                                           // abcdefghijklmnopqrstuvwxyz.\nconsole.log(buf.toString(\"ascii\", 0, 5));                                     // abcde.\nconsole.log(buf.toString(\"utf8\", 0, 5));                                      // abcde.\nconsole.log(buf.toString(undefined, 0, 5));\n`.trim();\n\nconst hiBufs = `\nconst hiBuf = Buffer.from('Hi!');\nhiBuf[1] = 'e';\nconsole.log(hiBuf.toString());\n\nhiBuf[1] = 101;\nconsole.log(hiBuf.toString());\n\nconst petBuf = Buffer.alloc(3);\npetBuf.write('Cats');\nconsole.log(petBuf.toString());\n\n//first two characters are overwritten, but the rest of the buffer is untouched.\nconst petBuf2 = Buffer.alloc(4);\npetBuf2.write('Cats');\npetBuf2.write('Hi');\nconsole.log(petBuf2.toString());\n`.trim();\n\nconst buff = `\nbuf = new Buffer.alloc(256);\nlen = buf.write(\"Simply Easy Learning\");\n\nconsole.log(\"Octets written : \" + len);\n\n\n//\nvar buffer1 = new Buffer.from(\"ABC\");\nvar buffer2 = new Buffer.from(\"ABCD\");\nvar result = buffer1.compare(buffer2);\n\nif (result < 0) {\n  console.log(buffer1 + \" comes before \" + buffer2);\n} else if (result === 0) {\n  console.log(buffer1 + \" is same as \" + buffer2);\n} else {\n  console.log(buffer1 + \" comes after \" + buffer2);\n}\n\n\n//\nvar buffer1 = new Buffer.from(\"TutorialsPoint \");\nvar buffer2 = new Buffer.from(\"Simply Easy Learning\");\nvar buffer3 = Buffer.concat([buffer1, buffer2]);\n\nconsole.log(\"buffer3 content: \" + buffer3);\n\n\n//copy a buffer\nvar buffer1 = new Buffer.from(\"ABC\");\n\nvar buffer2 = new Buffer.alloc(3);\nbuffer1.copy(buffer2);\nconsole.log(\"buffer2 content: \" + buffer2.toString());`.trim();\n\nconst buffJson = `\nconst data = [\n  { name: \"John Doe\", age: 23 },\n  { name: \"John Doe\", age: 2 },\n  { name: \"John Doe\", age: 3 },\n  { name: \"John Doe\", age: 4 },\n];\n\nconst buff = Buffer.from(data);\n\nlet bufferOne = Buffer.from(data);\n\nlet json = bufferOne.toJSON();\n// let json = JSON.stringify(bufferOne);\nconsole.log(json);\n`.trim();\n\n\nclass BufferNode extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0)\n  }\n  render() {\n    const { classes } = this.props;\n    return (\n      <Grid container>\n        <Grid item xs={2}>\n          <Paper className={classes.paper}>\n            <h4><Sidebar /></h4>\n          </Paper>\n        </Grid>\n        <Grid item xs={10}>\n          <Paper className={classes.paper}>\n            <List>\n              <h3>Buffer</h3>\n              <ul>\n                <li>\n                  Pure JavaScript is Unicode friendly, but it is not so for binary data. While dealing with TCP streams or the file system, it's\n                  necessary to handle octet streams. Node provides Buffer class which help to store raw data \n                  to a raw memory allocation outside the V8 heap.\n                </li>\n                <div style={titles}>\n                  <PrismCode\n                    code={buffer}\n                    language=\"js\"\n                    plugins={[\"line-numbers\"]}\n                  />\n                </div>\n                <i>This method returns the number of octets written. If there is not enough space in the buffer to fit the entire string, it will write a part of the string.</i>\n                <br />\n                <br />\n\n                <li><b>alloc() - </b>Creates a Buffer object of the specified length.</li>\n                <li><b>allocUnsafe() - </b>Creates a non-zero-filled Buffer of the specified length.</li>\n                <li><b>compare() - </b>Compares two Buffer objects.</li>\n                <li><b>concat() - </b>Concatenates an array of Buffer objects into one Buffer object.</li>\n                <li><b>copy() - </b>Copies the specified number of bytes of a Buffer object</li>\n                <li><b>entries() - </b>Returns an iterator of \"index\" \"byte\" pairs of a Buffer object</li>\n                <li><b>equals() - </b>Compares two Buffer objects, and returns true if it is a match, otherwise false</li>\n                <li><b>fill() - </b>Fills a Buffer object with the specified values</li>\n                <li><b>from() - </b>Creates a Buffer object from an object (string/array/buffer)</li>\n                <li>\n                  <b>includes() - </b>Checks if the Buffer object contains the specified value. Returns true if there is a match, otherwise\n                  false\n                </li>\n                <li><b>indexOf() - </b>Checks if the Buffer object contains the specified value. Returns the first occurrence, otherwise -1</li>\n                <li><b>keys() - </b>Returns an array of keys in a Buffer object length - Returns the length of a Buffer object, in bytes</li>\n                <li><b>slice() - </b>Slices a Buffer object into a new Buffer objects starting and ending at the specified positions</li>\n                <li><b>swap16()- </b>Swaps the byte-order of a 16 bit Buffer object</li>\n                <li><b>toString()- </b>Returns a string version of a Buffer object</li>\n                <li><b>toJSON()- </b>Returns a JSON version of a Buffer object</li>\n                <li><b>values()- </b>Returns an array of values in a Buffer object</li>\n                <li><b>write() - </b>Writes a specified string to a Buffer object</li>\n              </ul>\n              <br />\n\n              <h3>Buffering process output</h3>\n              <p>In cases where the complete buffered output of a child process is sufficient, with no need to manage data through events,\n                child_process offers the exec method. The method takes three arguments: </p>\n              command: A command-line string. Unlike spawn and fork, which pass arguments to a command via an array, this first\n              argument accepts a full command string, such as ps aux | grep node.\n              <br />\n              <br />\n              <ul>\n                <b>options: This is an optional argument.</b>\n                <li>cwd (String): This sets the working directory for the command process.</li>\n                <li>env (Object): This is a map of key-value pairs that will be exposed  to the child process.</li>\n                <li>encoding (String): This is the encoding of the child's data stream.  The default value is 'utf8'.</li>\n                <li>timeout (Number): This specifies the milliseconds to wait for the process to complete, at which point the child process\n                  will be sent  the killSignal.maxBuffer value.</li>\n                <li>killSignal.maxBuffer (Number): This is the maximum number  of bytes allowed on stdout or stderr. When this number is\n                  exceeded, the process is killed. This default is 200 KB.</li>\n                <li>killSignal (String): The child process receives this signal after  a timeout. This default is SIGTERM.</li>\n              </ul>\n              <br />\n\n              When you want the buffering behavior of exec but are targeting a Node file, use execFile. Importantly, execFile does not\n              spawn a new subshell, which makes  it slightly less expensive to run.\n              <br />\n              <br />\n\n              <b>Create Buffer</b>\n              <p>\n                If we store data in memory that we receive, then create a new buffer. In Node.js we use the alloc().\n              </p>\n              <p>\n                The alloc() function takes the size of the buffer as its first and only required argument. The\n                size is an integer representing how many bytes of memory the buffer object will use.\n              </p>\n              <div style={titles}>\n                <PrismCode\n                  code={firstBuf}\n                  la nguage=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <div style={titles}>\n                <PrismCode\n                  code={buff}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <br />\n\n              <b>2 Ways to create buffer</b>\n              <p>\n                Create a buffer from data that already exists, like a string or array.\n              </p>\n              To create a buffer from pre-existing data, we use the from() method. We can use that function to\n              create buffers from:\n              <ul>\n                <li><b>An array of integers :</b> The integer values can be between 0 and 255.</li>\n                <li><b>An ArrayBuffer :</b> This is a JavaScript object that stores a fixed length of bytes.</li>\n                <ul>\n                  <li>A string</li>\n                  <li>Another buffer</li>\n                </ul>\n              </ul>\n              <div style={titles}>\n                <PrismCode\n                  code={stringBuf}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <br />\n\n              <b>Reading from buffer</b>\n              <p>\n                To access one byte of a buffer, we pass the index or location\n                of the byte we want. Buffers store data sequentially like arrays.\n              </p>\n              <div style={titles}>\n                <PrismCode\n                  code={hiBuf}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <br />\n\n              <b>Modify buffer</b>\n              <p>\n                <ul>\n                  <li>Buffer can only accept an integer value. We can’t assign it to the letter.</li>\n                  <li>If try to write more bytes than a buffer’s size, the buffer object will only accept what bytes fit.</li>\n                </ul>\n              </p>\n              <div style={titles}>\n                <PrismCode\n                  code={hiBufs}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n\n\n              <h3>Buffer to JSON</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={buffJson}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n            </List>\n          </Paper>\n        </Grid>\n      </Grid>\n    )\n  }\n}\n\nexport default (withStyles(styles)(BufferNode));\n"]},"metadata":{},"sourceType":"module"}