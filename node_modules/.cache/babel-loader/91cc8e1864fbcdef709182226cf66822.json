{"ast":null,"code":"import _classCallCheck from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/createClass\";import _possibleConstructorReturn from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";import _getPrototypeOf from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";import _inherits from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/inherits\";import React,{Component}from'react';import Prism from\"prismjs\";import{Grid,Paper,withStyles,List}from\"@material-ui/core\";import'../ReactJs/styles.css';import Sidebar from'./sidebar';import PrismCode from'../ReactJs/prismCode';var titles={backgroundColor:'#F0F8FF',padding:'1px',fontSize:'16px'};var styles=function styles(theme){return{paper:{margin:theme.spacing(1),padding:theme.spacing(1)},smMargin:{margin:theme.spacing(1)},actionDiv:{textAlign:\"center\"}};};var matchers=\"\\ntest(\\\"two plus two is four\\\", () => {\\n  expect(2 + 2).toBe(4);\\n});\\n\\ntest(\\\"object assignment\\\", () => {\\n  const data = { one: 1 };\\n  data[\\\"two\\\"] = 2;\\n  expect(data).toEqual({ one: 1, two: 2 });\\n});\\n\\ntest(\\\"array assignment\\\", () => {\\n  const data = [1];\\n  data.push(2);\\n  expect(data).toEqual([1, 2]);\\n});\\n\\ntest(\\\"adding positive numbers is not zero\\\", () => {\\n  for (let a = 1; a < 10; a++) {\\n    for (let b = 1; b < 10; b++) {\\n      expect(a + b).not.toBe(0);\\n    }\\n  }\\n});\\n\\ntest(\\\"null\\\", () => {\\n  const n = null;\\n  expect(n).toBeNull();\\n  expect(n).toBeDefined();\\n  expect(n).not.toBeUndefined();\\n  expect(n).not.toBeTruthy();\\n  expect(n).toBeFalsy();\\n});\\n\\ntest(\\\"zero\\\", () => {\\n  const z = 0;\\n  expect(z).not.toBeNull();\\n  expect(z).toBeDefined();\\n  expect(z).not.toBeUndefined();\\n  expect(z).not.toBeTruthy();\\n  expect(z).toBeFalsy();\\n});\\n\\ntest(\\\"two plus two\\\", () => {\\n  const value = 2 + 2;\\n  expect(value).toBeGreaterThan(3);\\n  expect(value).toBeGreaterThanOrEqual(3.5);\\n  expect(value).toBeLessThan(5);\\n  expect(value).toBeLessThanOrEqual(4.5);\\n\\n  // toBe and toEqual are equivalent for numbers\\n  expect(value).toBe(4);\\n  expect(value).toEqual(4);\\n});\\n\\ntest(\\\"adding floating point numbers\\\", () => {\\n  const value = 0.1 + 0.2;\\n  // expect(value).toBe(0.3);\\n  expect(value).toBeCloseTo(0.3);\\n});\\n\\ntest(\\\"there is no I in team\\\", () => {\\n  expect(\\\"team\\\").not.toMatch(/I/);\\n});\\n\\ntest('but there is a \\\"stop\\\" in Christoph', () => {\\n  expect(\\\"Christoph\\\").toMatch(/stop/);\\n});\\n\\nconst shoppingList = [\\n  \\\"diapers\\\",\\n  \\\"kleenex\\\",\\n  \\\"trash bags\\\",\\n  \\\"paper towels\\\",\\n  \\\"beer\\\"\\n];\\n\\ntest(\\\"the shopping list has beer on it\\\", () => {\\n  expect(shoppingList).toContain(\\\"beer\\\");\\n  expect(new Set(shoppingList)).toContain(\\\"beer\\\");\\n});\\n\\nclass ConfigError extends Error {}\\n\\nfunction compileAndroidCode() {\\n  throw new ConfigError(\\\"you are using the wrong JDK\\\");\\n}\\n\\ntest(\\\"compiling android goes as expected\\\", () => {\\n  expect(compileAndroidCode).toThrow();\\n  expect(compileAndroidCode).toThrow(ConfigError);\\n\\n  // You can also use the exact error message or a regexp\\n  expect(compileAndroidCode).toThrow(\\\"you are using the wrong JDK\\\");\\n  expect(compileAndroidCode).toThrow(/JDK/);\\n});\\n\".trim();var asynchronous=\"\\nfunction fetchData(callback) {\\n  setTimeout(() => {\\n    callback(\\\"peanut butter\\\");\\n  }, 100);\\n}\\n\\nfunction fetchDataPromise() {\\n  return new Promise(resolve => {\\n    setTimeout(() => {\\n      resolve(\\\"peanut butter\\\");\\n    }, 100);\\n  });\\n}\\n\\nfunction fetchDataPromiseWithErrorMessage() {\\n  return new Promise((resolve, reject) => {\\n    setTimeout(() => {\\n      reject(\\\"error\\\");\\n    }, 100);\\n  });\\n}\\n\\nfunction fetchDataPromiseWithError() {\\n  return new Promise((resolve, reject) => {\\n    setTimeout(() => {\\n      reject(new Error(\\\"error\\\"));\\n    }, 100);\\n  });\\n}\\n\\n// Don't do this!\\n// test(\\\"the data is peanut butter\\\", () => {\\n//   function callback(data) {\\n//     expect(data).toBe(\\\"peanut butter\\\");\\n//   }\\n\\n//   fetchData(callback);\\n// });\\n\\ntest(\\\"the data is peanut butter\\\", (done) => {\\n  function callback(data) {\\n    expect(data).toBe(\\\"peanut butter\\\");\\n    done();\\n  }\\n\\n  fetchData(callback);\\n});\\n\\ntest(\\\"the data is peanut butter\\\", () => {\\n  return fetchDataPromise().then(data => {\\n    expect(data).toBe(\\\"peanut butter\\\");\\n  });\\n});\\n\\ntest(\\\"the fetch fails with an error\\\", () => {\\n  expect.assertions(1);\\n  return fetchDataPromiseWithErrorMessage().catch(e =>\\n    expect(e).toMatch(\\\"error\\\")\\n  );\\n});\\n\\ntest(\\\"the data is peanut butter\\\", () => {\\n  return expect(fetchDataPromise()).resolves.toBe(\\\"peanut butter\\\");\\n});\\n\\ntest(\\\"the fetch fails with an error\\\", () => {\\n  return expect(fetchDataPromiseWithErrorMessage()).rejects.toMatch(\\\"error\\\");\\n});\\n\\ntest(\\\"the data is peanut butter\\\", async () => {\\n  const data = await fetchDataPromise();\\n  expect(data).toBe(\\\"peanut butter\\\");\\n});\\n\\ntest(\\\"the fetch fails with an error\\\", async () => {\\n  expect.assertions(1);\\n  try {\\n    await fetchDataPromiseWithErrorMessage();\\n  } catch (e) {\\n    expect(e).toMatch(\\\"error\\\");\\n  }\\n});\\n\\ntest(\\\"the data is peanut butter\\\", async () => {\\n  await expect(fetchDataPromise()).resolves.toBe(\\\"peanut butter\\\");\\n});\\n\\ntest(\\\"the fetch fails with an error\\\", async () => {\\n  await expect(fetchDataPromiseWithError()).rejects.toThrow(\\\"error\\\");\\n});\\n\".trim();var teardown=\"\\nlet cities = [];\\n\\nfunction initializeCityDatabase() {\\n  return new Promise((resolve, reject) => {\\n    setTimeout(() => {\\n      cities.push(\\\"Vienna\\\");\\n      cities.push(\\\"San Juan\\\");\\n      resolve();\\n    }, 100);\\n  });\\n}\\n\\nfunction clearCityDatabase() {\\n  return new Promise((resolve, reject) => {\\n    setTimeout(() => {\\n      cities = [];\\n      resolve();\\n    }, 100);\\n  });\\n}\\n\\nfunction isCity(name) {\\n  return cities.includes(name);\\n}\\n\\nbeforeAll(() => {\\n  return initializeCityDatabase();\\n});\\n\\nafterAll(() => {\\n  return clearCityDatabase();\\n});\\n\\ntest(\\\"city database has Vienna\\\", () => {\\n  expect(isCity(\\\"Vienna\\\")).toBeTruthy();\\n});\\n\\ntest(\\\"city database has San Juan\\\", () => {\\n  expect(isCity(\\\"San Juan\\\")).toBeTruthy();\\n});\\n\\ntest(\\\"has only 2 cities\\\", () => {\\n  expect(cities.length).toBe(2);\\n});\\n\".trim();var mocks=\"\\nfunction forEach(items, callback) {\\n  for (let index = 0; index < items.length; index++) {\\n    callback(items[index]);\\n  }\\n}\\n\\ntest(\\\"mockFunctions\\\", () => {\\n  const mockCallback = jest.fn(x => 42 + x);\\n  forEach([0, 1], mockCallback);\\n\\n  // The mock function is called twice\\n  expect(mockCallback.mock.calls.length).toBe(2);\\n\\n  // The first argument of the first call to the function was 0\\n  expect(mockCallback.mock.calls[0][0]).toBe(0);\\n\\n  // The first argument of the second call to the function was 1\\n  expect(mockCallback.mock.calls[1][0]).toBe(1);\\n\\n  // The return value of the first call to the function was 42\\n  expect(mockCallback.mock.results[0].value).toBe(42);\\n});\\n\\ntest(\\\"this\\\", () => {\\n  const myMock = jest.fn();\\n\\n  const a = new myMock();\\n  a.name = \\\"a\\\";\\n  const b = {};\\n  b.name = \\\"b\\\";\\n  const bound = myMock.bind(b);\\n  bound();\\n\\n  console.log(myMock.mock.instances);\\n  // > [ <a>, <b> ]\\n});\\n\\ntest(\\\"someMockFunction\\\", () => {\\n  const someMockFunction = jest.fn(() => \\\"return value\\\");\\n\\n  someMockFunction(\\\"first arg\\\", \\\"second arg\\\");\\n\\n  // The function was called exactly once\\n  expect(someMockFunction.mock.calls.length).toBe(1);\\n\\n  // The first arg of the first call to the function was 'first arg'\\n  expect(someMockFunction.mock.calls[0][0]).toBe(\\\"first arg\\\");\\n\\n  // The second arg of the first call to the function was 'second arg'\\n  expect(someMockFunction.mock.calls[0][1]).toBe(\\\"second arg\\\");\\n\\n  // The return value of the first call to the function was 'return value'\\n  expect(someMockFunction.mock.results[0].value).toBe(\\\"return value\\\");\\n\\n  const SomeMockConstructor = jest.fn();\\n  const a = new SomeMockConstructor();\\n  a.name = \\\"test\\\";\\n  const b = new SomeMockConstructor();\\n\\n  // This function was instantiated exactly twice\\n  expect(SomeMockConstructor.mock.instances.length).toBe(2);\\n\\n  // The object returned by the first instantiation of this function\\n  // had a 'name' property whose value was set to 'test'\\n  expect(SomeMockConstructor.mock.instances[0].name).toEqual(\\\"test\\\");\\n});\\n\\ntest(\\\"mockReturnValueOnce\\\", () => {\\n  const myMock = jest.fn();\\n  console.log(myMock());\\n  // > undefined\\n\\n  myMock\\n    .mockReturnValue(true)\\n    .mockReturnValueOnce(10)\\n    .mockReturnValueOnce(\\\"x\\\");\\n\\n  console.log(myMock(), myMock(), myMock(), myMock());\\n});\\n\\ntest(\\\"filterTest\\\", () => {\\n  const filterTestFn = jest.fn();\\n\\n  // Make the mock return 'true' for the first call, and 'false' for the second call\\n  filterTestFn.mockReturnValueOnce(true).mockReturnValueOnce(false);\\n\\n  const result = [11, 12].filter(filterTestFn);\\n\\n  console.log(result);\\n  // > [11]\\n  console.log(filterTestFn.mock.calls);\\n  // > [ [11], [12] ]\\n});\\n\\ntest(\\\"mockImplementation\\\", () => {\\n  const myMockFn = jest.fn(cb => cb(null, true));\\n\\n  myMockFn((err, val) => console.log(val));\\n  // > true\\n});\\n\\ntest(\\\"mockImplementationOnce\\\", () => {\\n  const myMockFn = jest\\n    .fn(() => \\\"default\\\")\\n    .mockImplementationOnce(() => \\\"first call\\\")\\n    .mockImplementationOnce(() => \\\"second call\\\");\\n\\n  console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());\\n  // > 'first call', 'second call', 'default', 'default'\\n});\\n\\ntest(\\\"return this\\\", () => {\\n  const myObj = {\\n    myMethod: jest.fn().mockReturnThis()\\n  };\\n\\n  // is the same as\\n  const otherObj = {\\n    myMethod: jest.fn(function() {\\n      return this;\\n    })\\n  };\\n\\n  console.log(myObj.myMethod());\\n  console.log(otherObj.myMethod());\\n});\\n\\ntest(\\\"mockName\\\", () => {\\n  const myMockFn = jest\\n    .fn()\\n    .mockReturnValue(\\\"default\\\")\\n    .mockImplementation(scalar => 42 + scalar)\\n    .mockName(\\\"add42\\\");\\n\\n  // expect(myMockFn).toBeCalled();\\n});\\n\\ntest(\\\"custom matchers\\\", () => {\\n  const mockFunc = jest.fn();\\n\\n  const arg1 = \\\"arg1\\\";\\n  const arg2 = \\\"arg2\\\";\\n\\n  mockFunc(arg1, arg2);\\n\\n  // The mock function was called at least once\\n  expect(mockFunc).toBeCalled();\\n\\n  // The mock function was called at least once with the specified args\\n  expect(mockFunc).toBeCalledWith(arg1, arg2);\\n\\n  // The last call to the mock function was called with the specified args\\n  expect(mockFunc).lastCalledWith(arg1, arg2);\\n\\n  // All calls and the name of the mock is written as a snapshot\\n  expect(mockFunc).toMatchSnapshot();\\n});\\n\\ntest(\\\"common matchers\\\", () => {\\n  const mockFunc = jest.fn().mockName(\\\"a mock name\\\");\\n\\n  const arg1 = 42;\\n  const arg2 = \\\"arg2\\\";\\n\\n  mockFunc(arg1, arg2);\\n\\n  // The mock function was called at least once\\n  expect(mockFunc.mock.calls.length).toBeGreaterThan(0);\\n\\n  // The mock function was called at least once with the specified args\\n  expect(mockFunc.mock.calls).toContainEqual([arg1, arg2]);\\n\\n  // The last call to the mock function was called with the specified args\\n  expect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1]).toEqual([\\n    arg1,\\n    arg2\\n  ]);\\n\\n  // The first arg of the last call to the mock function was '42'\\n  // (note that there is no sugar helper for this specific of an assertion)\\n  expect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1][0]).toBe(42);\\n\\n  // A snapshot will check that a mock was invoked the same number of times,\\n  // in the same order, with the same arguments. It will also assert on the name.\\n  expect(mockFunc.mock.calls).toEqual([[arg1, arg2]]);\\n  expect(mockFunc.getMockName()).toBe(\\\"a mock name\\\");\\n});\\n\".trim();var login=\"\\nimport React from 'react';\\nimport { render, cleanup, fireEvent, wait, getByPlaceholderText } from '@testing-library/react';\\nimport '@testing-library/jest-dom/extend-expect';\\nimport { shallow, configure, mount, simulate } from 'enzyme';\\nimport Adapter from 'enzyme-adapter-react-16';\\nimport renderer from \\\"react-test-renderer\\\";\\nimport Login from '../../App/Login';\\n\\n// https://www.apollographql.com/docs/react/recipes/testing/\\n\\n\\nafterEach(cleanup);\\n\\nconfigure({ adapter: new Adapter() });\\n  let wrapper = shallow(<Login />);\\n  \\nlet location = {\\n  href: '/login',\\n};\\n\\ndescribe('Render the login page',() =>{\\nit('shows the login page', () => {\\n  const asFragment = renderer.create(<Login />).toJSON();\\n  expect(asFragment).toMatchSnapshot();\\n  });\\n})\\n\\n// it('logs in as admin', async () => {\\n//   let setSession = (param) => {\\n//     window.localStorage.setItem('graphql_session', JSON.stringify(param));\\n//   };\\n//   const { getByLabelText, getByText, getByPlaceholderText } = render(\\n//     <Login location={location} setSession={setSession} />\\n//   );\\n//   })\\n  \\n  // fill out the form\\n  it('check username', () => {\\n  fireEvent.change(getByPlaceholderText(/Email/i), {\\n    target: { name: 'username', value: 'andre@nivoda.net' },\\n  });\\n  expect(wrapper.state('username')).toEqual('andre@nivoda.net');\\n})\\n\\n  it('check user password', () => {\\n  fireEvent.change(getByPlaceholderText(/Password/i), {\\n    target: { name: 'password', value: 'test' },\\n  });\\n  expect(wrapper.state('password')).toEqual('test');\\n})\\n\\n/* NOTE: Test needed for error handling case where if users don't enter anything, error \\nmessage is present on the screen.\\nlogin check with right data\\n*/\\ntest('login check with right data',()=>{\\n  wrapper = shallow(<Login/>);\\n  wrapper.find('input[type=\\\"text\\\"]').simulate('change', {target: {\\n    name: 'username', value: 'andre@nivoda.net'}\\n  });\\n  \\n  wrapper.find('input[type=\\\"password\\\"]').simulate('change', {\\n    target: {name: 'password', value: 'test'}\\n  });\\n  \\n  wrapper.find('button').simulate('click');\\n  expect(wrapper.state('isLogined')).toBe(true);\\n  /* Also, check if the function is being called\\n   on submit check if loader present on the screen\\n  */\\n  })\\n  \\n//login check with wrong data\\n/* \\n message - username of passwrod not correct (error: this.setState({\\\"error_msg\\\":\\\"not correct\\\"}))\\n user entered wrong username of password - UI-> check if error message is present on th the Ui\\n*/\\n test('login check with wrong data',()=>{\\n  wrapper = shallow(<Login/>);\\n  wrapper.find('input[type=\\\"text\\\"]').simulate('change', {\\n    target: {name: 'username', value: 'andre@nivoda123.net'}\\n  });\\n  // console.log(wrapper.debug())\\n  \\n  wrapper.find('input[type=\\\"password\\\"]').simulate('change', {\\n    target: {name: 'password', value: 'test123'}\\n  });\\n  \\n    wrapper.find('button').simulate('click');\\n    expect(wrapper.state('isLogined')).toBe(false);\\n  })\\n\\n  it('click login button', () => {\\n    const { getByLabelText } = render(<Login location={location} />);\\n  fireEvent.click(getByLabelText(/login-button/i));\\n  wrapper.find('button').simulate('click');\\n  expect(wrapper.state('isLogined')).toBe();\\n})\\n  // await wait(() => getByText(/admin/i));\\n\\n  // expect(getByText(/admin/i).textContent).toMatchSnapshot();\\n  // let session = window.localStorage.getItem('graphql_session');\\n  // expect(session).toMatchSnapshot();\\n\".trim();var Matchers=/*#__PURE__*/function(_Component){_inherits(Matchers,_Component);function Matchers(){_classCallCheck(this,Matchers);return _possibleConstructorReturn(this,_getPrototypeOf(Matchers).apply(this,arguments));}_createClass(Matchers,[{key:\"componentDidMount\",value:function componentDidMount(){setTimeout(function(){return Prism.highlightAll();},0);}},{key:\"render\",value:function render(){var classes=this.props.classes;return React.createElement(Grid,{container:true},React.createElement(Grid,{item:true,xs:2},React.createElement(Paper,{className:classes.paper},React.createElement(\"h4\",null,React.createElement(Sidebar,null)))),React.createElement(Grid,{item:true,xs:10},React.createElement(Paper,{className:classes.paper},React.createElement(List,null,React.createElement(\"h3\",null,\"Matchers\"),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:matchers,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"3-testing-asynchronous-code\"),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:asynchronous,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"4-setup-and-teardown\"),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:teardown,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"5-mock-functions\"),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:mocks,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"Login\"),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:login,language:\"js\",plugins:[\"line-numbers\"]}))))));}}]);return Matchers;}(Component);export default withStyles(styles)(Matchers);","map":{"version":3,"sources":["/home/mukeshs/Projects/edurights/src/components/css/matchers.js"],"names":["React","Component","Prism","Grid","Paper","withStyles","List","Sidebar","PrismCode","titles","backgroundColor","padding","fontSize","styles","theme","paper","margin","spacing","smMargin","actionDiv","textAlign","matchers","trim","asynchronous","teardown","mocks","login","Matchers","setTimeout","highlightAll","classes","props"],"mappings":"6kBAAA,MAAOA,CAAAA,KAAP,EAAgBC,SAAhB,KAAiC,OAAjC,CACA,MAAOC,CAAAA,KAAP,KAAkB,SAAlB,CACA,OAASC,IAAT,CAAeC,KAAf,CAAsBC,UAAtB,CAAkCC,IAAlC,KAA8C,mBAA9C,CAEA,MAAO,uBAAP,CACA,MAAOC,CAAAA,OAAP,KAAoB,WAApB,CACA,MAAOC,CAAAA,SAAP,KAAsB,sBAAtB,CAGA,GAAMC,CAAAA,MAAM,CAAG,CAACC,eAAe,CAAC,SAAjB,CAA4BC,OAAO,CAAC,KAApC,CAA2CC,QAAQ,CAAC,MAApD,CAAf,CAEA,GAAMC,CAAAA,MAAM,CAAG,QAATA,CAAAA,MAAS,CAAAC,KAAK,QAAK,CACvBC,KAAK,CAAE,CACHC,MAAM,CAAEF,KAAK,CAACG,OAAN,CAAc,CAAd,CADL,CAEHN,OAAO,CAAEG,KAAK,CAACG,OAAN,CAAc,CAAd,CAFN,CADgB,CAKvBC,QAAQ,CAAE,CACNF,MAAM,CAAEF,KAAK,CAACG,OAAN,CAAc,CAAd,CADF,CALa,CAQvBE,SAAS,CAAE,CACPC,SAAS,CAAE,QADJ,CARY,CAAL,EAApB,CAcA,GAAMC,CAAAA,QAAQ,CAAG,iwEAgGfC,IAhGe,EAAjB,CAkGA,GAAMC,CAAAA,YAAY,CAAG,smEA2FnBD,IA3FmB,EAArB,CA6FA,GAAME,CAAAA,QAAQ,CAAG,y1BA6CfF,IA7Ce,EAAjB,CA+CA,GAAMG,CAAAA,KAAK,CAAG,w1KA4LZH,IA5LY,EAAd,CA8LA,GAAMI,CAAAA,KAAK,CAAG,k4GAwGZJ,IAxGY,EAAd,C,GA2GMK,CAAAA,Q,gSACgB,CAClBC,UAAU,CAAC,iBAAM1B,CAAAA,KAAK,CAAC2B,YAAN,EAAN,EAAD,CAA6B,CAA7B,CAAV,CACD,C,uCACQ,IACCC,CAAAA,OADD,CACa,KAAKC,KADlB,CACCD,OADD,CAEP,MACE,qBAAC,IAAD,EAAM,SAAS,KAAf,EACM,oBAAC,IAAD,EAAM,IAAI,KAAV,CAAW,EAAE,CAAE,CAAf,EACI,oBAAC,KAAD,EAAO,SAAS,CAAEA,OAAO,CAACf,KAA1B,EACI,8BAAI,oBAAC,OAAD,MAAJ,CADJ,CADJ,CADN,CAMF,oBAAC,IAAD,EAAM,IAAI,KAAV,CAAW,EAAE,CAAE,EAAf,EACA,oBAAC,KAAD,EAAO,SAAS,CAAEe,OAAO,CAACf,KAA1B,EACA,oBAAC,IAAD,MACE,yCADF,CAEE,2BAAK,KAAK,CAAEN,MAAZ,EACA,oBAAC,SAAD,EACE,IAAI,CAAEY,QADR,CAEE,QAAQ,CAAC,IAFX,CAGE,OAAO,CAAE,CAAC,cAAD,CAHX,EADA,CAFF,CASE,8BATF,CAWE,4DAXF,CAYE,2BAAK,KAAK,CAAEZ,MAAZ,EACA,oBAAC,SAAD,EACE,IAAI,CAAEc,YADR,CAEE,QAAQ,CAAC,IAFX,CAGE,OAAO,CAAE,CAAC,cAAD,CAHX,EADA,CAZF,CAmBE,8BAnBF,CAqBE,qDArBF,CAsBE,2BAAK,KAAK,CAAEd,MAAZ,EACA,oBAAC,SAAD,EACE,IAAI,CAAEe,QADR,CAEE,QAAQ,CAAC,IAFX,CAGE,OAAO,CAAE,CAAC,cAAD,CAHX,EADA,CAtBF,CA6BE,8BA7BF,CA+BE,iDA/BF,CAgCE,2BAAK,KAAK,CAAEf,MAAZ,EACA,oBAAC,SAAD,EACE,IAAI,CAAEgB,KADR,CAEE,QAAQ,CAAC,IAFX,CAGE,OAAO,CAAE,CAAC,cAAD,CAHX,EADA,CAhCF,CAuCE,8BAvCF,CAyCE,sCAzCF,CA0CE,2BAAK,KAAK,CAAEhB,MAAZ,EACA,oBAAC,SAAD,EACE,IAAI,CAAEiB,KADR,CAEE,QAAQ,CAAC,IAFX,CAGE,OAAO,CAAE,CAAC,cAAD,CAHX,EADA,CA1CF,CADA,CADA,CANE,CADF,CA+DD,C,sBArEoBzB,S,EAwEvB,cAAgBI,CAAAA,UAAU,CAACQ,MAAD,CAAV,CAAmBc,QAAnB,CAAhB","sourcesContent":["import React, { Component } from 'react';\nimport Prism from \"prismjs\"\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\n\nimport '../ReactJs/styles.css'\nimport Sidebar from './sidebar';\nimport PrismCode from '../ReactJs/prismCode';\n\n\nconst titles = {backgroundColor:'#F0F8FF', padding:'1px', fontSize:'16px'}\n\nconst styles = theme => ({\n  paper: {\n      margin: theme.spacing(1),\n      padding: theme.spacing(1)\n  },\n  smMargin: {\n      margin: theme.spacing(1)\n  },\n  actionDiv: {\n      textAlign: \"center\"\n  }\n})\n\n\nconst matchers = `\ntest(\"two plus two is four\", () => {\n  expect(2 + 2).toBe(4);\n});\n\ntest(\"object assignment\", () => {\n  const data = { one: 1 };\n  data[\"two\"] = 2;\n  expect(data).toEqual({ one: 1, two: 2 });\n});\n\ntest(\"array assignment\", () => {\n  const data = [1];\n  data.push(2);\n  expect(data).toEqual([1, 2]);\n});\n\ntest(\"adding positive numbers is not zero\", () => {\n  for (let a = 1; a < 10; a++) {\n    for (let b = 1; b < 10; b++) {\n      expect(a + b).not.toBe(0);\n    }\n  }\n});\n\ntest(\"null\", () => {\n  const n = null;\n  expect(n).toBeNull();\n  expect(n).toBeDefined();\n  expect(n).not.toBeUndefined();\n  expect(n).not.toBeTruthy();\n  expect(n).toBeFalsy();\n});\n\ntest(\"zero\", () => {\n  const z = 0;\n  expect(z).not.toBeNull();\n  expect(z).toBeDefined();\n  expect(z).not.toBeUndefined();\n  expect(z).not.toBeTruthy();\n  expect(z).toBeFalsy();\n});\n\ntest(\"two plus two\", () => {\n  const value = 2 + 2;\n  expect(value).toBeGreaterThan(3);\n  expect(value).toBeGreaterThanOrEqual(3.5);\n  expect(value).toBeLessThan(5);\n  expect(value).toBeLessThanOrEqual(4.5);\n\n  // toBe and toEqual are equivalent for numbers\n  expect(value).toBe(4);\n  expect(value).toEqual(4);\n});\n\ntest(\"adding floating point numbers\", () => {\n  const value = 0.1 + 0.2;\n  // expect(value).toBe(0.3);\n  expect(value).toBeCloseTo(0.3);\n});\n\ntest(\"there is no I in team\", () => {\n  expect(\"team\").not.toMatch(/I/);\n});\n\ntest('but there is a \"stop\" in Christoph', () => {\n  expect(\"Christoph\").toMatch(/stop/);\n});\n\nconst shoppingList = [\n  \"diapers\",\n  \"kleenex\",\n  \"trash bags\",\n  \"paper towels\",\n  \"beer\"\n];\n\ntest(\"the shopping list has beer on it\", () => {\n  expect(shoppingList).toContain(\"beer\");\n  expect(new Set(shoppingList)).toContain(\"beer\");\n});\n\nclass ConfigError extends Error {}\n\nfunction compileAndroidCode() {\n  throw new ConfigError(\"you are using the wrong JDK\");\n}\n\ntest(\"compiling android goes as expected\", () => {\n  expect(compileAndroidCode).toThrow();\n  expect(compileAndroidCode).toThrow(ConfigError);\n\n  // You can also use the exact error message or a regexp\n  expect(compileAndroidCode).toThrow(\"you are using the wrong JDK\");\n  expect(compileAndroidCode).toThrow(/JDK/);\n});\n`.trim();\n\nconst asynchronous = `\nfunction fetchData(callback) {\n  setTimeout(() => {\n    callback(\"peanut butter\");\n  }, 100);\n}\n\nfunction fetchDataPromise() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(\"peanut butter\");\n    }, 100);\n  });\n}\n\nfunction fetchDataPromiseWithErrorMessage() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      reject(\"error\");\n    }, 100);\n  });\n}\n\nfunction fetchDataPromiseWithError() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      reject(new Error(\"error\"));\n    }, 100);\n  });\n}\n\n// Don't do this!\n// test(\"the data is peanut butter\", () => {\n//   function callback(data) {\n//     expect(data).toBe(\"peanut butter\");\n//   }\n\n//   fetchData(callback);\n// });\n\ntest(\"the data is peanut butter\", (done) => {\n  function callback(data) {\n    expect(data).toBe(\"peanut butter\");\n    done();\n  }\n\n  fetchData(callback);\n});\n\ntest(\"the data is peanut butter\", () => {\n  return fetchDataPromise().then(data => {\n    expect(data).toBe(\"peanut butter\");\n  });\n});\n\ntest(\"the fetch fails with an error\", () => {\n  expect.assertions(1);\n  return fetchDataPromiseWithErrorMessage().catch(e =>\n    expect(e).toMatch(\"error\")\n  );\n});\n\ntest(\"the data is peanut butter\", () => {\n  return expect(fetchDataPromise()).resolves.toBe(\"peanut butter\");\n});\n\ntest(\"the fetch fails with an error\", () => {\n  return expect(fetchDataPromiseWithErrorMessage()).rejects.toMatch(\"error\");\n});\n\ntest(\"the data is peanut butter\", async () => {\n  const data = await fetchDataPromise();\n  expect(data).toBe(\"peanut butter\");\n});\n\ntest(\"the fetch fails with an error\", async () => {\n  expect.assertions(1);\n  try {\n    await fetchDataPromiseWithErrorMessage();\n  } catch (e) {\n    expect(e).toMatch(\"error\");\n  }\n});\n\ntest(\"the data is peanut butter\", async () => {\n  await expect(fetchDataPromise()).resolves.toBe(\"peanut butter\");\n});\n\ntest(\"the fetch fails with an error\", async () => {\n  await expect(fetchDataPromiseWithError()).rejects.toThrow(\"error\");\n});\n`.trim();\n\nconst teardown = `\nlet cities = [];\n\nfunction initializeCityDatabase() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      cities.push(\"Vienna\");\n      cities.push(\"San Juan\");\n      resolve();\n    }, 100);\n  });\n}\n\nfunction clearCityDatabase() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      cities = [];\n      resolve();\n    }, 100);\n  });\n}\n\nfunction isCity(name) {\n  return cities.includes(name);\n}\n\nbeforeAll(() => {\n  return initializeCityDatabase();\n});\n\nafterAll(() => {\n  return clearCityDatabase();\n});\n\ntest(\"city database has Vienna\", () => {\n  expect(isCity(\"Vienna\")).toBeTruthy();\n});\n\ntest(\"city database has San Juan\", () => {\n  expect(isCity(\"San Juan\")).toBeTruthy();\n});\n\ntest(\"has only 2 cities\", () => {\n  expect(cities.length).toBe(2);\n});\n`.trim();\n\nconst mocks = `\nfunction forEach(items, callback) {\n  for (let index = 0; index < items.length; index++) {\n    callback(items[index]);\n  }\n}\n\ntest(\"mockFunctions\", () => {\n  const mockCallback = jest.fn(x => 42 + x);\n  forEach([0, 1], mockCallback);\n\n  // The mock function is called twice\n  expect(mockCallback.mock.calls.length).toBe(2);\n\n  // The first argument of the first call to the function was 0\n  expect(mockCallback.mock.calls[0][0]).toBe(0);\n\n  // The first argument of the second call to the function was 1\n  expect(mockCallback.mock.calls[1][0]).toBe(1);\n\n  // The return value of the first call to the function was 42\n  expect(mockCallback.mock.results[0].value).toBe(42);\n});\n\ntest(\"this\", () => {\n  const myMock = jest.fn();\n\n  const a = new myMock();\n  a.name = \"a\";\n  const b = {};\n  b.name = \"b\";\n  const bound = myMock.bind(b);\n  bound();\n\n  console.log(myMock.mock.instances);\n  // > [ <a>, <b> ]\n});\n\ntest(\"someMockFunction\", () => {\n  const someMockFunction = jest.fn(() => \"return value\");\n\n  someMockFunction(\"first arg\", \"second arg\");\n\n  // The function was called exactly once\n  expect(someMockFunction.mock.calls.length).toBe(1);\n\n  // The first arg of the first call to the function was 'first arg'\n  expect(someMockFunction.mock.calls[0][0]).toBe(\"first arg\");\n\n  // The second arg of the first call to the function was 'second arg'\n  expect(someMockFunction.mock.calls[0][1]).toBe(\"second arg\");\n\n  // The return value of the first call to the function was 'return value'\n  expect(someMockFunction.mock.results[0].value).toBe(\"return value\");\n\n  const SomeMockConstructor = jest.fn();\n  const a = new SomeMockConstructor();\n  a.name = \"test\";\n  const b = new SomeMockConstructor();\n\n  // This function was instantiated exactly twice\n  expect(SomeMockConstructor.mock.instances.length).toBe(2);\n\n  // The object returned by the first instantiation of this function\n  // had a 'name' property whose value was set to 'test'\n  expect(SomeMockConstructor.mock.instances[0].name).toEqual(\"test\");\n});\n\ntest(\"mockReturnValueOnce\", () => {\n  const myMock = jest.fn();\n  console.log(myMock());\n  // > undefined\n\n  myMock\n    .mockReturnValue(true)\n    .mockReturnValueOnce(10)\n    .mockReturnValueOnce(\"x\");\n\n  console.log(myMock(), myMock(), myMock(), myMock());\n});\n\ntest(\"filterTest\", () => {\n  const filterTestFn = jest.fn();\n\n  // Make the mock return 'true' for the first call, and 'false' for the second call\n  filterTestFn.mockReturnValueOnce(true).mockReturnValueOnce(false);\n\n  const result = [11, 12].filter(filterTestFn);\n\n  console.log(result);\n  // > [11]\n  console.log(filterTestFn.mock.calls);\n  // > [ [11], [12] ]\n});\n\ntest(\"mockImplementation\", () => {\n  const myMockFn = jest.fn(cb => cb(null, true));\n\n  myMockFn((err, val) => console.log(val));\n  // > true\n});\n\ntest(\"mockImplementationOnce\", () => {\n  const myMockFn = jest\n    .fn(() => \"default\")\n    .mockImplementationOnce(() => \"first call\")\n    .mockImplementationOnce(() => \"second call\");\n\n  console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());\n  // > 'first call', 'second call', 'default', 'default'\n});\n\ntest(\"return this\", () => {\n  const myObj = {\n    myMethod: jest.fn().mockReturnThis()\n  };\n\n  // is the same as\n  const otherObj = {\n    myMethod: jest.fn(function() {\n      return this;\n    })\n  };\n\n  console.log(myObj.myMethod());\n  console.log(otherObj.myMethod());\n});\n\ntest(\"mockName\", () => {\n  const myMockFn = jest\n    .fn()\n    .mockReturnValue(\"default\")\n    .mockImplementation(scalar => 42 + scalar)\n    .mockName(\"add42\");\n\n  // expect(myMockFn).toBeCalled();\n});\n\ntest(\"custom matchers\", () => {\n  const mockFunc = jest.fn();\n\n  const arg1 = \"arg1\";\n  const arg2 = \"arg2\";\n\n  mockFunc(arg1, arg2);\n\n  // The mock function was called at least once\n  expect(mockFunc).toBeCalled();\n\n  // The mock function was called at least once with the specified args\n  expect(mockFunc).toBeCalledWith(arg1, arg2);\n\n  // The last call to the mock function was called with the specified args\n  expect(mockFunc).lastCalledWith(arg1, arg2);\n\n  // All calls and the name of the mock is written as a snapshot\n  expect(mockFunc).toMatchSnapshot();\n});\n\ntest(\"common matchers\", () => {\n  const mockFunc = jest.fn().mockName(\"a mock name\");\n\n  const arg1 = 42;\n  const arg2 = \"arg2\";\n\n  mockFunc(arg1, arg2);\n\n  // The mock function was called at least once\n  expect(mockFunc.mock.calls.length).toBeGreaterThan(0);\n\n  // The mock function was called at least once with the specified args\n  expect(mockFunc.mock.calls).toContainEqual([arg1, arg2]);\n\n  // The last call to the mock function was called with the specified args\n  expect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1]).toEqual([\n    arg1,\n    arg2\n  ]);\n\n  // The first arg of the last call to the mock function was '42'\n  // (note that there is no sugar helper for this specific of an assertion)\n  expect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1][0]).toBe(42);\n\n  // A snapshot will check that a mock was invoked the same number of times,\n  // in the same order, with the same arguments. It will also assert on the name.\n  expect(mockFunc.mock.calls).toEqual([[arg1, arg2]]);\n  expect(mockFunc.getMockName()).toBe(\"a mock name\");\n});\n`.trim();\n\nconst login = `\nimport React from 'react';\nimport { render, cleanup, fireEvent, wait, getByPlaceholderText } from '@testing-library/react';\nimport '@testing-library/jest-dom/extend-expect';\nimport { shallow, configure, mount, simulate } from 'enzyme';\nimport Adapter from 'enzyme-adapter-react-16';\nimport renderer from \"react-test-renderer\";\nimport Login from '../../App/Login';\n\n// https://www.apollographql.com/docs/react/recipes/testing/\n\n\nafterEach(cleanup);\n\nconfigure({ adapter: new Adapter() });\n  let wrapper = shallow(<Login />);\n  \nlet location = {\n  href: '/login',\n};\n\ndescribe('Render the login page',() =>{\nit('shows the login page', () => {\n  const asFragment = renderer.create(<Login />).toJSON();\n  expect(asFragment).toMatchSnapshot();\n  });\n})\n\n// it('logs in as admin', async () => {\n//   let setSession = (param) => {\n//     window.localStorage.setItem('graphql_session', JSON.stringify(param));\n//   };\n//   const { getByLabelText, getByText, getByPlaceholderText } = render(\n//     <Login location={location} setSession={setSession} />\n//   );\n//   })\n  \n  // fill out the form\n  it('check username', () => {\n  fireEvent.change(getByPlaceholderText(/Email/i), {\n    target: { name: 'username', value: 'andre@nivoda.net' },\n  });\n  expect(wrapper.state('username')).toEqual('andre@nivoda.net');\n})\n\n  it('check user password', () => {\n  fireEvent.change(getByPlaceholderText(/Password/i), {\n    target: { name: 'password', value: 'test' },\n  });\n  expect(wrapper.state('password')).toEqual('test');\n})\n\n/* NOTE: Test needed for error handling case where if users don't enter anything, error \nmessage is present on the screen.\nlogin check with right data\n*/\ntest('login check with right data',()=>{\n  wrapper = shallow(<Login/>);\n  wrapper.find('input[type=\"text\"]').simulate('change', {target: {\n    name: 'username', value: 'andre@nivoda.net'}\n  });\n  \n  wrapper.find('input[type=\"password\"]').simulate('change', {\n    target: {name: 'password', value: 'test'}\n  });\n  \n  wrapper.find('button').simulate('click');\n  expect(wrapper.state('isLogined')).toBe(true);\n  /* Also, check if the function is being called\n   on submit check if loader present on the screen\n  */\n  })\n  \n//login check with wrong data\n/* \n message - username of passwrod not correct (error: this.setState({\"error_msg\":\"not correct\"}))\n user entered wrong username of password - UI-> check if error message is present on th the Ui\n*/\n test('login check with wrong data',()=>{\n  wrapper = shallow(<Login/>);\n  wrapper.find('input[type=\"text\"]').simulate('change', {\n    target: {name: 'username', value: 'andre@nivoda123.net'}\n  });\n  // console.log(wrapper.debug())\n  \n  wrapper.find('input[type=\"password\"]').simulate('change', {\n    target: {name: 'password', value: 'test123'}\n  });\n  \n    wrapper.find('button').simulate('click');\n    expect(wrapper.state('isLogined')).toBe(false);\n  })\n\n  it('click login button', () => {\n    const { getByLabelText } = render(<Login location={location} />);\n  fireEvent.click(getByLabelText(/login-button/i));\n  wrapper.find('button').simulate('click');\n  expect(wrapper.state('isLogined')).toBe();\n})\n  // await wait(() => getByText(/admin/i));\n\n  // expect(getByText(/admin/i).textContent).toMatchSnapshot();\n  // let session = window.localStorage.getItem('graphql_session');\n  // expect(session).toMatchSnapshot();\n`.trim();\n\n\nclass Matchers extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0)\n  }\n  render() {\n    const { classes } = this.props;\n    return (\n      <Grid container>\n            <Grid item xs={2}>\n                <Paper className={classes.paper}>\n                    <h4><Sidebar /></h4>\n                </Paper>\n            </Grid>\n    <Grid item xs={10}>\n    <Paper className={classes.paper}>\n    <List>\n      <h3>Matchers</h3>\n      <div style={titles}>\n      <PrismCode\n        code={matchers}\n        language=\"js\"\n        plugins={[\"line-numbers\"]}\n      />\n      </div>\n      <br/>\n      \n      <h3>3-testing-asynchronous-code</h3>\n      <div style={titles}>\n      <PrismCode\n        code={asynchronous}\n        language=\"js\"\n        plugins={[\"line-numbers\"]}\n      />\n      </div>\n      <br/>\n      \n      <h3>4-setup-and-teardown</h3>\n      <div style={titles}>\n      <PrismCode\n        code={teardown}\n        language=\"js\"\n        plugins={[\"line-numbers\"]}\n      />\n      </div>\n      <br/>\n      \n      <h3>5-mock-functions</h3>\n      <div style={titles}>\n      <PrismCode\n        code={mocks}\n        language=\"js\"\n        plugins={[\"line-numbers\"]}\n      />\n      </div>\n      <br/>\n      \n      <h3>Login</h3>\n      <div style={titles}>\n      <PrismCode\n        code={login}\n        language=\"js\"\n        plugins={[\"line-numbers\"]}\n      />\n      </div>\n      </List>\n      </Paper>\n      </Grid>\n      </Grid>\n    )\n  }\n}\n\nexport default (withStyles(styles)(Matchers));\n"]},"metadata":{},"sourceType":"module"}