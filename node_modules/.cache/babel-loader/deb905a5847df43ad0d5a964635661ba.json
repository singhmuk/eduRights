{"ast":null,"code":"import _classCallCheck from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/createClass\";import _possibleConstructorReturn from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";import _getPrototypeOf from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";import _inherits from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/inherits\";import React,{Component}from'react';import Prism from\"prismjs\";import{Grid,Paper,withStyles,List}from\"@material-ui/core\";import'../../ReactJs/styles.css';import Sidebar from'../sidebar';import PrismCode from'../../ReactJs/prismCode';import LinkedList from'../../../assets/linkedList.png';import Theata from'../../../assets/theta.png';import Big_O from'../../../assets/big_O.png';import Omega from'../../../assets/omega.png';import DeadLocks from'../../../assets/deadlock.png';import divudeconquers from'../../../assets/divide_conquer.png';import dis from'../../../assets/dijkastra.jpg';import di from'../../../assets/di.png';import greedy from'../../../assets/greedy.png';import search from'../../../assets/search.png';var titles={backgroundColor:'#F0F8FF',padding:'1px',fontSize:'16px'};var redesign={height:200,width:500};var styles=function styles(theme){return{paper:{margin:theme.spacing(1),padding:theme.spacing(1)},smMargin:{margin:theme.spacing(1)},actionDiv:{textAlign:\"center\"}};};var code=\"\\n\".trim();var IntroAlgo=/*#__PURE__*/function(_Component){_inherits(IntroAlgo,_Component);function IntroAlgo(){_classCallCheck(this,IntroAlgo);return _possibleConstructorReturn(this,_getPrototypeOf(IntroAlgo).apply(this,arguments));}_createClass(IntroAlgo,[{key:\"componentDidMount\",value:function componentDidMount(){setTimeout(function(){return Prism.highlightAll();},0);}},{key:\"render\",value:function render(){var classes=this.props.classes;return React.createElement(Grid,{container:true},React.createElement(Grid,{item:true,xs:2},React.createElement(Paper,{className:classes.paper},React.createElement(\"h4\",null,React.createElement(Sidebar,null)))),React.createElement(Grid,{item:true,xs:10},React.createElement(Paper,{className:classes.paper},React.createElement(List,null,React.createElement(\"h3\",null,\"1.How to find middle element of linked list in one pass?\"),React.createElement(\"img\",{src:LinkedList,alt:\"DeadLock\",className:\"responsive\",style:redesign}),React.createElement(\"p\",null,\"We need to maintain two-pointer, one increment at each node while other increments after two nodes at a time, when the first pointer reaches the end, the second pointer will point to a middle element of the linked list.\"),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"2.How to find if a linked list has a loop?\"),React.createElement(\"p\",null,\"If we maintain two pointers, and we increment one pointer after processing two nodes and other after processing every node, we will find a situation where both pointers will pointing to the same node. This happen if a linked list has a loop/ cycle.\"),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"3. What is the difference between the Singly Linked List and Doubly Linked List data structure?\"),React.createElement(\"p\",null,\"The main difference is the ability to traverse.\",React.createElement(\"ol\",null,React.createElement(\"li\",null,\"In a singly linked list, a node only points towards the next node, and there is no pointer to the previous node, So, can not traverse back on a singly linked list.\"),React.createElement(\"li\",null,\"On the other hand, the doubly linked list maintains two pointers, towards the next and previous node, which allows to navigate in both directions in linked list.\"))),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"4.Generally data structure types?\"),React.createElement(\"p\",null,\"At a high level, there are basically three types of data structures.\",React.createElement(\"ol\",null,React.createElement(\"li\",null,React.createElement(\"b\",null,\"Stacks and Queues: \"),\"Array-like structures that differ only in how items are inserted and removed.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Linked Lists, Trees, and Graphs:\"),\"Structures with nodes that keep references to other nodes.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Hash Tables: \"),\"Depend on hash functions to save and locate data.\")),React.createElement(\"br\",null),\"In terms of complexity, Stacks and Queues are the simplest and can be constructed from Linked Lists.\",React.createElement(\"br\",null),\"Trees and Graphs are the most complex because they extend the concept of a linked list. Hash Tables need to utilize these data structures to perform reliably.\",React.createElement(\"br\",null),React.createElement(\"br\",null),\"In terms of efficiency, Linked Lists are most optimal for recording and storing of data, while Hash Tables are most performant for searching and retrieving of data.\"),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"5. What is Divide and Conquer algorithms?\"),React.createElement(\"p\",null,\"Divide and Conquer is a pattern for algorithm. It is designed in a way as to take dispute on a huge input, break the input into minor pieces, and decide the problem for each of the small pieces. Now merge all of the piecewise solutions into a global solution.\",React.createElement(\"br\",null),React.createElement(\"ol\",null,React.createElement(\"li\",null,React.createElement(\"b\",null,\"Divide: \"),\"Algorithm divides the original problem into a set of subproblems.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Conquer: \"),\"Algorithm solves every subproblem individually.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Combine: \"),\"TAlgorithm puts together the solutions of the subproblems to get the solution of whole problem.\")),React.createElement(\"b\",null,\"Ex. \"),\"Merge Sort, Quick Sort, Binary Search, Strassen's Matrix Multiplication, Closest pair.\"),React.createElement(\"img\",{src:divudeconquers,alt:\"DeadLock\",className:\"responsive\",style:redesign}),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"6.What is Dijkstra's shortest path algorithm?\"),React.createElement(\"img\",{src:di,alt:\"DeadLock\",className:\"responsive\",style:redesign}),React.createElement(\"img\",{src:dis,alt:\"DeadLock\",className:\"responsive\",style:redesign}),React.createElement(\"p\",null,React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Dijkstra's algorithm is an algorithm for finding the shortest path from a starting node to the target node in a weighted graph. \"),React.createElement(\"li\",null,\"Algorithm makes a tree of shortest paths from the starting vertex/ source vertex to all other nodes in the graph.\")),React.createElement(\"br\",null),\"Suppose you want to go from home to office in the shortest possible way. You know some roads are heavily congested (large weight) and challenging to use this,. In Dijkstra's algorithm, the shortest path tree found by the algorithm will try to avoid edges with larger weights.\"),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"7. What are Greedy algorithms?\"),React.createElement(\"img\",{src:greedy,alt:\"DeadLock\",className:\"responsive\",style:redesign}),React.createElement(\"p\",null,\"A greedy algorithm made for the best optimal choice at each sub stage with the goal of teventually leading to a globally optimum solution. This means that the algorithm chooses the best solution at the moment without regard for consequences.\",React.createElement(\"br\",null),React.createElement(\"br\",null),\"In other words, an algorithm that always takes the best immediate, or local, solution while finding an answer. Greedy algorithms find the overall, ideal solution for some idealistic problems, but may discover less-than-ideal solutions for some instances of other problems.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Ex. \"),\"Travelling Salesman Problem, Prim's Minimal Spanning Tree Algorithm, Kruskal's Minimal Spanning Tree Algorithm, Dijkstra's Minimal Spanning Tree Algorithm, Graph - Map Coloring, Graph - Vertex Cover, Knapsack Problem, Job Scheduling Problem,\"),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"8. What is a linear search?\"),React.createElement(\"img\",{src:search,alt:\"DeadLock\",className:\"responsive\",style:redesign}),React.createElement(\"p\",null,\"Technique of traversing a list from start to end by visiting properties of all the elements that are found on the way.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"ul\",null,React.createElement(\"li\",null,React.createElement(\"b\",null,\"Step1:  \"),\"Traverse the array using for loop.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Step2: \"),\"In every iteration, compare the target value with the current value of the array.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Step3: \"),\"If the values match, return the current index of the array\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Step4: \"),\"If the values do not match, shift on to the next array element.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Step5: \"),\"If no match is found, return -1.\"))),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"9. Asymptotic Notations\"),\"Asymptotic analysis is used to measure the efficiency of an algorithm that doesn't depend on machine-specific constants and prevents the algorithm from comparing the time taking algorithm. Asymptotic notation is a mathematical tool that is used to represent the time complexity of algorithms for asymptotic analysis.\",React.createElement(\"br\",null),React.createElement(\"br\",null),\"The three most used asymptotic notation is as follows.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"\\u03B8 Notation:\"),React.createElement(\"br\",null),\"\\u03B8 Notation defines exact asymptotic behavior. It bounds functions from above and below. A convenient way to get Theta notation of an expression is to drop low order terms and ignore leading constants.\",React.createElement(\"br\",null),React.createElement(\"img\",{src:Theata,alt:\"Theata\",className:\"responsive2\",style:redesign}),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Big O Notation:\"),React.createElement(\"br\",null),\"The Big O notation bounds a function from above, it defines an upper bound of an algorithm. Let's consider the case of insertion sort, it takes linear time in the best case and quadratic time in the worst case. The time complexity of insertion sort is O(n2). It is useful when we only have upper bound on time complexity of an algorithm.\",React.createElement(\"br\",null),React.createElement(\"img\",{src:Big_O,alt:\"Big O\",className:\"responsive\",style:redesign}),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"\\u03A9 Notation:\"),React.createElement(\"br\",null),\"Just like Big O notation provides an asymptotic upper bound, the \\u03A9 Notation provides an asymptotic lower bound on a function. It is useful when we have lower bound on time complexity of an algorithm.\",React.createElement(\"br\",null),React.createElement(\"img\",{src:Omega,alt:\"Omega\",className:\"responsive\",style:redesign}),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"10. Deadlock in Operating System\"),\"A process in operating systems uses different resources and uses resources in following way.\",React.createElement(\"br\",null),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"1) Requests a resource\"),React.createElement(\"li\",null,\"2) Use the resource\"),React.createElement(\"li\",null,\"2) Releases the resource\")),React.createElement(\"br\",null),\"Deadlock is a situation where a set of processes are blocked because each process is holding a resource and waiting for another resource acquired by some other process.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Ex. \"),\"When two trains are coming toward each other on same track and there is only one track, none of the trains can move once they are in front of each other. Similar situation occurs in operating systems when there are two/ more processes hold some resources and wait for resources held by other(s).\",React.createElement(\"br\",null),React.createElement(\"br\",null),\"Process 1 is holding Resource 1 and waiting for resource 2 which is acquired by process 2, and process 2 is waiting for resource 1.\",React.createElement(\"img\",{src:DeadLocks,alt:\"DeadLock\",className:\"responsive\",style:redesign}),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Deadlock can arise if following four conditions hold simultaneously\"),React.createElement(\"br\",null),React.createElement(\"ol\",null,React.createElement(\"li\",null,React.createElement(\"b\",null,\"Mutual Exclusion:\"),\" One/ more than one resource are non-sharable (Only one process can use at a time).\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Hold and Wait:\"),\" A process is holding at least one resource and waiting for resources.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"No Preemption:\"),\" A resource cannot be taken from a process unless the process releases the resource.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Circular Wait:\"),\" A set of processes are waiting for each other in circular form.\")),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"h4\",null,\"Methods for handling deadlock:\"),React.createElement(\"b\",null,\"There are three ways to handle deadlock\"),React.createElement(\"br\",null),React.createElement(\"ul\",null,React.createElement(\"li\",null,React.createElement(\"b\",null,\"1) Deadlock prevention or avoidance: \"),\"The idea is to not let the system into deadlock state. Prevention is done by negating one of above mentioned necessary conditions for deadlock. By using strategy of \\u201CAvoidance\\u201D, we have to make an assumption. We need to ensure that all information about resources which process WILL need are known to us prior to execution of the process.\",React.createElement(\"br\",null),React.createElement(\"br\",null),\"We use Banker\\u2019s algorithm in order to avoid deadlock.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"2) Deadlock detection and recovery: \"),\"Let deadlock occur, then do preemption to handle it once occurred.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"3) Ignore the problem all together: \"),\"If deadlock is very rare, then let it happen and reboot the system. This is the approach that both Windows and UNIX take.\"))))));}}]);return IntroAlgo;}(Component);export default withStyles(styles)(IntroAlgo);","map":{"version":3,"sources":["/home/mukeshs/Projects/edurights/src/components/algorithams/deepAlgorithams/introAlgo.js"],"names":["React","Component","Prism","Grid","Paper","withStyles","List","Sidebar","PrismCode","LinkedList","Theata","Big_O","Omega","DeadLocks","divudeconquers","dis","di","greedy","search","titles","backgroundColor","padding","fontSize","redesign","height","width","styles","theme","paper","margin","spacing","smMargin","actionDiv","textAlign","code","trim","IntroAlgo","setTimeout","highlightAll","classes","props"],"mappings":"6kBAAA,MAAOA,CAAAA,KAAP,EAAgBC,SAAhB,KAAiC,OAAjC,CACA,MAAOC,CAAAA,KAAP,KAAkB,SAAlB,CACA,OAASC,IAAT,CAAeC,KAAf,CAAsBC,UAAtB,CAAkCC,IAAlC,KAA8C,mBAA9C,CAEA,MAAO,0BAAP,CACA,MAAOC,CAAAA,OAAP,KAAoB,YAApB,CACA,MAAOC,CAAAA,SAAP,KAAsB,yBAAtB,CAEA,MAAOC,CAAAA,UAAP,KAAuB,gCAAvB,CACA,MAAOC,CAAAA,MAAP,KAAmB,2BAAnB,CACA,MAAOC,CAAAA,KAAP,KAAkB,2BAAlB,CACA,MAAOC,CAAAA,KAAP,KAAkB,2BAAlB,CACA,MAAOC,CAAAA,SAAP,KAAsB,8BAAtB,CACA,MAAOC,CAAAA,cAAP,KAA2B,oCAA3B,CACA,MAAOC,CAAAA,GAAP,KAAgB,+BAAhB,CACA,MAAOC,CAAAA,EAAP,KAAe,wBAAf,CACA,MAAOC,CAAAA,MAAP,KAAmB,4BAAnB,CACA,MAAOC,CAAAA,MAAP,KAAmB,4BAAnB,CAGA,GAAMC,CAAAA,MAAM,CAAG,CAAEC,eAAe,CAAE,SAAnB,CAA8BC,OAAO,CAAE,KAAvC,CAA8CC,QAAQ,CAAE,MAAxD,CAAf,CAGA,GAAMC,CAAAA,QAAQ,CAAG,CACfC,MAAM,CAAE,GADO,CAEfC,KAAK,CAAE,GAFQ,CAAjB,CAKA,GAAMC,CAAAA,MAAM,CAAG,QAATA,CAAAA,MAAS,CAAAC,KAAK,QAAK,CACvBC,KAAK,CAAE,CACLC,MAAM,CAAEF,KAAK,CAACG,OAAN,CAAc,CAAd,CADH,CAELT,OAAO,CAAEM,KAAK,CAACG,OAAN,CAAc,CAAd,CAFJ,CADgB,CAKvBC,QAAQ,CAAE,CACRF,MAAM,CAAEF,KAAK,CAACG,OAAN,CAAc,CAAd,CADA,CALa,CAQvBE,SAAS,CAAE,CACTC,SAAS,CAAE,QADF,CARY,CAAL,EAApB,CAaA,GAAMC,CAAAA,IAAI,CAAG,KACXC,IADW,EAAb,C,GAIMC,CAAAA,S,qSACgB,CAClBC,UAAU,CAAC,iBAAMnC,CAAAA,KAAK,CAACoC,YAAN,EAAN,EAAD,CAA6B,CAA7B,CAAV,CACD,C,uCACQ,IACCC,CAAAA,OADD,CACa,KAAKC,KADlB,CACCD,OADD,CAEP,MACE,qBAAC,IAAD,EAAM,SAAS,KAAf,EACE,oBAAC,IAAD,EAAM,IAAI,KAAV,CAAW,EAAE,CAAE,CAAf,EACE,oBAAC,KAAD,EAAO,SAAS,CAAEA,OAAO,CAACX,KAA1B,EACE,8BAAI,oBAAC,OAAD,MAAJ,CADF,CADF,CADF,CAME,oBAAC,IAAD,EAAM,IAAI,KAAV,CAAW,EAAE,CAAE,EAAf,EACE,oBAAC,KAAD,EAAO,SAAS,CAAEW,OAAO,CAACX,KAA1B,EACE,oBAAC,IAAD,MACE,yFADF,CAEE,2BAAK,GAAG,CAAEnB,UAAV,CAAsB,GAAG,CAAC,UAA1B,CAAqC,SAAS,CAAC,YAA/C,CAA4D,KAAK,CAAEc,QAAnE,EAFF,CAGE,2PAHF,CAQE,8BARF,CAUE,2EAVF,CAWE,wRAXF,CAgBE,8BAhBF,CAkBE,gIAlBF,CAmBE,+EAEE,8BACE,oMADF,CAGE,kMAHF,CAFF,CAnBF,CA4BE,8BA5BF,CA8BE,kEA9BF,CA+BE,oGAEE,8BACE,8BAAI,mDAAJ,iFADF,CAEE,8BAAI,gEAAJ,8DAFF,CAGE,8BAAI,6CAAJ,qDAHF,CAFF,CAOE,8BAPF,wGAWE,8BAXF,kKAeE,8BAfF,CAgBE,8BAhBF,wKA/BF,CAoDE,8BApDF,CAsDE,0EAtDF,CAuDE,mSAIE,8BAJF,CAKE,8BACE,8BAAI,wCAAJ,qEADF,CAEE,8BAAI,yCAAJ,mDAFF,CAGE,8BAAI,yCAAJ,mGAHF,CALF,CAUE,oCAVF,0FAvDF,CAmEE,2BAAK,GAAG,CAAET,cAAV,CAA0B,GAAG,CAAC,UAA9B,CAAyC,SAAS,CAAC,YAAnD,CAAgE,KAAK,CAAES,QAAvE,EAnEF,CAoEE,8BApEF,CAqEE,8BArEF,CAuEE,8EAvEF,CAwEE,2BAAK,GAAG,CAAEP,EAAV,CAAc,GAAG,CAAC,UAAlB,CAA6B,SAAS,CAAC,YAAvC,CAAoD,KAAK,CAAEO,QAA3D,EAxEF,CAyEE,2BAAK,GAAG,CAAER,GAAV,CAAe,GAAG,CAAC,UAAnB,CAA8B,SAAS,CAAC,YAAxC,CAAqD,KAAK,CAAEQ,QAA5D,EAzEF,CA0EE,6BACE,8BACE,iKADF,CAGE,kJAHF,CADF,CAME,8BANF,uRA1EF,CAsFE,8BAtFF,CAwFE,+DAxFF,CAyFE,2BAAK,GAAG,CAAEN,MAAV,CAAkB,GAAG,CAAC,UAAtB,CAAiC,SAAS,CAAC,YAA3C,CAAwD,KAAK,CAAEM,QAA/D,EAzFF,CA0FE,iRAIE,8BAJF,CAKE,8BALF,oRAUE,8BAVF,CAWE,8BAXF,CAYE,oCAZF,qPA1FF,CA0GE,8BA1GF,CA4GE,4DA5GF,CA6GE,2BAAK,GAAG,CAAEL,MAAV,CAAkB,GAAG,CAAC,UAAtB,CAAiC,SAAS,CAAC,YAA3C,CAAwD,KAAK,CAAEK,QAA/D,EA7GF,CA8GE,sJAGE,8BAHF,CAIE,8BAJF,CAME,8BACE,8BAAI,wCAAJ,sCADF,CAEE,8BAAI,uCAAJ,qFAFF,CAGE,8BAAI,uCAAJ,8DAHF,CAIE,8BAAI,uCAAJ,mEAJF,CAKE,8BAAI,uCAAJ,oCALF,CANF,CA9GF,CA4HE,8BA5HF,CA8HE,wDA9HF,gUAmIE,8BAnIF,CAoIE,8BApIF,0DAsIE,8BAtIF,CAuIE,8BAvIF,CAwIE,gDAxIF,CAwIoB,8BAxIpB,iNA4IE,8BA5IF,CA6IE,2BAAK,GAAG,CAAEb,MAAV,CAAkB,GAAG,CAAC,QAAtB,CAA+B,SAAS,CAAC,aAAzC,CAAuD,KAAK,CAAEa,QAA9D,EA7IF,CA8IE,8BA9IF,CA+IE,8BA/IF,CAiJE,+CAjJF,CAiJwB,8BAjJxB,qVAsJE,8BAtJF,CAuJE,2BAAK,GAAG,CAAEZ,KAAV,CAAiB,GAAG,CAAC,OAArB,CAA6B,SAAS,CAAC,YAAvC,CAAoD,KAAK,CAAEY,QAA3D,EAvJF,CAwJE,8BAxJF,CAyJE,8BAzJF,CA2JE,gDA3JF,CA2JoB,8BA3JpB,gNA+JE,8BA/JF,CAgKE,2BAAK,GAAG,CAAEX,KAAV,CAAiB,GAAG,CAAC,OAArB,CAA6B,SAAS,CAAC,YAAvC,CAAoD,KAAK,CAAEW,QAA3D,EAhKF,CAiKE,8BAjKF,CAmKE,iEAnKF,gGAoK8F,8BApK9F,CAqKE,8BACE,uDADF,CAEE,oDAFF,CAGE,yDAHF,CArKF,CA0KE,8BA1KF,4KA6KE,8BA7KF,CA8KE,8BA9KF,CAgLE,oCAhLF,2SAoLE,8BApLF,CAqLE,8BArLF,uIA0LE,2BAAK,GAAG,CAAEV,SAAV,CAAqB,GAAG,CAAC,UAAzB,CAAoC,SAAS,CAAC,YAA9C,CAA2D,KAAK,CAAEU,QAAlE,EA1LF,CA2LE,8BA3LF,CA4LE,8BA5LF,CA8LE,mGA9LF,CA+LE,8BA/LF,CAgME,8BACE,8BACE,iDADF,uFADF,CAKE,8BAAI,8CAAJ,0EALF,CAME,8BAAI,8CAAJ,wFANF,CAOE,8BAAI,8CAAJ,oEAPF,CAhMF,CAyME,8BAzMF,CA0ME,8BA1MF,CA4ME,+DA5MF,CA6ME,uEA7MF,CA8ME,8BA9MF,CA+ME,8BACE,8BACE,qEADF,gWAME,8BANF,CAOE,8BAPF,8DADF,CAWE,8BAXF,CAaE,8BACE,oEADF,sEAbF,CAiBE,8BAjBF,CAmBE,8BACE,oEADF,6HAnBF,CA/MF,CADF,CADF,CANF,CADF,CAqPD,C,uBA3PqBtB,S,EA8PxB,cAAgBI,CAAAA,UAAU,CAACqB,MAAD,CAAV,CAAmBU,SAAnB,CAAhB","sourcesContent":["import React, { Component } from 'react';\nimport Prism from \"prismjs\"\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\n\nimport '../../ReactJs/styles.css'\nimport Sidebar from '../sidebar';\nimport PrismCode from '../../ReactJs/prismCode';\n\nimport LinkedList from '../../../assets/linkedList.png';\nimport Theata from '../../../assets/theta.png';\nimport Big_O from '../../../assets/big_O.png';\nimport Omega from '../../../assets/omega.png';\nimport DeadLocks from '../../../assets/deadlock.png';\nimport divudeconquers from '../../../assets/divide_conquer.png';\nimport dis from '../../../assets/dijkastra.jpg';\nimport di from '../../../assets/di.png';\nimport greedy from '../../../assets/greedy.png';\nimport search from '../../../assets/search.png';\n\n\nconst titles = { backgroundColor: '#F0F8FF', padding: '1px', fontSize: '16px' }\n\n\nconst redesign = {\n  height: 200,\n  width: 500\n}\n\nconst styles = theme => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1)\n  },\n  smMargin: {\n    margin: theme.spacing(1)\n  },\n  actionDiv: {\n    textAlign: \"center\"\n  }\n})\n\nconst code = `\n`.trim()\n\n\nclass IntroAlgo extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0)\n  }\n  render() {\n    const { classes } = this.props;\n    return (\n      <Grid container>\n        <Grid item xs={2}>\n          <Paper className={classes.paper}>\n            <h4><Sidebar /></h4>\n          </Paper>\n        </Grid>\n        <Grid item xs={10}>\n          <Paper className={classes.paper}>\n            <List>\n              <h3>1.How to find middle element of linked list in one pass?</h3>\n              <img src={LinkedList} alt=\"DeadLock\" className=\"responsive\" style={redesign} />\n              <p>\n                We need to maintain two-pointer, one increment at each node while other\n                increments after two nodes at a time, when the first pointer reaches the end, the second\n                pointer will point to a middle element of the linked list.\n              </p>\n              <br />\n\n              <h3>2.How to find if a linked list has a loop?</h3>\n              <p>\n                If we maintain two pointers, and we increment one pointer after processing two nodes and other after processing every\n                node, we will find a situation where both pointers will pointing to the same node. This\n                happen if a linked list has a loop/ cycle.\n              </p>\n              <br />\n\n              <h3>3. What is the difference between the Singly Linked List and Doubly Linked List data structure?</h3>\n              <p>\n                The main difference is the ability to traverse.\n                <ol>\n                  <li>In a singly linked list, a node only points towards the next node, and there is no pointer to the previous node, So,\n                    can not traverse back on a singly linked list.</li>\n                  <li>On the other hand, the doubly linked list maintains two pointers,\n                    towards the next and previous node, which allows to navigate in both directions in linked list.</li>\n                </ol>\n              </p>\n              <br />\n\n              <h3>4.Generally data structure types?</h3>\n              <p>\n                At a high level, there are basically three types of data structures.\n                <ol>\n                  <li><b>Stacks and Queues: </b>Array-like structures that differ only in how items are inserted and removed.</li>\n                  <li><b>Linked Lists, Trees, and Graphs:</b>Structures with nodes that keep references to other nodes.</li>\n                  <li><b>Hash Tables: </b>Depend on hash functions to save and locate data.</li>\n                </ol>\n                <br />\n\n                In terms of complexity,\n                Stacks and Queues are the simplest and can be constructed from Linked Lists.\n                <br />\n                Trees and Graphs are the most complex\n                because they extend the concept of a linked list. Hash Tables need to utilize these data structures to perform\n                reliably.\n                <br />\n                <br />\n\n                In terms of efficiency, Linked Lists are most optimal for recording and storing of data, while Hash Tables\n                are most performant for searching and retrieving of data.\n              </p>\n              <br />\n\n              <h3>5. What is Divide and Conquer algorithms?</h3>\n              <p>\n                Divide and Conquer is a pattern for algorithm. It is designed in a way as to take dispute\n                on a huge input, break the input into minor pieces, and decide the problem for each of the small pieces. Now merge\n                all of the piecewise solutions into a global solution.\n                <br />\n                <ol>\n                  <li><b>Divide: </b>Algorithm divides the original problem into a set of subproblems.</li>\n                  <li><b>Conquer: </b>Algorithm solves every subproblem individually.</li>\n                  <li><b>Combine: </b>TAlgorithm puts together the solutions of the subproblems to get the solution of whole problem.</li>\n                </ol>\n                <b>Ex. </b>Merge Sort, Quick Sort, Binary Search, Strassen's Matrix Multiplication, Closest pair.\n              </p>\n              <img src={divudeconquers} alt=\"DeadLock\" className=\"responsive\" style={redesign} />\n              <br />\n              <br />\n\n              <h3>6.What is Dijkstra's shortest path algorithm?</h3>\n              <img src={di} alt=\"DeadLock\" className=\"responsive\" style={redesign} />\n              <img src={dis} alt=\"DeadLock\" className=\"responsive\" style={redesign} />\n              <p>\n                <ul>\n                  <li>Dijkstra's algorithm is an algorithm for finding the shortest path from a starting node to the target node in a\n                    weighted graph. </li>\n                  <li>Algorithm makes a tree of shortest paths from the starting vertex/ source vertex to all other nodes in the graph.</li>\n                </ul>\n                <br />\n\n                Suppose you want to go from home to office in the shortest possible way. You know some roads are\n                heavily congested (large weight) and challenging to use this,. In Dijkstra's algorithm, the\n                shortest path tree found by the algorithm will try to avoid edges with larger weights.\n              </p>\n              <br />\n\n              <h3>7. What are Greedy algorithms?</h3>\n              <img src={greedy} alt=\"DeadLock\" className=\"responsive\" style={redesign} />\n              <p>\n                A greedy algorithm made for the best optimal choice at each sub stage with the\n                goal of teventually leading to a globally optimum solution. This means that the algorithm chooses the best\n                solution at the moment without regard for consequences.\n                <br />\n                <br />\n\n                In other words, an algorithm that always takes the best\n                immediate, or local, solution while finding an answer. Greedy algorithms find the overall, ideal solution for some\n                idealistic problems, but may discover less-than-ideal solutions for some instances of other problems.\n                <br />\n                <br />\n                <b>Ex. </b>Travelling Salesman Problem, Prim's\n                Minimal Spanning Tree Algorithm, Kruskal's Minimal Spanning Tree Algorithm, Dijkstra's Minimal Spanning Tree\n                Algorithm, Graph - Map Coloring, Graph - Vertex Cover, Knapsack Problem, Job Scheduling Problem,\n              </p>\n              <br />\n\n              <h3>8. What is a linear search?</h3>\n              <img src={search} alt=\"DeadLock\" className=\"responsive\" style={redesign} />\n              <p>\n                Technique of traversing a list from start to end by\n                visiting properties of all the elements that are found on the way.\n                <br />\n                <br />\n\n                <ul>\n                  <li><b>Step1:  </b>Traverse the array using for loop.</li>\n                  <li><b>Step2: </b>In every iteration, compare the target value with the current value of the array.</li>\n                  <li><b>Step3: </b>If the values match, return the current index of the array</li>\n                  <li><b>Step4: </b>If the values do not match, shift on to the next array element.</li>\n                  <li><b>Step5: </b>If no match is found, return -1.</li>\n                </ul>\n              </p>\n              <br />\n\n              <h3>9. Asymptotic Notations</h3>\n              Asymptotic analysis is used to measure the efficiency of an algorithm that doesn't\n              depend on machine-specific constants and prevents the algorithm from comparing the time\n              taking algorithm. Asymptotic notation is a mathematical tool that is used to represent\n              the time complexity of algorithms for asymptotic analysis.\n              <br />\n              <br />\n              The three most used asymptotic notation is as follows.\n              <br />\n              <br />\n              <b>θ Notation:</b><br />\n              θ Notation defines exact asymptotic behavior. It bounds\n              functions from above and below. A convenient way to get Theta notation of an expression\n              is to drop low order terms and ignore leading constants.\n              <br />\n              <img src={Theata} alt=\"Theata\" className=\"responsive2\" style={redesign} />\n              <br />\n              <br />\n\n              <b>Big O Notation:</b><br />\n              The Big O notation bounds a function from above, it defines an upper bound of an\n              algorithm. Let's consider the case of insertion sort, it takes linear time in the best\n              case and quadratic time in the worst case. The time complexity of insertion sort is O(n2).\n              It is useful when we only have upper bound on time complexity of an algorithm.\n              <br />\n              <img src={Big_O} alt=\"Big O\" className=\"responsive\" style={redesign} />\n              <br />\n              <br />\n\n              <b>Ω Notation:</b><br />\n              Just like Big O notation provides an asymptotic upper bound, the Ω Notation provides an\n              asymptotic lower bound on a function. It is useful when we have lower bound on time\n              complexity of an algorithm.\n              <br />\n              <img src={Omega} alt=\"Omega\" className=\"responsive\" style={redesign} />\n              <br />\n\n              <h3>10. Deadlock in Operating System</h3>\n              A process in operating systems uses different resources and uses resources in following way.<br />\n              <ul>\n                <li>1) Requests a resource</li>\n                <li>2) Use the resource</li>\n                <li>2) Releases the resource</li>\n              </ul>\n              <br />\n              Deadlock is a situation where a set of processes are blocked because each process is holding\n              a resource and waiting for another resource acquired by some other process.\n              <br />\n              <br />\n\n              <b>Ex. </b>When two trains are coming toward each other on same track and there is\n              only one track, none of the trains can move once they are in front of each other. Similar\n              situation occurs in operating systems when there are two/ more processes hold some\n              resources and wait for resources held by other(s).\n              <br />\n              <br />\n\n              Process 1 is holding Resource 1 and waiting for resource 2 which is acquired by process 2,\n              and process 2 is waiting for resource 1.\n\n              <img src={DeadLocks} alt=\"DeadLock\" className=\"responsive\" style={redesign} />\n              <br />\n              <br />\n\n              <b>Deadlock can arise if following four conditions hold simultaneously</b>\n              <br />\n              <ol>\n                <li>\n                  <b>Mutual Exclusion:</b> One/ more than one resource are non-sharable (Only one process\n                  can use at a time).\n                </li>\n                <li><b>Hold and Wait:</b> A process is holding at least one resource and waiting for resources.</li>\n                <li><b>No Preemption:</b> A resource cannot be taken from a process unless the process releases the resource.</li>\n                <li><b>Circular Wait:</b> A set of processes are waiting for each other in circular form.</li>\n              </ol>\n              <br />\n              <br />\n\n              <h4>Methods for handling deadlock:</h4>\n              <b>There are three ways to handle deadlock</b>\n              <br />\n              <ul>\n                <li>\n                  <b>1) Deadlock prevention or avoidance: </b>The idea is to not let the system into deadlock state.\n                  Prevention is done by negating one of above mentioned necessary conditions for deadlock.\n                  By using strategy of “Avoidance”, we have to make\n                  an assumption. We need to ensure that all information about resources which process WILL\n                  need are known to us prior to execution of the process.\n                  <br />\n                  <br />\n                  We use Banker’s algorithm in order to avoid deadlock.\n                </li>\n                <br />\n\n                <li>\n                  <b>2) Deadlock detection and recovery: </b>Let deadlock occur, then do preemption to handle it once\n                  occurred.\n                </li>\n                <br />\n\n                <li>\n                  <b>3) Ignore the problem all together: </b>If deadlock is very rare, then let it happen and reboot\n                  the system. This is the approach that both Windows and UNIX take.\n                </li>\n              </ul>\n            </List>\n          </Paper>\n        </Grid>\n      </Grid>\n    )\n  }\n}\n\nexport default (withStyles(styles)(IntroAlgo));\n"]},"metadata":{},"sourceType":"module"}