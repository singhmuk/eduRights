{"ast":null,"code":"var _jsxFileName = \"/home/mukeshs/Projects/edurights/client/src/components/ml/deepMl/k_meanClustring.js\";\nimport React, { Component } from 'react';\nimport Prism from \"prismjs\";\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\nimport '../../ReactJs/styles.css';\nimport Sidebar from '../sidebar';\nimport PrismCode from '../../ReactJs/prismCode';\nconst titles = {\n  backgroundColor: '#F0F8FF',\n  padding: '1px',\n  fontSize: '16px'\n};\n\nconst styles = theme => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1)\n  },\n  smMargin: {\n    margin: theme.spacing(1)\n  },\n  actionDiv: {\n    textAlign: \"center\"\n  }\n});\n\nconst kmeansClucs = `\nfrom sklearn.cluster import KMeans\nimport pandas as pd\nfrom sklearn.preprocessing import MinMaxScaler\nfrom matplotlib import pyplot as plt\n%matplotlib inline\n\ndf = pd.read_csv(\"income.csv\")\n\nplt.scatter(df.Age,df['Income($)'])\nplt.xlabel('Age')\nplt.ylabel('Income($)')\n\nkm = KMeans(n_clusters=3)\ny_predicted = km.fit_predict(df[['Age','Income($)']])\n\ndf['cluster']=y_predicted\n\nkm.cluster_centers_\n\ndf1 = df[df.cluster==0]\ndf2 = df[df.cluster==1]\ndf3 = df[df.cluster==2]\n\nplt.scatter(df1.Age,df1['Income($)'],color='green')\nplt.scatter(df2.Age,df2['Income($)'],color='red')\nplt.scatter(df3.Age,df3['Income($)'],color='black')\nplt.scatter(km.cluster_centers_[:,0],km.cluster_centers_[:,1],color='purple',marker='*',label='centroid')\n\nplt.xlabel('Age')\nplt.ylabel('Income ($)')\nplt.legend()\n`.trim();\nconst preprocessing = `\nscaler = MinMaxScaler()\n\nscaler.fit(df[['Income($)']])\ndf['Income($)'] = scaler.transform(df[['Income($)']])\n\nscaler.fit(df[['Age']])\ndf['Age'] = scaler.transform(df[['Age']])\n\nplt.scatter(df.Age,df['Income($)'])\n\nkm = KMeans(n_clusters=3)\ny_predicted = km.fit_predict(df[['Age','Income($)']])\n\ndf['cluster'] = y_predicted\nkm.cluster_centers_\n\ndf1 = df[df.cluster==0]\ndf2 = df[df.cluster==1]\n\nplt.scatter(df1.Age,df1['Income($)'],color='green')\nplt.scatter(df2.Age,df2['Income($)'],color='red')\nplt.scatter(df3.Age,df3['Income($)'],color='black')\nplt.scatter(km.cluster_centers_[:,0],km.cluster_centers_[:,1],color='purple',marker='*',label='centroid')\nplt.legend()\n`.trim();\nconst elbo = `\nsse = []\nk_rng = range(1,10)\nfor k in k_rng:\n    km = KMeans(n_clusters=k)\n    km.fit(df[['Age','Income($)']])\n    sse.append(km.inertia_)\n    \nplt.xlabel('K')\nplt.ylabel('Sum of squared error')\nplt.plot(k_rng,sse)\n`.trim();\nconst cluster = `      %matplotlib inline\nimport matplotlib.pyplot as plt\nimport seaborn as sns; sns.set()\nimport numpy as np\nfrom sklearn.cluster import KMeans\nfrom sklearn.datasets.samples_generator import make_blobs\nX, y_true = make_blobs(n_samples = 400, centers = 4, cluster_std = 0.60, random_state = 0)\nplt.scatter(X[:, 0], X[:, 1], s = 20);\nplt.show()\n`.trim();\nconst cluster_2 = `kmeans = KMeans(n_clusters = 4)\nkmeans.fit(X)\ny_kmeans = kmeans.predict(X)\n`.trim();\nconst cluster_3 = `plt.scatter(X[:, 0], X[:, 1], c = y_kmeans, s = 20, cmap = 'summer')\ncenters = kmeans.cluster_centers_\nplt.scatter(centers[:, 0], centers[:, 1], c = 'blue', s = 100, alpha = 0.9);\nplt.show()\n`.trim();\nconst cluster_4 = `%matplotlib inline\nimport matplotlib.pyplot as plt\nimport seaborn as sns; sns.set()\nimport numpy as np\nfrom sklearn.cluster import KMeans\nfrom sklearn.datasets import load_digits\ndigits = load_digits()\ndigits.data.shape\n`.trim();\n\nclass K_Mean extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0);\n  }\n\n  render() {\n    const {\n      classes\n    } = this.props;\n    return React.createElement(Grid, {\n      container: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 139\n      },\n      __self: this\n    }, React.createElement(Grid, {\n      item: true,\n      xs: 2,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 140\n      },\n      __self: this\n    }, React.createElement(Paper, {\n      className: classes.paper,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 141\n      },\n      __self: this\n    }, React.createElement(\"h4\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 142\n      },\n      __self: this\n    }, React.createElement(Sidebar, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 142\n      },\n      __self: this\n    })))), React.createElement(Grid, {\n      item: true,\n      xs: 10,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 145\n      },\n      __self: this\n    }, React.createElement(Paper, {\n      className: classes.paper,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 146\n      },\n      __self: this\n    }, React.createElement(List, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 147\n      },\n      __self: this\n    }, React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 148\n      },\n      __self: this\n    }, \"Clustering With K Means\"), \"K Means is an Unsuperwised Learning.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 150\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 151\n      },\n      __self: this\n    }), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 152\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: kmeansClucs,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 153\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 159\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 161\n      },\n      __self: this\n    }, \"Preprocessing using min max scaler\"), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 162\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: preprocessing,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 163\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 169\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 171\n      },\n      __self: this\n    }, \"Elbow Plot\"), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 172\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: elbo,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 173\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 179\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 181\n      },\n      __self: this\n    }, \"K-Means clustering:\"), \"K-means clustering algorithm computes the centroids and iterates until we it finds optimal centroid. It assumes that the number of clusters are already known. It is also called flat clustering algorithm. The number of clusters identified from data by algorithm is represented by \\u2018K\\u2019 in K-means.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 185\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 186\n      },\n      __self: this\n    }), \"In this, the data points are assigned to a cluster in such a manner that the sum of the squared distance between the data points and centroid would be minimum. It is to be understood that less variation within the clusters will lead to more similar data points within same cluster.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 190\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 191\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 192\n      },\n      __self: this\n    }, \"Working of K-Means Algorithm: \"), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 193\n      },\n      __self: this\n    }, React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 194\n      },\n      __self: this\n    }, \"1. We need to specify the number of clusters, K, need to be generated by this algorithm.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 195\n      },\n      __self: this\n    }, \"2. Randomly select K data points and assign each data point to a cluster. In simple words, classify the data based on the number of data points.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 197\n      },\n      __self: this\n    }, \"3. Now it will compute the cluster centroids.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 198\n      },\n      __self: this\n    }, \"4. Keep iterating the following until we find optimal centroid which is the assignment of data points to the clusters that are not changing any more\"), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 200\n      },\n      __self: this\n    }, React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 201\n      },\n      __self: this\n    }, \"1. The sum of squared distance between data points and centroids would be computed.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 202\n      },\n      __self: this\n    }, \"2. Now, we have to assign each data point to the cluster that is closer than other cluster (centroid).\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 203\n      },\n      __self: this\n    }, \"3. At last compute the centroids for the clusters by taking the average of all data points of that cluster.\"))), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 206\n      },\n      __self: this\n    }), \"K-means follows Expectation-Maximization approach to solve the problem. The Expectation-step is used for assigning the data points to the closest cluster and the Maximization-step is used for computing the centroid of each cluster.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 210\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 211\n      },\n      __self: this\n    }), \"While working with K-means algorithm we need to take care of the following things \\u2212\", React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 213\n      },\n      __self: this\n    }, React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 214\n      },\n      __self: this\n    }, \"It is recommended to standardize the data because such algorithms use distance-based measurement to determine the similarity between data points.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 216\n      },\n      __self: this\n    }, \"Due to the iterative nature of K-Means and random initialization of centroids, K-Means may stick in a local optimum and may not converge to global optimum. That is why it is recommended to use different initializations of centroids.\")), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 219\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 220\n      },\n      __self: this\n    }, \"Ex.\"), \" We are going to first generate 2D dataset containing 4 different blobs and after that will apply k-means algorithm to see the result.\", React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 223\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: cluster,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 224\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 230\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 231\n      },\n      __self: this\n    }), React.createElement(\"i\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 232\n      },\n      __self: this\n    }, \"Next, make an object of KMeans along with providing number of clusters, train the model and do the prediction as follows \\u2212\"), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 235\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: cluster_2,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 236\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 242\n      },\n      __self: this\n    }), \"Now, with the help of following code we can plot and visualize the cluster\\u2019s centers picked by k-means Python estimator \\u2212\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 245\n      },\n      __self: this\n    }), \"from sklearn.datasets.samples_generator import make_blobs\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 246\n      },\n      __self: this\n    }), \"X, y_true = make_blobs(n_samples = 400, centers = 4, cluster_std = 0.60, random_state = 0)\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 248\n      },\n      __self: this\n    }), \"Next, the following code will help us to visualize the dataset \\u2212\", React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 250\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: cluster_3,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 251\n      },\n      __self: this\n    })), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 257\n      },\n      __self: this\n    }, \"Let us move to another example in which we are going to apply K-means clustering on simple digits dataset. K-means will try to identify similar digits without using the original label information.\"), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 260\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: cluster_4,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 261\n      },\n      __self: this\n    })), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 267\n      },\n      __self: this\n    }, \"Advantages and Disadvantages:\"), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 268\n      },\n      __self: this\n    }, \"Advantages:\"), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 269\n      },\n      __self: this\n    }, React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 270\n      },\n      __self: this\n    }, \"It is very easy to understand and implement.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 271\n      },\n      __self: this\n    }, \"If we have large number of variables then, K-means would be faster than Hierarchical clustering.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 272\n      },\n      __self: this\n    }, \"On re-computation of centroids, an instance can change the cluster.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 273\n      },\n      __self: this\n    }, \"Tighter clusters are formed with K-means as compared to Hierarchical clustering\")), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 275\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 277\n      },\n      __self: this\n    }, \"Disadvantages:\"), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 278\n      },\n      __self: this\n    }, React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 279\n      },\n      __self: this\n    }, \"It is a bit difficult to predict the number of clusters i.e. the value of k.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 280\n      },\n      __self: this\n    }, \"Output is strongly impacted by initial inputs like number of clusters (value of k) Order of data will have strong impact on the final output.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 282\n      },\n      __self: this\n    }, \"It is very sensitive to rescaling. If we will rescale our data by means of normalization or standardization, then the output will completely change.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 284\n      },\n      __self: this\n    }, \"It is not good in doing clustering job if the clusters have a complicated geometric shape.\")), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 286\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 288\n      },\n      __self: this\n    }, \"Applications:\"), \"To get a meaningful intuition from the data we are working with. Cluster-then-predict where different models will be built for different subgroups.\"))));\n  }\n\n}\n\nexport default withStyles(styles)(K_Mean);","map":{"version":3,"sources":["/home/mukeshs/Projects/edurights/client/src/components/ml/deepMl/k_meanClustring.js"],"names":["React","Component","Prism","Grid","Paper","withStyles","List","Sidebar","PrismCode","titles","backgroundColor","padding","fontSize","styles","theme","paper","margin","spacing","smMargin","actionDiv","textAlign","kmeansClucs","trim","preprocessing","elbo","cluster","cluster_2","cluster_3","cluster_4","K_Mean","componentDidMount","setTimeout","highlightAll","render","classes","props"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport Prism from \"prismjs\"\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\n\nimport '../../ReactJs/styles.css'\nimport Sidebar from '../sidebar';\nimport PrismCode from '../../ReactJs/prismCode';\n\n\nconst titles = { backgroundColor: '#F0F8FF', padding: '1px', fontSize: '16px' }\n\nconst styles = theme => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1)\n  },\n  smMargin: {\n    margin: theme.spacing(1)\n  },\n  actionDiv: {\n    textAlign: \"center\"\n  }\n})\n\nconst kmeansClucs = `\nfrom sklearn.cluster import KMeans\nimport pandas as pd\nfrom sklearn.preprocessing import MinMaxScaler\nfrom matplotlib import pyplot as plt\n%matplotlib inline\n\ndf = pd.read_csv(\"income.csv\")\n\nplt.scatter(df.Age,df['Income($)'])\nplt.xlabel('Age')\nplt.ylabel('Income($)')\n\nkm = KMeans(n_clusters=3)\ny_predicted = km.fit_predict(df[['Age','Income($)']])\n\ndf['cluster']=y_predicted\n\nkm.cluster_centers_\n\ndf1 = df[df.cluster==0]\ndf2 = df[df.cluster==1]\ndf3 = df[df.cluster==2]\n\nplt.scatter(df1.Age,df1['Income($)'],color='green')\nplt.scatter(df2.Age,df2['Income($)'],color='red')\nplt.scatter(df3.Age,df3['Income($)'],color='black')\nplt.scatter(km.cluster_centers_[:,0],km.cluster_centers_[:,1],color='purple',marker='*',label='centroid')\n\nplt.xlabel('Age')\nplt.ylabel('Income ($)')\nplt.legend()\n`.trim();\n\nconst preprocessing = `\nscaler = MinMaxScaler()\n\nscaler.fit(df[['Income($)']])\ndf['Income($)'] = scaler.transform(df[['Income($)']])\n\nscaler.fit(df[['Age']])\ndf['Age'] = scaler.transform(df[['Age']])\n\nplt.scatter(df.Age,df['Income($)'])\n\nkm = KMeans(n_clusters=3)\ny_predicted = km.fit_predict(df[['Age','Income($)']])\n\ndf['cluster'] = y_predicted\nkm.cluster_centers_\n\ndf1 = df[df.cluster==0]\ndf2 = df[df.cluster==1]\n\nplt.scatter(df1.Age,df1['Income($)'],color='green')\nplt.scatter(df2.Age,df2['Income($)'],color='red')\nplt.scatter(df3.Age,df3['Income($)'],color='black')\nplt.scatter(km.cluster_centers_[:,0],km.cluster_centers_[:,1],color='purple',marker='*',label='centroid')\nplt.legend()\n`.trim();\n\nconst elbo = `\nsse = []\nk_rng = range(1,10)\nfor k in k_rng:\n    km = KMeans(n_clusters=k)\n    km.fit(df[['Age','Income($)']])\n    sse.append(km.inertia_)\n    \nplt.xlabel('K')\nplt.ylabel('Sum of squared error')\nplt.plot(k_rng,sse)\n`.trim();\n\nconst cluster = `      %matplotlib inline\nimport matplotlib.pyplot as plt\nimport seaborn as sns; sns.set()\nimport numpy as np\nfrom sklearn.cluster import KMeans\nfrom sklearn.datasets.samples_generator import make_blobs\nX, y_true = make_blobs(n_samples = 400, centers = 4, cluster_std = 0.60, random_state = 0)\nplt.scatter(X[:, 0], X[:, 1], s = 20);\nplt.show()\n`.trim()\n\nconst cluster_2 = `kmeans = KMeans(n_clusters = 4)\nkmeans.fit(X)\ny_kmeans = kmeans.predict(X)\n`.trim()\n\nconst cluster_3 = `plt.scatter(X[:, 0], X[:, 1], c = y_kmeans, s = 20, cmap = 'summer')\ncenters = kmeans.cluster_centers_\nplt.scatter(centers[:, 0], centers[:, 1], c = 'blue', s = 100, alpha = 0.9);\nplt.show()\n`.trim()\n\nconst cluster_4 = `%matplotlib inline\nimport matplotlib.pyplot as plt\nimport seaborn as sns; sns.set()\nimport numpy as np\nfrom sklearn.cluster import KMeans\nfrom sklearn.datasets import load_digits\ndigits = load_digits()\ndigits.data.shape\n`.trim()\n\n\nclass K_Mean extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0)\n  }\n  render() {\n    const { classes } = this.props;\n    return (\n      <Grid container>\n        <Grid item xs={2}>\n          <Paper className={classes.paper}>\n            <h4><Sidebar /></h4>\n          </Paper>\n        </Grid>\n        <Grid item xs={10}>\n          <Paper className={classes.paper}>\n            <List>\n              <h3>Clustering With K Means</h3>\n              K Means is an Unsuperwised Learning.\n              <br />\n              <br />\n              <div style={titles}>\n                <PrismCode\n                  code={kmeansClucs}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3>Preprocessing using min max scaler</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={preprocessing}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3>Elbow Plot</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={elbo}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3>K-Means clustering:</h3>\n              K-means clustering algorithm computes the centroids and iterates until we it finds optimal centroid. It assumes that\n              the number of clusters are already known. It is also called flat clustering algorithm. The number of clusters\n              identified from data by algorithm is represented by ‘K’ in K-means.\n              <br />\n              <br />\n              In this, the data points are assigned to a cluster in such a manner that the sum of the squared distance\n              between the data points and centroid would be minimum. It is to be understood that less variation within the clusters\n              will lead to more similar data points within same cluster.\n              <br />\n              <br />\n              <b>Working of K-Means Algorithm: </b>\n              <ul>\n                <li>1. We need to specify the number of clusters, K, need to be generated by this algorithm.</li>\n                <li>2. Randomly select K data points and assign each data point to a cluster. In simple words, classify the\n                  data based on the number of data points.</li>\n                <li>3. Now it will compute the cluster centroids.</li>\n                <li>4. Keep iterating the following until we find optimal centroid which is the assignment of data points to\n                  the clusters that are not changing any more</li>\n                <ul>\n                  <li>1. The sum of squared distance between data points and centroids would be computed.</li>\n                  <li>2. Now, we have to assign each data point to the cluster that is closer than other cluster (centroid).</li>\n                  <li>3. At last compute the centroids for the clusters by taking the average of all data points of that cluster.</li>\n                </ul>\n              </ul>\n              <br />\n\n              K-means follows Expectation-Maximization approach to solve the problem. The Expectation-step is used for assigning\n              the data points to the closest cluster and the Maximization-step is used for computing the centroid of each cluster.\n              <br />\n              <br />\n              While working with K-means algorithm we need to take care of the following things −\n              <ul>\n                <li>It is recommended to standardize the data because such\n                  algorithms use distance-based measurement to determine the similarity between data points.</li>\n                <li>Due to the iterative nature of K-Means and random initialization of centroids, K-Means may stick in a local optimum\n                  and may not converge to global optimum. That is why it is recommended to use different initializations of centroids.</li>\n              </ul>\n              <br />\n              <b>Ex.</b> We are going to first generate 2D dataset containing 4 different blobs and after that will apply k-means\n              algorithm to see the result.\n\n              <div style={titles}>\n                <PrismCode\n                  code={cluster}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <br />\n              <i>Next, make an object of KMeans along with providing number of clusters, train the model and do the prediction as\n                follows −\n              </i>\n              <div style={titles}>\n                <PrismCode\n                  code={cluster_2}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              Now, with the help of following code we can plot and visualize the cluster’s centers picked by k-means Python\n              estimator −\n              <br />\n              from sklearn.datasets.samples_generator import make_blobs<br />\n              X, y_true = make_blobs(n_samples = 400, centers = 4, cluster_std = 0.60, random_state = 0)\n              <br />\n              Next, the following code will help us to visualize the dataset −\n              <div style={titles}>\n                <PrismCode\n                  code={cluster_3}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <h3>Let us move to another example in which we are going to apply K-means clustering on simple digits dataset.\n                K-means will try to identify similar digits without using the original label information.\n              </h3>\n              <div style={titles}>\n                <PrismCode\n                  code={cluster_4}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <h3>Advantages and Disadvantages:</h3>\n              <b>Advantages:</b>\n              <ul>\n                <li>It is very easy to understand and implement.</li>\n                <li>If we have large number of variables then, K-means would be faster than Hierarchical clustering.</li>\n                <li>On re-computation of centroids, an instance can change the cluster.</li>\n                <li>Tighter clusters are formed with K-means as compared to Hierarchical clustering</li>\n              </ul>\n              <br />\n\n              <b>Disadvantages:</b>\n              <ul>\n                <li>It is a bit difficult to predict the number of clusters i.e. the value of k.</li>\n                <li>Output is strongly impacted by initial inputs like number of clusters (value of k)\n                  Order of data will have strong impact on the final output.</li>\n                <li>It is very sensitive to rescaling. If we will rescale our data by means of normalization or standardization, then the\n                  output will completely change.</li>\n                <li>It is not good in doing clustering job if the clusters have a complicated geometric shape.</li>\n              </ul>\n              <br />\n\n              <b>Applications:</b>\n              To get a meaningful intuition from the data we are working with.\n              Cluster-then-predict where different models will be built for different subgroups.\n            </List>\n          </Paper>\n        </Grid>\n      </Grid>\n    )\n  }\n}\n\nexport default (withStyles(styles)(K_Mean));\n"]},"metadata":{},"sourceType":"module"}