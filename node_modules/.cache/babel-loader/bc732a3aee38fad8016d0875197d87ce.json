{"ast":null,"code":"import _classCallCheck from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/createClass\";import _possibleConstructorReturn from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";import _getPrototypeOf from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";import _inherits from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/inherits\";import React,{Component}from'react';import Prism from\"prismjs\";import{Grid,Paper,withStyles,List}from\"@material-ui/core\";import'../../dashboard/blog/styles.css';import Sidebar from'../sidebar';import PrismCode from'../prismCode';import Tools from\"../../../assets/js/jsToolchain.png\";import Tools2 from\"../../../assets/js/jsToolchain_2.png\";import VDom from\"../../../assets/js/vDom.png\";var titles={backgroundColor:'#F0F8FF',padding:'1px',fontSize:'16px'};var redesign={height:350};var redesigns={height:350,width:600};var styles=function styles(theme){return{paper:{margin:theme.spacing(1),padding:theme.spacing(1)},smMargin:{margin:theme.spacing(1)},actionDiv:{textAlign:\"center\"}};};var call=\"\\n// assuming this.state = { value: 0 }\\nthis.setState({ value: 1 });\\nconsole.log(this.state.value); // 0\\n\".trim();var newStates=\"\\n// assuming this.state = { value: 0 };\\nthis.setState((state) => ({ value: state.value + 1}));\\nthis.setState((state) => ({ value: state.value + 1}));\\nthis.setState((state) => ({ value: state.value + 1}));\".trim();var returnSynchronous=\"\\nrender() {\\n  return <button onClick={this.inc}>Click to update</button>\\n}\\n\\ninc() {\\n  console.log('before: ' + this.state.test);\\n  this.setState({\\n    test: this.state.test+1\\n  });\\n  console.log('after: ' + this.state.test);\\n}\\n\\n// click!\\nbefore: 1\\nafter: 1\\n\\n// click!\\nbefore: 2\\nafter: 2\".trim();var Lazy=\"\\nimport React, { Suspense, lazy } from 'react';\\nconst OtherComponent = lazy(() => import('./OtherComponent'));\\n\\nconsr Routes = () => (\\n  <Switch>\\n   <Suspense fallback={<div>Loading Page...</div>}>\\n    <Route path = \\\"/login\\\" component={Login} />\\n    <Route exact path = \\\"Home\\\" component={Home} />\\n   </Suspense>\\n    <Route component={()=> <h1>Page not found</h1>} />\\n  </Switch>\".trim();var Uncontrolled=\"\\nfunction App() {\\n  const inputRef = useRef(null);\\n  \\n  const handleSubmitButton = () => {\\n    alert(inputRef.current.value);\\n  };\\n  return (\\n    <div className=\\\"App\\\">\\n      <input type=\\\"text\\\" ref={inputRef} />\\n      <input type=\\\"submit\\\" value=\\\"submit\\\" onClick={handleSubmitButton} />\\n    </div>\\n  );\\n}\".trim();var Update=\"\\nclass App extends Component{\\n  forceUpdateHandler = () => {\\n    this.forceUpdate();\\n  };\\n  \\n  render(){\\n    return(\\n      <div>\\n        <button onClick= {this.forceUpdateHandler} >FORCE UPDATE</button>\\n        <h4>Random Number : { Math.random() }</h4>\\n      </div>\\n    );\\n  }\\n}\".trim();var code=\"\\nclass App extends Component{\\n  constructor(){\\n      super();\\n      this.state={count:0}\\n  }\\n\\n  componentDidMount(){\\n      console.log('When component render first time')\\n  }\\n\\n  increment(){\\n      this.setState({count:this.state.count + 1})\\n  }\\n\\n  componentDidUpdate(prevProps, prevState){\\n      console.log(prevState.count)\\n      if(prevState.count !=this.state.count){\\n          console.log('component update')\\n      }\\n  }\\n\\n  componentWillUnmount(){\\n      console.log('countis about to be unmounted.')\\n  }\\n\\n  render(){\\n      return(\\n          <div>\\n              {this.state.count}\\n              {/* <button onClick={this.increment.bind(this)}>bindThis</button> */}\\n              <button onClick={()=>this.increment()}>clickMe</button>\\n          </div>\\n      )\\n  }\\n}\\n\\n\\n//functional component\\nconst App = () => {\\n  const [count, setCount] = useState(0);\\n\\n  useEffect(()=>{\\n      console.log('Mounting')\\n      console.log('Updating', count)\\n\\n      return ()=>{\\n          console.log('Unmount')\\n      }\\n  },[count])\\n\\n  const increment = () => {\\n      setCount(count+1)\\n  }\\n\\n      return(\\n          <div>\\n              {count}\\n              <button onClick={increment}>clickMe</button>\\n          </div>\\n      )\\n  }\\n\".trim();var IntroRectJs=/*#__PURE__*/function(_Component){_inherits(IntroRectJs,_Component);function IntroRectJs(){_classCallCheck(this,IntroRectJs);return _possibleConstructorReturn(this,_getPrototypeOf(IntroRectJs).apply(this,arguments));}_createClass(IntroRectJs,[{key:\"componentDidMount\",value:function componentDidMount(){setTimeout(function(){return Prism.highlightAll();},0);}},{key:\"render\",value:function render(){var classes=this.props.classes;return React.createElement(Grid,{container:true},React.createElement(Grid,{item:true,xs:2},React.createElement(\"h4\",null,React.createElement(Sidebar,null))),React.createElement(Grid,{item:true,xs:10},React.createElement(Paper,{className:classes.paper},React.createElement(List,null,React.createElement(\"h3\",null,\"1.Explain the standard JavaScript toolchain, transpilation, JSX, and these items. What tools use in the build steps to optimize the compiled output React code?\"),React.createElement(\"br\",null),React.createElement(\"img\",{src:Tools,alt:\"Omega\",className:\"responsive\",style:redesign}),React.createElement(\"img\",{src:Tools2,alt:\"Omega\",className:\"responsive\",style:redesign}),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"p\",null,React.createElement(\"b\",null,\"There are a couple primary pillars in the JavaScript toolchain:\")),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"1. Dependency Management\"),React.createElement(\"li\",null,\"2. Linting\"),React.createElement(\"li\",null,\"3. Style-checking\"),React.createElement(\"li\",null,\"4. Transpilation and Compilation\"),React.createElement(\"li\",null,\"5. Minification and Compression\"),React.createElement(\"li\",null,\"6. Source-Mapping\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"2. How Virtual-DOM is more efficient than Dirty checking\"),React.createElement(\"img\",{src:VDom,alt:\"Omega\",className:\"responsive\",style:redesigns}),React.createElement(\"p\",null,\"In React, each of our components have a state. This state is like an observable. Essentially, React knows when to re-render the scene because it is able to observe when this data changes. Dirty checking is slower than observables because we must poll the data at a regular interval and check all of the values in the data structure recursively.\"),React.createElement(\"b\",null,\"Virtual DOM: \"),\"Virtual DOM is about avoiding unnecessary changes to the dom. Virtual DOM also allows to collect several changes to be applied at once, so not every single change causes a re-render, but instead re-rendering only happens once after a set of changes was applied to the DOM.\",React.createElement(\"br\",null),React.createElement(\"br\",null),\"A virtual DOM is a lightweight JS object. It is simply a copy of the real DOM.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Virtual DOM operates in three simple steps:\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"1. The entire UI is re-rendered in Virtual DOM representation as data changes.\"),React.createElement(\"li\",null,\"2. Now, the difference between the previous DOM representation and the new one is calculated.\"),React.createElement(\"li\",null,\"3. After the calculations are successfully, the real DOM is updated in line with only the things that actually underwent changes.\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"How does the Real DOM differ from the Virtual DOM: \"),React.createElement(\"ul\",null,React.createElement(\"li\",null,React.createElement(\"b\",null,\"DOM Manipulation: \"),\"Real DOM supports a very expensive DOM manipulation.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Element Update: \"),\"Real DOM creates a new DOM when an element updates. While, virtual DOM updates the JSX.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Memory Wastage: \"),\"Real DOM causes a lot of memory wastage while there is no memory wastage for Virtual DOM.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Update Speed: \"),\"Real DOM updates slowly.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Updating HTML: \"),\"Real DOM can directly update HTML, while virtual DOM can\\u2019t update HTML directly.\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"3. What do you understand with the term polling?\"),React.createElement(\"p\",null,\"The server needs to be monitored for updates w.r.t.time. This process is basically considered as pooling. It checks for the updates approximately after every 5 seconds. Poling make sure that no negative information is present on the servers.\"),React.createElement(\"h3\",null,\"4. Difference between redux saga and redux thunk.\"),\"Use Thunk instead of Saga for simple and trivial tasks like:\",React.createElement(\"ul\",null,React.createElement(\"li\",null,\"AJAX calls\"),React.createElement(\"li\",null,\"data polling and only if they are started directly by the user interaction.\")),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Use Saga for\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"intertwined tasks, Ex login example of the docs.\"),React.createElement(\"li\",null,\"flows with a lot of steps and waitings for other conditions to happen (\\\"finite-state machine\\\" flows)\"),React.createElement(\"li\",null,\"tasks that work in the background and proceed independently from the user interaction (or a mix of background/interactions)\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"5. What is React? What are some of its standouts?\"),\"Writing UI test cases is simple with React, which is also easy to integrate with Angular, Meteor, and other popular JS frameworks.\",React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Excellent for developing complex and interactive web and mobile UI\"),React.createElement(\"li\",null,\"Follows the component-based approach and helps in building reusable UI components\"),React.createElement(\"li\",null,\"Makes use of the virtual DOM instead of the real DOM\"),React.createElement(\"li\",null,\"Relies on server-side rendering\"),React.createElement(\"li\",null,\"Supports unidirectional data flow or data binding\")),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Note: \"),\"JSX is a contraction of the JavaScript and XML.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"6. HOC\"),\"A higher-order component (HOC) is a function that takes a component as input and returns a new component with enhanced functionality. It allows for code reuse, abstraction, and the addition of new features to existing components in a flexible and composable manner.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Benefits of HOC: \"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Reuse of Code.\"),React.createElement(\"li\",null,\"Offers a high hacking facility\"),React.createElement(\"li\",null,\"Supports state abstraction and manipulation\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"7. Define Reducers in React?\"),\"Reducers are functions that specify how the application's state should change in response to different actions.\",React.createElement(\"br\",null),React.createElement(\"h3\",null,\"State\"),\"state refers to the data that represents the current state of a component. It determines how the component appears and behaves at a given point in time. State is used to store and manage dynamic information within a component.\",React.createElement(\"br\",null),React.createElement(\"h3\",null,\"8. When would you use state\"),\"When a component needs to keep track of information between renderings the component itself update, use state.\",React.createElement(\"p\",null,\"Component state is a way of holding, processing information and allows to implement its logic. State is usually a POJO (Plain Old JavaScript Object).\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"using this.setState, accept an Object that will be eventually merged into Components current state.\"),React.createElement(\"li\",null,\"To alter state by writing to this.state directly, it will not lead to the Component re-rendering with new data, and generally lead to state inconsistency.\")),React.createElement(\"br\",null),React.createElement(\"b\",null,\"setState is asynchronous (*)\"),React.createElement(\"br\",null),React.createElement(\"p\",null,\"The setState causes reconciliation is base of the next property \\u2014 setState is asynchronous. This allows us to have multiple calls to setState in a single scope and not trigger not needed re-renders of the whole tree.\"),\"This is why you don\\u2019t see the new values in state right after you updated it.\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:call,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"setState accepts a function as its parameter\"),React.createElement(\"br\",null),React.createElement(\"p\",null,\"If you pass a function as the first argument of setState, React will call it with the at-call-time-current state and expect you to return an Object to merge into state. So updating our example above to:\"),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:newStates,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"i\",null,\"Will give us this.state.value = 3\"),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"9. setState is \\u2026 synchronous?\"),React.createElement(\"p\",null,\"setState is asynchronous? Well, it not always the case! It depends on the execution context.\"),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:returnSynchronous,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Is setState() is async? Props should not change. Why is setState() in React Async instead of Sync?\"),React.createElement(\"br\",null),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"setState() actions are asynchronous and are batched for performance gains. setState() does not immediately mutate this.state but creates a pending state transition. Accessing this.state after calling this method can potentially return the existing value.\"),React.createElement(\"li\",null,\"There is no guarantee of synchronous operation of calls to setState and calls may be batched for performance gains. This is because setState alters the state and causes rerendering. \"),React.createElement(\"li\",null,\"Thus the setState calls are asynchronous as well as batched for better UI experience and performance.\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"10. Why can't you update state directly without setState()?.\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"setState alwase trigger re-rendering of the component.\"),React.createElement(\"li\",null,\"Mutating state directly can lead to odd bugs, and components that are hard to optimize.\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"11. Props should not change\"),\"You used to be able to change props with setProps and replaceProps but these have been deprecated.\",React.createElement(\"br\",null),React.createElement(\"p\",null,\"Since props are passed in, and they cannot change, if a React component that only uses props as \\u201Cpure,\\u201D that is, it will always render the same output given the same input. \"),React.createElement(\"h3\",null,\"Render Props\"),React.createElement(\"p\",null,\"A render prop is a way to pass a template to a component which should be used while rendering, on the fly.\"),React.createElement(\"b\",null,\"Props\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Props are read-only, Whether you declare a component as a function or a class, it must never modify its own props.\"),React.createElement(\"li\",null,\"All React components must act like pure functions w.r.t their props.\")),React.createElement(\"br\",null),React.createElement(\"p\",null,\"Props prints the name of the user depending on the props that were passed to it. Here, the name of the prop will be name\"),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"12. Lazy Loading\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"We bundle the files in React application using tool such as webpack. Bundling in the end merges the files in the sequence of their imports and creates a single file.\"),React.createElement(\"li\",null,\"The problem with this approach is that the bundle file gets larger with the increase in files. User may not be sung all the feature components but still bundle is loading them, this could affect the loading of application.\")),React.createElement(\"br\",null),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:Lazy,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"13. When might you use React.PureComponent?\"),React.createElement(\"p\",null,\"When we want a default implementation of shouldComponentUpdate()\"),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"14. What is the children prop?\"),React.createElement(\"p\",null,\"A property that lets you pass components as data to other components\"),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"15. What is prop drilling and how can you avoid it?\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"When building a React application, there is often the need for a deeply nested component to use data provided by another component that is much higher in the hierarchy. The simplest approach is to simply pass a prop from each component to the next in the hierarchy from the source component to the deeply nested component. This is called prop drilling.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"The primary disadvantage of prop drilling is that components that should not otherwise be aware of the data become unnecessarily complicated and are harder to maintain.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"To avoid prop drilling, a common approach is to use React context. This allows a Provider component that supplies data to be defined, and allows nested components to consume context data via either a Consumer component or a useContext hook.\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"17. Controlled component\"),\"We have 2 ways to handle the input value: Controlled & Uncontrolled\",React.createElement(\"p\",null,\"In a controlled component, form data is handled by a React component. While in uncontroll, form data is handled by the DOM itself.\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"In a controlled component, the form data is handled by the state within the component.\"),React.createElement(\"li\",null,\"The controlled component is a way that can handle the form input value using the state and to change the input value by using setState or useState\"),React.createElement(\"li\",null,\"Change this state using one of the events like onChange and when the user starts writing any character setState or useState will be called and update the state of this input then it will add the new value inside the input.\")),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Uncontrolled Components\"),React.createElement(\"br\",null),React.createElement(\"p\",null,\"The uncontrolled component is like traditional HTML form inputs that you will not be able to handle the value by yourself but the DOM will take care of handling the value of the input and save it then you can get this value using React Ref\"),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:Uncontrolled,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Use the controlled component when you create\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Form validation so you always need to know the value of the input when typing to check if it\\u2019s a valid character or not!\"),React.createElement(\"li\",null,\"Disable the submit button unless all fields have valid data\"),React.createElement(\"li\",null,\"If you have a specific format like the credit card input\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"18. Force Update\"),\"Calling forceUpdate() will cause render() to be called on the component and skip shouldComponentUpdate().\",React.createElement(\"br\",null),\"It will skip shouldComponentUpdate(), so you're not getting the optimization benefit.\",React.createElement(\"br\",null),\"Also, using forceUpdate() \\\"bypasses\\\" the proper lifecycle, making your code less straight-forward and possibly harder to understand and maintain.\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:Update,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"19. Lifecycle of Components\"),\"Each component in React has a lifecycle which you can monitor and manipulate during its three main phases.\",React.createElement(\"br\",null),\"1. Mounting\",React.createElement(\"br\",null),\"2. Updating and\",React.createElement(\"br\",null),\"3. Unmounting\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Mounting: \"),\"Mounting means putting elements into the DOM.\",React.createElement(\"br\",null),\"React has four built-in methods that gets called, in this order, when mounting a component:\",React.createElement(\"br\",null),React.createElement(\"br\",null),\"1. constructor()\",React.createElement(\"br\",null),\"3. \",React.createElement(\"b\",null,\"render():\"),\"  required and will always be called, the others are optional and will be called if you define them.\",React.createElement(\"br\",null),\"4. componentWillMount()\",React.createElement(\"br\",null),\"4. componentDidMount()\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"constructor(): \"),\"Is called before anything else, when the component is initiated, and it is the natural place to set up the initial state and other initial values.\",React.createElement(\"br\",null),React.createElement(\"br\",null),\"The constructor() method is called with the props, as arguments, and you should always start by calling the super(props) before anything else, this will initiate the parent's constructor method and allows the component to inherit methods from its parent.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"componentDidMount: \"),\"Method is called after the component is rendered.\",React.createElement(\"br\",null),\"This is where you run statements that requires that the component is already placed in the DOM.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Updating: \"),\"A component is updated whenever there is a change in the component's state or props.\",React.createElement(\"br\",null),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"shouldComponentUpdate()\"),React.createElement(\"li\",null,\"render()\"),React.createElement(\"li\",null,\"componentDidUpdate()\")),React.createElement(\"br\",null),React.createElement(\"b\",null,\"shouldComponentUpdate: \"),\"In the shouldComponentUpdate() we can return a Boolean value that specifies whether React should continue with the rendering or not.\",React.createElement(\"br\",null),React.createElement(\"b\",null,\"The default value is true.\"),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"render:\"),\"Method is called when a component gets updated, it has to re-render the HTML to the DOM, with the new changes.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"componentDidUpdate: \"),\"The componentDidUpdate method is called after the component is updated in the DOM.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Unmounting: \"),\"componentWillUnmount:\",React.createElement(\"br\",null),\"This method is called when the component is about to be removed from the DOM.\",React.createElement(\"br\",null),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:code,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"p\",null,\"This method is called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component. \"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"b. componentDidCatch\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"20. Event\"),React.createElement(\"p\",null,\"In React, events are the triggered reactions to specific actions like mouse hover, mouse click, key press, etc.\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"1. Events are passed as functions instead of strings. \"),React.createElement(\"li\",null,\"2. The event argument contains a set of properties, which are specific to an event. Each event type contains its own properties and behavior which can be accessed via its event handler only.\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"21. What are synthetic events in React?\"),React.createElement(\"p\",null,\"Synthetic events are the objects which act as a cross-browser wrapper around the browser\\u2019s native event. They combine the behavior of different browsers into one API. This is done to make sure that the events show consistent properties across different browsers.\"),React.createElement(\"b\",null,\"Ex. \"),\"preventDefault\",React.createElement(\"br\",null)))));}}]);return IntroRectJs;}(Component);export default withStyles(styles)(IntroRectJs);","map":{"version":3,"sources":["/home/mukeshs/Projects/edurights/src/components/ReactJs/reactJs_hooks/introReact.js"],"names":["React","Component","Prism","Grid","Paper","withStyles","List","Sidebar","PrismCode","Tools","Tools2","VDom","titles","backgroundColor","padding","fontSize","redesign","height","redesigns","width","styles","theme","paper","margin","spacing","smMargin","actionDiv","textAlign","call","trim","newStates","returnSynchronous","Lazy","Uncontrolled","Update","code","IntroRectJs","setTimeout","highlightAll","classes","props"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport Prism from \"prismjs\"\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\n\nimport '../../dashboard/blog/styles.css'\nimport Sidebar from '../sidebar';\nimport PrismCode from '../prismCode';\n\nimport Tools from \"../../../assets/js/jsToolchain.png\";\nimport Tools2 from \"../../../assets/js/jsToolchain_2.png\";\nimport VDom from \"../../../assets/js/vDom.png\";\n\n\nconst titles = { backgroundColor: '#F0F8FF', padding: '1px', fontSize: '16px' }\n\nconst redesign = {\n  height: 350,\n}\n\nconst redesigns = {\n  height: 350,\n  width: 600\n}\n\nconst styles = theme => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1)\n  },\n  smMargin: {\n    margin: theme.spacing(1)\n  },\n  actionDiv: {\n    textAlign: \"center\"\n  }\n})\n\nconst call = `\n// assuming this.state = { value: 0 }\nthis.setState({ value: 1 });\nconsole.log(this.state.value); // 0\n`.trim();\n\nconst newStates = `\n// assuming this.state = { value: 0 };\nthis.setState((state) => ({ value: state.value + 1}));\nthis.setState((state) => ({ value: state.value + 1}));\nthis.setState((state) => ({ value: state.value + 1}));`.trim();\n\nconst returnSynchronous = `\nrender() {\n  return <button onClick={this.inc}>Click to update</button>\n}\n\ninc() {\n  console.log('before: ' + this.state.test);\n  this.setState({\n    test: this.state.test+1\n  });\n  console.log('after: ' + this.state.test);\n}\n\n// click!\nbefore: 1\nafter: 1\n\n// click!\nbefore: 2\nafter: 2`.trim();\n\nconst Lazy = `\nimport React, { Suspense, lazy } from 'react';\nconst OtherComponent = lazy(() => import('./OtherComponent'));\n\nconsr Routes = () => (\n  <Switch>\n   <Suspense fallback={<div>Loading Page...</div>}>\n    <Route path = \"/login\" component={Login} />\n    <Route exact path = \"Home\" component={Home} />\n   </Suspense>\n    <Route component={()=> <h1>Page not found</h1>} />\n  </Switch>`.trim();\n\nconst Uncontrolled = `\nfunction App() {\n  const inputRef = useRef(null);\n  \n  const handleSubmitButton = () => {\n    alert(inputRef.current.value);\n  };\n  return (\n    <div className=\"App\">\n      <input type=\"text\" ref={inputRef} />\n      <input type=\"submit\" value=\"submit\" onClick={handleSubmitButton} />\n    </div>\n  );\n}`.trim();\n\nconst Update = `\nclass App extends Component{\n  forceUpdateHandler = () => {\n    this.forceUpdate();\n  };\n  \n  render(){\n    return(\n      <div>\n        <button onClick= {this.forceUpdateHandler} >FORCE UPDATE</button>\n        <h4>Random Number : { Math.random() }</h4>\n      </div>\n    );\n  }\n}`.trim();\n\nconst code = `\nclass App extends Component{\n  constructor(){\n      super();\n      this.state={count:0}\n  }\n\n  componentDidMount(){\n      console.log('When component render first time')\n  }\n\n  increment(){\n      this.setState({count:this.state.count + 1})\n  }\n\n  componentDidUpdate(prevProps, prevState){\n      console.log(prevState.count)\n      if(prevState.count !=this.state.count){\n          console.log('component update')\n      }\n  }\n\n  componentWillUnmount(){\n      console.log('countis about to be unmounted.')\n  }\n\n  render(){\n      return(\n          <div>\n              {this.state.count}\n              {/* <button onClick={this.increment.bind(this)}>bindThis</button> */}\n              <button onClick={()=>this.increment()}>clickMe</button>\n          </div>\n      )\n  }\n}\n\n\n//functional component\nconst App = () => {\n  const [count, setCount] = useState(0);\n\n  useEffect(()=>{\n      console.log('Mounting')\n      console.log('Updating', count)\n\n      return ()=>{\n          console.log('Unmount')\n      }\n  },[count])\n\n  const increment = () => {\n      setCount(count+1)\n  }\n\n      return(\n          <div>\n              {count}\n              <button onClick={increment}>clickMe</button>\n          </div>\n      )\n  }\n`.trim();\n\n\n\n\nclass IntroRectJs extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0)\n  }\n  render() {\n    const { classes } = this.props;\n    return (\n      <Grid container>\n        <Grid item xs={2}>\n          <h4><Sidebar /></h4>\n        </Grid>\n        <Grid item xs={10}>\n          <Paper className={classes.paper}>\n            <List>\n\n              <h3>1.Explain the standard JavaScript toolchain, transpilation, JSX, and these items.\n                What tools use in the build steps to optimize the compiled output React code?</h3>\n              <br />\n              <img src={Tools} alt=\"Omega\" className=\"responsive\" style={redesign} />\n              <img src={Tools2} alt=\"Omega\" className=\"responsive\" style={redesign} />\n              <br />\n              <br />\n\n              <p>\n                <b>There are a couple primary pillars in the JavaScript toolchain:</b>\n              </p>\n              <ul>\n                <li>1. Dependency Management</li>\n                <li>2. Linting</li>\n                <li>3. Style-checking</li>\n                <li>4. Transpilation and Compilation</li>\n                <li>5. Minification and Compression</li>\n                <li>6. Source-Mapping</li>\n              </ul>\n              <br />\n\n              <h3>2. How Virtual-DOM is more efficient than Dirty checking</h3>\n              <img src={VDom} alt=\"Omega\" className=\"responsive\" style={redesigns} />\n              <p>\n                In React, each of our components have a state. This state is like an observable. Essentially, React\n                knows when to re-render the scene because it is able to observe when this data changes. Dirty checking\n                is slower than observables because we must poll the data at a regular interval and check all of the\n                values in the data structure recursively.\n              </p>\n\n              <b>Virtual DOM: </b>Virtual DOM is about avoiding unnecessary changes to the dom. \n              Virtual DOM also allows to collect several changes to \n              be applied at once, so not every single change causes a re-render, but instead re-rendering only happens once after a set \n              of changes was applied to the DOM.\n              <br/>\n              <br/>\n              A virtual DOM is a lightweight JS object. It is simply a copy of the real DOM.\n              <br />\n              <br />\n              <b>Virtual DOM operates in three simple steps:</b>\n              <ul>\n                <li>1. The entire UI is re-rendered in Virtual DOM representation as data changes.</li>\n                <li>2. Now, the difference between the previous DOM representation and the new one is calculated.</li>\n                <li>3. After the calculations are successfully, the real DOM is updated in line\n                  with only the things that actually underwent changes.</li>\n              </ul>\n              <br />\n\n              <h3>How does the Real DOM differ from the Virtual DOM: </h3>\n              <ul>\n                <li><b>DOM Manipulation: </b>Real DOM supports a very expensive DOM manipulation.</li>\n                <li><b>Element Update: </b>Real DOM creates a new DOM when an element updates. While, virtual DOM updates the JSX.</li>\n                <li><b>Memory Wastage: </b>Real DOM causes a lot of memory wastage while there is no memory\n              wastage for Virtual DOM.</li>\n                <li><b>Update Speed: </b>Real DOM updates slowly.</li>\n                <li><b>Updating HTML: </b>Real DOM can directly update HTML, while virtual DOM can’t update HTML directly.</li>\n              </ul>\n              <br />\n              \n              <h3>3. What do you understand with the term polling?</h3>\n              <p>\n                The server needs to be monitored for updates w.r.t.time.\n                This process is basically considered as pooling. It checks for the updates approximately after every 5 seconds.\n                Poling make sure that no negative information is present on the servers.\n              </p>\n\n              <h3>4. Difference between redux saga and redux thunk.</h3>\n              Use Thunk instead of Saga for simple and trivial tasks like:\n              <ul>\n                <li>AJAX calls</li>\n                <li>data polling and only if they are started directly by the user interaction.</li>\n              </ul>\n              <br />\n              <b>Use Saga for</b>\n              <ul>\n                <li>intertwined tasks, Ex login example of the docs.</li>\n                <li>flows with a lot of steps and waitings for other conditions to happen (\"finite-state machine\" flows)</li>\n                <li>tasks that work in the background and proceed independently from the user interaction (or a mix of background/interactions)</li>\n              </ul>\n              <br />\n\n              <h3>5. What is React? What are some of its standouts?</h3>\n              Writing UI test cases is simple with React, which is also easy to integrate with Angular,\n              Meteor, and other popular JS frameworks.\n              <ul>\n                <li>Excellent for developing complex and interactive web and mobile UI</li>\n                <li>Follows the component-based approach and helps in building reusable UI components</li>\n                <li>Makes use of the virtual DOM instead of the real DOM</li>\n                <li>Relies on server-side rendering</li>\n                <li>Supports unidirectional data flow or data binding</li>\n              </ul>\n\n              <br />\n              <b>Note: </b>JSX is a contraction of the JavaScript and XML.\n              <br />\n              <br />\n\n              <h3>6. HOC</h3>\n              A higher-order component (HOC) is a function that takes a component as input and returns a new component with enhanced functionality. It allows for code reuse, abstraction, and the addition of new features to existing components in a flexible and composable manner.\n              <br/>\n              <br/>\n              <b>Benefits of HOC: </b>\n              <ul>\n                <li>Reuse of Code.</li>\n                <li>Offers a high hacking facility</li>\n                <li>Supports state abstraction and manipulation</li>\n              </ul>\n              <br/>\n\n              <h3>7. Define Reducers in React?</h3>\n              Reducers are functions that specify how the application's state should change in response to different actions.\n              <br/>\n              <h3>State</h3>\n              state refers to the data that represents the current state of a component. It determines how the component appears and behaves at a given point in time. State is used to store and manage dynamic information within a component.\n              <br/>\n              \n              <h3>8. When would you use state</h3>\n              When a component needs to keep track of information between renderings the component itself update, use state.\n              <p>\n                Component state is a way of holding, processing information and allows to implement its logic.\n                State is usually a POJO (Plain Old JavaScript Object).</p>\n              <ul>\n                <li>using this.setState, accept an Object that will be eventually merged into Components current state.</li>\n                <li>To alter state by writing to this.state directly, it will not lead to the Component re-rendering\n                  with new data, and generally lead to state inconsistency.</li>\n              </ul>\n              <br />\n              <b>setState is asynchronous (*)</b>\n              <br />\n              <p>The setState causes reconciliation is base of the next property — setState is asynchronous. This\n                allows us to have multiple calls to setState in a single scope and not trigger not\n                needed re-renders of the whole tree.</p>\n              This is why you don’t see the new values in state right after you updated it.\n              <div style={titles}>\n                <PrismCode\n                  code={call}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <br />\n\n              <b>setState accepts a function as its parameter</b><br/>\n              <p>If you pass a function as the first argument of setState, React will\n                call it with the at-call-time-current state and expect you to return an\n                Object to merge into state. So updating our example above to:</p>\n              <div style={titles}>\n                <PrismCode\n                  code={newStates}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <i>Will give us this.state.value = 3</i>\n              <br />\n\n              <h3>9. setState is … synchronous?</h3>\n              <p>setState is asynchronous? Well, it not always the case! It depends on the execution context.</p>\n              <div style={titles}>\n                <PrismCode\n                  code={returnSynchronous}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <br />\n\n              <b>Is setState() is async? Props should not change. Why is setState() in React Async instead of Sync?</b>\n              <br />\n              <ul>\n                <li>setState() actions are asynchronous and are batched for performance gains. setState() does not immediately mutate\n                  this.state but creates a pending state transition. Accessing this.state after calling this method can potentially\n                  return the existing value.</li>\n                <li>There is no guarantee of synchronous operation of calls to setState and calls may be\n                  batched for performance gains. This is because setState alters the state and causes rerendering. </li>\n                <li>Thus the setState calls are asynchronous as well as batched for better UI experience and performance.</li>\n              </ul>\n              <br />\n\n              <h3>10. Why can't you update state directly without setState()?.</h3>\n              <ul>\n                <li>setState alwase trigger re-rendering of the component.</li>\n                <li>Mutating state directly can lead to odd bugs, and components that are hard to optimize.</li>\n              </ul>\n              <br />\n\n              <h3>11. Props should not change</h3>\n              You used to be able to change props with setProps and replaceProps but these have been deprecated.\n              <br />\n              <p>Since props are passed in, and they cannot change, if a React\n                component that only uses props as “pure,” that is, it will always\n                render the same output given the same input. </p>\n              <h3>Render Props</h3>\n              <p>A render prop is a way to pass a template to a component which should be used\n                while rendering, on the fly.</p>\n\n              <b>Props</b>\n              <ul>\n                <li>Props are read-only, Whether you declare a component as a function or a class, it must never modify its own props.</li>\n                <li>All React components must act like pure functions w.r.t their props.</li>\n              </ul>\n              <br />\n              <p>\n                Props prints the name of the user depending on the props that were passed to it.\n                Here, the name of the prop will be name\n              </p>\n            <br />\n\n            <h3>12. Lazy Loading</h3>\n            <ul>\n              <li>We bundle the files in React application using tool such as webpack. Bundling in the end merges the files in the\n            sequence of their imports and creates a single file.</li>\n              <li>The problem with this approach is that the bundle file gets larger with the increase in files. User may not be sung\n            all the feature components but still bundle is loading them, this could affect the loading of application.</li>\n            </ul>\n            <br />\n            <div style={titles}>\n              <PrismCode\n                code={Lazy}\n                language=\"js\"\n                plugins={[\"line-numbers\"]}\n              />\n            </div>\n            <br />\n\n            <h3>13. When might you use React.PureComponent?</h3>\n            <p>When we want a default implementation of shouldComponentUpdate()</p>\n            <br />\n\n            <h3>14. What is the children prop?</h3>\n            <p>A property that lets you pass components as data to other components</p>\n            <br />\n\n            <h3>15. What is prop drilling and how can you avoid it?</h3>\n              <ul>\n                <li>When building a React application, there is often the need for a deeply nested component to use data provided \n                  by another component that is much higher in the hierarchy. The simplest approach is to simply pass a prop from \n                  each component to the next in the hierarchy from the source component to the deeply nested component. This is \n                  called prop drilling.</li><br/>\n                <li>The primary disadvantage of prop drilling is that components that should not otherwise be aware of the data \n                  become unnecessarily complicated and are harder to maintain.</li><br/>\n                <li>To avoid prop drilling, a common approach is to use React context. This allows a Provider component that \n                  supplies data to be defined, and allows nested components to consume context data via either a Consumer \n                  component or a useContext hook.</li>\n              </ul>\n              <br/>\n\n              <h3>17. Controlled component</h3>\n              We have 2 ways to handle the input value: Controlled & Uncontrolled\n              <p>In a controlled component, form data is handled by a React component. While in uncontroll, form data is handled \n                by the DOM itself.</p>\n              <ul>\n                <li>In a controlled component, the form data is handled by the state within the component.</li>\n                <li>The controlled component is a way that can handle the form input value using the state and to change the input \n                  value by using setState or useState</li>\n                <li>Change this state using one of the events like onChange and when the user starts writing any character \n                  setState or useState will be called and update the state of this input then it will add the new value inside \n                  the input.</li>\n              </ul>\n              <br />\n\n              <b>Uncontrolled Components</b>\n              <br />\n              <p>The uncontrolled component is like traditional HTML form inputs that you will not be able to handle the value by yourself but the DOM will take care of handling the value of the input and save it then you can get this value using React Ref</p>\n\n              <div style={titles}>\n                <PrismCode\n                  code={Uncontrolled}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <br />\n              <b>Use the controlled component when you create</b>\n              <ul>\n                <li>Form validation so you always need to know the value of the input when typing to check if it’s a valid character or not!</li>\n                <li>Disable the submit button unless all fields have valid data</li>\n                <li>If you have a specific format like the credit card input</li>\n              </ul>\n              <br/>\n\n              <h3>18. Force Update</h3>\n              Calling forceUpdate() will cause render() to be called on the component and skip shouldComponentUpdate().<br />\n              It will skip shouldComponentUpdate(), so you're not getting the optimization benefit.<br />\n              Also, using forceUpdate() \"bypasses\" the proper lifecycle, making your code less straight-forward and possibly harder to understand and maintain.\n              <div style={titles}>\n                <PrismCode\n                  code={Update}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>19. Lifecycle of Components</h3>\n              Each component in React has a lifecycle which you can monitor and manipulate during its\n              three main phases.\n              <br />\n              1. Mounting<br />\n              2. Updating and<br />\n              3. Unmounting<br />\n              <br />\n              <b>Mounting: </b>Mounting means putting elements into the DOM.\n              <br />\n              React has four built-in methods that gets called, in this order, when mounting a component:\n              <br />\n              <br />\n              1. constructor()<br />\n              3. <b>render():</b>  required and will always be called, the others are optional and will be called if you define them.<br />\n              4. componentWillMount()<br />\n              4. componentDidMount()<br />\n\n              <br />\n              <br />\n              <b>constructor(): </b>Is called before anything else, when the component is initiated,\n              and it is the natural place to set up the initial state and other initial values.\n              <br />\n              <br />\n              The constructor() method is called with the props, as arguments, and you should always start\n              by calling the super(props) before anything else, this will initiate the parent's constructor\n              method and allows the component to inherit methods from its parent.\n              <br />\n              <br />\n              <b>componentDidMount: </b>Method is called after the component is rendered.\n              <br />\n              This is where you run statements that requires that the component is already placed in the\n              DOM.\n              <br />\n              <br />\n              <b>Updating: </b>\n              A component is updated whenever there is a change in the component's state or props.\n              <br />\n              <ul>\n                <li>shouldComponentUpdate()</li>\n                <li>render()</li>\n                <li>componentDidUpdate()</li>\n              </ul>\n              <br />\n\n              <b>shouldComponentUpdate: </b>\n              In the shouldComponentUpdate() we can return a Boolean value that specifies whether\n              React should continue with the rendering or not.\n              <br />\n              <b>The default value is true.</b>\n              <br />\n              <br />\n\n              <b>render:</b>\n              Method is called when a component gets updated, it has to re-render\n              the HTML to the DOM, with the new changes.\n              <br />\n              <br />\n\n              <b>componentDidUpdate: </b>\n              The componentDidUpdate method is called after the component is updated in the DOM.\n              <br />\n              <br />\n              <b>Unmounting: </b>\n              componentWillUnmount:\n              <br />\n              This method is called when the component is about to be removed from the\n              DOM.\n              <br />\n              <div style={titles}>\n                <PrismCode\n                  code={code}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <p>This method is called when there is an error during rendering, in a lifecycle method, or in the constructor of any\n                child component. </p>\n              <ul>\n                <li>b. componentDidCatch</li>\n              </ul>\n              <br />\n\n              <h3>20. Event</h3>\n              <p>\n                In React, events are the triggered reactions to specific actions like mouse hover, mouse click, key press, etc.\n              </p>\n              <ul>\n                <li>1. Events are passed as functions instead of strings. </li>\n                <li>\n                  2. The event argument contains a set of properties, which are specific to an event. Each event type contains its own\n                  properties and behavior which can be accessed via its event handler only.\n                </li>\n              </ul>\n              <br />\n\n              <h3>21. What are synthetic events in React?</h3>\n              <p>\n                Synthetic events are the objects which act as a cross-browser wrapper around the browser’s native event. They combine\n                the behavior of different browsers into one API. This is done to make sure that the events show consistent properties\n                across different browsers.\n              </p>\n              <b>Ex. </b>preventDefault\n              <br />\n            </List>\n          </Paper>\n        </Grid>\n      </Grid>\n    )\n  }\n}\n\nexport default (withStyles(styles)(IntroRectJs));\n"]},"metadata":{},"sourceType":"module"}