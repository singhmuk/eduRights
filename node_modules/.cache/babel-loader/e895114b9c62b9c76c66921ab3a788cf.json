{"ast":null,"code":"var _jsxFileName = \"/home/mukeshs/Projects/edurights/src/components/algorithams/deepAlgorithams/trees.js\";\nimport React, { Component } from 'react';\nimport Prism from \"prismjs\";\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\nimport '../../ReactJs/styles.css';\nimport Sidebar from '../sidebar';\nimport PrismCode from '../../ReactJs/prismCode';\nimport Stcksval from '../../../assets/stcks.png';\nconst titles = {\n  backgroundColor: '#F0F8FF',\n  padding: '1px',\n  fontSize: '16px'\n};\nconst redesign = {\n  height: 200,\n  width: 500\n};\n\nconst styles = theme => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1)\n  },\n  smMargin: {\n    margin: theme.spacing(1)\n  },\n  actionDiv: {\n    textAlign: \"center\"\n  }\n});\n\nconst insertData = `\nfunction Nodes(data, left, right){\n  this.data=data;\n  this.left=left;\n  this.right=right;\n  this.show=show;\n}\n\nfunction show(){\n  return this.data;\n}\n\nfunction bst(){\n  this.root=null;\n  this.insert=insert;\n}\n\nfunction insert(data){\n  const node=new Nodes(data,null,null)\n  if(this.root === null){\n    this.root=node;\n  }else{\n    var current=this.root;\n    var parrent;\n    while(current){\n      parrent=current;\n      if(data < current.data){\n        current=current.left;\n        if(current === null){\n          parrent.left=node;\n        }\n      }else{\n        current = current.right;\n        if(current === null){\n          parrent.right = node;\n        }\n      }\n    }\n  }\n}\n\nconst obj= new bst();\nobj.insert(3)\nobj.insert(5)\nobj.insert(2)\nobj.insert(7)\nobj.insert(1)\n\nconsole.log(obj.root)`.trim();\nconst traversing = `\nfunction Nodes(data, left, right){\n  this.data=data;\n  this.left=left;\n  this.right=right;\n  this.show=show;\n}\n\nfunction show(){\n  return this.data;\n}\n\nfunction bst(){\n  this.root=null;\n  this.insert=insert;\n}\n\nfunction insert(data){\n  const node=new Nodes(data,null,null)\n  if(this.root === null){\n    this.root=node;\n  }else{\n    var current=this.root;\n    var parrent;\n    while(current){\n      parrent=current;\n      if(data < current.data){\n        current=current.left;\n        if(current === null){\n          parrent.left=node;\n        }\n      }else{\n        current = current.right;\n        if(current === null){\n          parrent.right = node;\n        }\n      }\n    }\n  }\n}\n\nfunction inOrder(node){\n  if(!(node==null)){\n    inOrder(node.left);\n    console.log(node.show()+ \" \")\n    inOrder(node.right)\n  }\n}\n\nfunction preOrder(node) {\n  if (node !== null) {\n    console.log(node.show() + \" \");\n    preOrder(node.left);\n    preOrder(node.right);\n  }\n}\n\nfunction postOrder(node) {\n  if (node !== null) {\n    postOrder(node.left);\n    postOrder(node.right);\n    console.log(node.show() + \" \");\n  }\n}\n\nconst obj= new bst();\nobj.insert(3)\nobj.insert(5)\nobj.insert(2)\nobj.insert(7)\nobj.insert(1)\n\nconsole.log(obj.root)\n\nconsole.log('Inorder Traversal')\ninOrder(obj.root)\n\nconsole.log('Pre-Order Traversal');\npreOrder(obj.root);\n\nconsole.log('Post-Order Traversal');\npostOrder(obj.root);`.trim();\nconst deleteNode = `\nfunction Node(data,left,right){\n  this.data=data;\n  this.left=left;\n  this.right=right;\n  this.show=show;\n}\n\nfunction show(){\n  return this.data;\n}\n\nfunction bst(){\n  this.root=null;\n  this.insert=insert;\n}\n\nfunction insert(data){\n  const node=new Node(data,null,null);\n\n  if(this.root===null){\n    this.root=node;\n  }else{\n    var current=this.root;\n    var parent;\n\n    while(current){\n      parent=current;\n      if(data < current.data){\n        current=current.left;\n        if(current === null){\n          parent.left = node;\n        }\n      }else{\n        current = current.right;\n        if(current === null){\n          parent.right = node;\n        }\n      }\n    }\n  }\n}\n\nfunction inOrder(node){\n  if(!(node === null)){\n    inOrder(node.left)\n    console.log(node.show())\n    inOrder(node.right)\n  }\n}\n\nfunction deleteNode(root, key){\n  if(root === null){\n    return root;\n  }\n\n  if(key < root.data){\n    root.left = deleteNode(root.left, key)\n  }else if(key > root.data){\n    root.right = deleteNode(root.right, key)\n  }else {\n    if(root.left === null){\n      return root.right;\n    }else if(root.right === null){\n      return root.right;\n    }\n  }\n  return root;\n}\n\nconst obj = new bst()\nobj.insert(5)\nobj.insert(6)\nobj.insert(1)\nobj.insert(2)\nobj.insert(3)\n\ninOrder(obj.root)\n\nobj.root = deleteNode(obj.root, 6)\nconsole.log('After Deleting')\ninOrder(obj.root)`.trim();\nconst updates = `\nfunction Node(data,left,right){\n  this.data=data;\n  this.left=left;\n  this.right=right;\n  this.show=show;\n}\n\nfunction show(){\n  return this.data;\n}\n\nfunction bst(){\n  this.root=null;\n  this.insert=insert;\n}\n\nfunction insert(data){\n  const node=new Node(data,null,null)\n  if(this.root===null){\n    this.root=node;\n  }else{\n    var current=this.root;\n    var parrent;\n    while(current){\n      parrent=current;\n      if(data<current.data){\n        current=current.left;;\n        if(current===null){\n          parrent.left=node;\n        }\n      }else{\n        current=current.right;\n        if(current===null){\n          parrent.right=node;\n        }\n      }\n    }\n  }\n}\n\nfunction inOrder(root){\n  if(!(root===null)){\n    inOrder(root.left)\n    console.log(root.show())\n    inOrder(root.right)\n  }\n}\n\nfunction updateNode(node, target, newValue) {\n  if (node === null) {\n    return null;                                // Target node not found\n  }\n\n  if (target < node.data) {\n    node.left = updateNode(node.left, target, newValue);\n  } else if (target > node.data) {\n    node.right = updateNode(node.right, target, newValue);\n  } else {\n    node.data = newValue;                       // Found the target node, update its data\n  }\n\n  return node;\n}\n\nconst obj=new bst()\nobj.insert(4)\nobj.insert(1)\nobj.insert(2)\nobj.insert(3)\n\ninOrder(obj.root)\n\nconsole.log('Update Node');\nobj.root = updateNode(obj.root, 4, 10);\ninOrder(obj.root);\n`.trim(); // const traversing = ``.trim()\n\nconst generateTrees = `\nfunction Node(val, left, right) {\n  this.val = val;\n  this.left = left || null;\n  this.right = right || null;\n}\n\nfunction generateTrees(n) {\n  if (n === 0) return [];\n\n  // Helper function to generate BSTs recursively\n  function generateBST(start, end) {\n    if (start > end) return [null];\n    const result = [];\n\n    for (let i = start; i <= end; i++) {\n      const leftSubtrees = generateBST(start, i - 1);\n      const rightSubtrees = generateBST(i + 1, end);\n\n      for (const leftTree of leftSubtrees) {\n        for (const rightTree of rightSubtrees) {\n          const root = new Node(i);\n          root.left = leftTree;\n          root.right = rightTree;\n          result.push(root);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  return generateBST(1, n);\n}\n\nfunction preOrder(node) {\n  if (node !== null) {\n    console.log(node.val);\n    preOrder(node.left);\n    preOrder(node.right);\n  }\n}\n\nconst obj = generateTrees(3);\n\nfor (const tree of obj) {\n  preOrder(tree);\n  console.log('---');\n}\n\n\n//2\nfunction TreeNode(val) {\n  this.val = val\n  this.left = null\n  this.right = null\n}\n\nconst generateTrees = (n) => {\n  if (n === 0) return [];\n\n  const numbers = new Array(n).fill(0).map((v, index) => index + 1)\n  const memo = {}\n\n  const compose = (number, left, right) => {\n    const result = []\n    for (let i = 0; i < left.length; i++) {\n      for (let j = 0; j < right.length; j++) {\n            const node = new TreeNode(number)\n            node.left = left[i]\n            node.right = right[j]\n            result.push(node)\n          }\n        }\n        return result\n      }\n\n  const aux = (list = []) => {\n    const key = list.toString()\n    if (memo[key] !== undefined) {\n      return memo[list.toString()]\n    }\n\n    if (list.length === 0) return [null]\n\n    memo[key] = list.reduce((acc, number) => {\n        acc.push(...compose(number, aux(list.filter(x => x < number)), aux(list.filter(x => x > number)),\n          ),\n        )\n        return acc\n      },\n      [],\n    )\n    return memo[key]\n  }\n  \n  return aux(numbers)\n}\n\nconsole.log(generateTrees(3))\n`.trim();\nconst isValidBST = `\nfunction Nodes(data, left, right) {\n  this.data = data;\n  this.left = left;\n  this.right = right;\n  this.show = show;\n}\n\nfunction show() {\n  return this.data;\n}\n\nfunction bst() {\n  this.root = null;\n  this.insert = insert;\n  this.isValidBST = isValidBST; \n}\n\nfunction insert(data) {\n  const node = new Nodes(data, null, null);\n  if (this.root === null) {\n    this.root = node;\n  } else {\n    let current = this.root;\n    let parent;\n    while (current) {\n      parent = current;\n      if (data < current.data) {\n        current = current.left;\n        if (current === null) {\n          parent.left = node;\n        }\n      } else {\n        current = current.right;\n        if (current === null) {\n          parent.right = node;\n        }\n      }\n    }\n  }\n}\n\nfunction inOrder(node) {\n  if (!(node == null)) {\n    inOrder(node.left);\n    console.log(node.show() + \" \");\n    inOrder(node.right);\n  }\n}\n\nfunction isValidBST(node, min = null, max = null) {\n  if (node === null) return true;\n\n  if ((min !== null && node.data <= min) || (max !== null && node.data >= max)) {\n    return false;\n  }\n\n  return (\n    isValidBST(node.left, min, node.data) && isValidBST(node.right, node.data, max)\n  );\n}\n\nconst obj = new bst();\nobj.insert(3);\nobj.insert(5);\nobj.insert(2);\nobj.insert(7);\nobj.insert(1);\n\ninOrder(obj.root);\n\nconsole.log('Is Valid BST:', obj.isValidBST(obj.root));\n`.trim();\nconst recoverTree = `\nfunction recoverTree(root) {\n  let first = null\n  let second = null\n  let prev = null\n\n  const aux = (node) => {\n    if (node) {\n      aux(node.left)\n      if (prev && prev.val > node.val) {\n        if (!first) {\n          first = prev\n          second = node\n        } else {\n          second = node\n        }\n      }\n      prev = node\n      aux(node.right)\n    }\n  }\n  aux(root)\n\n  if (first && second) {\n    const temp = first.val\n    first.val = second.val\n    second.val = temp\n  }\n}\n\nconsole.log(recoverTree([1,3,null,2]))`.trim();\nconst isSameTree = `\nfunction TreeNode(val, left, right) {\n  this.val = val;\n  this.left = left || null;\n  this.right = right || null;\n}\n\nfunction isSameTree(p, q) {\n  if (!p && !q) return true; \n  if (!p || !q) return false;                     // One of the nodes is null, they are different.\n  if (p.val !== q.val) return false;              // Values are different.\n\n  // Recursively compare left and right subtrees.\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}\n\nfunction buildTreeFromArray(arr) {\n  if (!arr || arr.length === 0) return null;\n\n  const build = (index) => {\n    if (index >= arr.length || arr[index] === null) {\n      return null;\n    }\n    return new TreeNode(arr[index], build(2 * index + 1), build(2 * index + 2));\n  };\n\n  return build(0);\n}\n\nconst tree1Array = [1, 3, null, 2];\nconst tree2Array = [1, 3, null, 2];\n\nconst tree1 = buildTreeFromArray(tree1Array);\nconst tree2 = buildTreeFromArray(tree2Array);\n\nconsole.log(isSameTree(tree1, tree2)); \n`.trim();\nconst isSymmetric = `\nfunction TreeNode(val, left, right) {\n  this.val = val;\n  this.left = left || null;\n  this.right = right || null;\n}\n\nfunction isSymmetric(root) {\n  if (!root) return true;                           // An empty tree is symmetric.\n\n  function isMirror(left, right) {\n    if (!left && !right) return true;               // Both nodes are null, they are mirrors.\n    if (!left || !right) return false;              // One of the nodes is null, they are not mirrors.\n    if (left.val !== right.val) return false; \n\n    // Check if subtrees are mirrors of each other.\n    return isMirror(left.left, right.right) && isMirror(left.right, right.left);\n  }\n\n  // Start by comparing the left and right subtrees.\n  return isMirror(root.left, root.right);\n}\n\nfunction buildTreeFromArray(arr) {\n  if (!arr || arr.length === 0) return null;\n\n  const build = (index) => {\n    if (index >= arr.length || arr[index] === null) {\n      return null;\n    }\n    return new TreeNode(arr[index], build(2 * index + 1), build(2 * index + 2));\n  };\n\n  return build(0);\n}\n\nconst obj = [1, 2, 2, 3, 4, 4, 3];\nconst tree = buildTreeFromArray(obj);\n\nconsole.log(isSymmetric(tree)); \n `.trim();\nconst sortedArrayToBST = `\nfunction sortedArrayToBST (nums = []){\n  const aux = (low, high) => {\n    if (low <= high) {\n      const middle = Math.floor((low + high) / 2)\n      const node = { val: nums[middle] }\n      \n      node.left = aux(low, middle - 1)\n      node.right = aux(middle + 1, high)\n      return node\n    }\n    return null\n  }\n  return aux(0, nums.length - 1)\n}\n\nconsole.log(sortedArrayToBST([3,9,20,null,null,15,7]))\n`.trim();\nconst sortedListToBST = `\nfunction Node(data, left, right) {\n  this.data = data;\n  this.left = left;\n  this.right = right;\n  this.show = show;\n}\n\nfunction show() {\n  return this.data;\n}\n\nfunction bst() {\n  this.root = null;\n  this.insert = insert;\n  this.sortedArrayToBST = sortedArrayToBST;\n}\n\nfunction insert(data) {\n  const node = new Node(data, null, null);\n  if (this.root === null) {\n    this.root = node;\n  } else {\n    let current = this.root;\n    let parent;\n    while (current) {\n      parent = current;\n      if (data < current.data) {\n        current = current.left;\n        if (current === null) {\n          parent.left = node;\n        }\n      } else {\n        current = current.right;\n        if (current === null) {\n          parent.right = node;\n        }\n      }\n    }\n  }\n}\n\nfunction sortedArrayToBST(arr) {\n  this.root = sortedArray(arr, 0, arr.length - 1);\n}\n\nfunction sortedArray(arr, start, end) {\n  if (start > end) {\n    return null;\n  }\n\n  const mid = Math.floor((start + end) / 2);\n  const node = new Node(arr[mid], null, null);\n\n  node.left = sortedArray(arr, start, mid - 1);\n  node.right = sortedArray(arr, mid + 1, end);\n\n  return node;\n}\n\nfunction postOrder(node) {\n  if (node !== null) {\n    postOrder(node.left);\n    postOrder(node.right);\n    console.log(node.show() + \" \");\n  }\n}\n\nconst obj = new bst();\n\nobj.sortedArrayToBST([1, 2, 3, 5, 7]);\npostOrder(obj.root);\n`.trim();\nconst minDepth = `\nfunction Node(data, left, right) {\n  this.data = data;\n  this.left = left;\n  this.right = right;\n}\n\nfunction BST() {\n  this.root = null;\n  this.insert = insert;\n  this.insertArray = insertArray;\n}\n\nfunction insert(data) {\n  const node = new Node(data, null, null);\n  if (this.root === null) {\n    this.root = node;\n  } else {\n    let current = this.root;\n    let parent;\n    while (current) {\n      parent = current;\n      if (data < current.data) {\n        current = current.left;\n        if (current === null) {\n          parent.left = node;\n        }\n      } else {\n        current = current.right;\n        if (current === null) {\n          parent.right = node;\n        }\n      }\n    }\n  }\n}\n\nfunction insertArray(arr) {\n  for (const data of arr) {\n    this.insert(data);\n  }\n}\n\n\nfunction minDepth(root) {\n  let depth = 0;\n  const queue = [root];\n\n  while (queue.length > 0) {\n    depth++;\n    const levelSize = queue.length;\n\n    for (let i = 0; i < levelSize; i++) {\n      const currentNode = queue.shift();\n\n      // If a leaf node is encountered, return the depth.\n      if (currentNode.left === null && currentNode.right === null) {\n        return depth;\n      }\n\n     \n      if (currentNode.left !== null) {                       // Add the child nodes to the queue.\n        queue.push(currentNode.left);\n      }\n      if (currentNode.right !== null) {\n        queue.push(currentNode.right);\n      }\n    }\n  }\n\n  return depth;\n}\n\n\nconst obj = new BST();\nconst sortedArray = [3,9,20,null,null,15,7];\nobj.insertArray(sortedArray);\n\nconst minimumDepth = minDepth(obj.root);\nconsole.log(\"Minimum Depth of Binary Tree:\", minimumDepth);\n\n`.trim();\nconst hasPathSum = `\nfunction hasPathSum (root, sum){\n  function aux (node, currentSum){\n    if (!node) return false;\n\n    if (node && !node.left && !node.right) {\n      return (currentSum + node.val) === sum\n    }\n    const isLeftHas = aux(node.left, currentSum + node.val)\n    const isRightHas = aux(node.right, currentSum + node.val)\n    return (isLeftHas || isRightHas)\n  }\n\n  if (root === null) return false;\n  return aux(root, 0)\n}\n\nconsole.log(hasPathSum([5,4,1],10))\n`.trim();\nconst connect = `\nfunction connect (root){\n  if (!root) return null;\n  let frontier = [root];\n\n  while (frontier.length) {\n    const next = []\n    frontier.forEach((node, index) => {\n      if (frontier[index + 1]) {\n        node.next = frontier[index + 1]\n      } else {\n        node.next = null\n      }\n      if (node.left) {\n        next.push(node.left)\n      }\n      if (node.right) {\n        next.push(node.right)\n      }\n    })\n    frontier = next\n  }\n  return root\n}\n\nconsole.log(connect([1,2,3,4,5,null,7]))\n`.trim();\n\nclass Trees extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0);\n  }\n\n  render() {\n    const {\n      classes\n    } = this.props;\n    return React.createElement(Grid, {\n      container: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 847\n      },\n      __self: this\n    }, React.createElement(Grid, {\n      item: true,\n      xs: 2,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 848\n      },\n      __self: this\n    }, React.createElement(Paper, {\n      className: classes.paper,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 849\n      },\n      __self: this\n    }, React.createElement(\"h4\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 850\n      },\n      __self: this\n    }, React.createElement(Sidebar, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 850\n      },\n      __self: this\n    })))), React.createElement(Grid, {\n      item: true,\n      xs: 10,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 853\n      },\n      __self: this\n    }, React.createElement(Paper, {\n      className: classes.paper,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 854\n      },\n      __self: this\n    }, React.createElement(List, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 855\n      },\n      __self: this\n    }, React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 856\n      },\n      __self: this\n    }, \"Create Tree\"), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 857\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: insertData,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 858\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 864\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 866\n      },\n      __self: this\n    }, \"Traversing\"), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 867\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: traversing,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 868\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 874\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 876\n      },\n      __self: this\n    }, \"Delete\"), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 877\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: deleteNode,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 878\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 884\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 886\n      },\n      __self: this\n    }, \"Update\"), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 887\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: updates,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 888\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 894\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 896\n      },\n      __self: this\n    }, \"1. Unique Binary Search Trees.\"), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 897\n      },\n      __self: this\n    }, \"Input: \"), \"3\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 897\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 898\n      },\n      __self: this\n    }, \"Output: \"), \"[\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 899\n      },\n      __self: this\n    }), \"[1,null,3,2],\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 900\n      },\n      __self: this\n    }), \"[3,2,null,1],\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 901\n      },\n      __self: this\n    }), \"[3,1,null,null,2],\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 902\n      },\n      __self: this\n    }), \"[2,1,3],\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 903\n      },\n      __self: this\n    }), \"[1,null,2,null,3] ]\", React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 906\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: generateTrees,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 907\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 913\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 915\n      },\n      __self: this\n    }, \"2. Validate Binary Search Tree.\"), \"To validate whether a binary tree is a binary search tree (BST), you can use an inorder traversal approach. In a BST, when you traverse the tree in inorder, the values should be in ascending order. If they are not, the tree is not a valid BST.\", React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 919\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: isValidBST,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 920\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 926\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 928\n      },\n      __self: this\n    }, \"3. Recover Binary Search Tree.\"), \"Two elements of a binary search tree (BST) are swapped by mistake.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 930\n      },\n      __self: this\n    }), \"Recover the tree without changing its structure. \", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 931\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 931\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 932\n      },\n      __self: this\n    }, \"Input: \"), \" [3,1,4,null,null,2]\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 932\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 933\n      },\n      __self: this\n    }, \"Output: \"), \" [2,1,4,null,null,3]\", React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 934\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: recoverTree,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 935\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 941\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 943\n      },\n      __self: this\n    }, \"4. Same Tree.\"), \"Given two binary trees, write a function to check if they are the same or not.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 945\n      },\n      __self: this\n    }), \"Two binary trees are considered the same if they are structurally identical and the nodes have the same value.\", React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 947\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: isSameTree,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 948\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 954\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 956\n      },\n      __self: this\n    }, \"5. Symmetric Tree.\"), \"Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\", React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 958\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: isSymmetric,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 959\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 965\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 967\n      },\n      __self: this\n    }, \"6. Convert Sorted Array to Binary Search Tree.\"), \"Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 969\n      },\n      __self: this\n    }), \"For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\", React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 971\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: sortedArrayToBST,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 972\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 978\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 980\n      },\n      __self: this\n    }, \"7. Convert Sorted List to Binary Search Tree.\"), \"Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 982\n      },\n      __self: this\n    }), \"For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 984\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 985\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 986\n      },\n      __self: this\n    }, \"Input: \"), \"head = [-10,-3,0,5,9]\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 986\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 987\n      },\n      __self: this\n    }, \"Output: \"), \"[0,-3,9,-10,null,5]\", React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 988\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: sortedListToBST,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 989\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 995\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 997\n      },\n      __self: this\n    }, \"8. Minimum Depth of Binary Tree.\"), \"The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\", React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 999\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: minDepth,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1000\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1006\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1008\n      },\n      __self: this\n    }, \"9. Path Sum.\"), \"Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\", React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1010\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: hasPathSum,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1011\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1017\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1019\n      },\n      __self: this\n    }, \"10. Populating Next Right Pointers in Each Node.\"), \"Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1021\n      },\n      __self: this\n    }), \"Initially, all next pointers are set to NULL.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1023\n      },\n      __self: this\n    }), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1024\n      },\n      __self: this\n    }, React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1025\n      },\n      __self: this\n    }, \"You may only use constant extra space.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1026\n      },\n      __self: this\n    }, \"Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.\")), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1028\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: connect,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1029\n      },\n      __self: this\n    }))))));\n  }\n\n}\n\nexport default withStyles(styles)(Trees);","map":{"version":3,"sources":["/home/mukeshs/Projects/edurights/src/components/algorithams/deepAlgorithams/trees.js"],"names":["React","Component","Prism","Grid","Paper","withStyles","List","Sidebar","PrismCode","Stcksval","titles","backgroundColor","padding","fontSize","redesign","height","width","styles","theme","paper","margin","spacing","smMargin","actionDiv","textAlign","insertData","trim","traversing","deleteNode","updates","generateTrees","isValidBST","recoverTree","isSameTree","isSymmetric","sortedArrayToBST","sortedListToBST","minDepth","hasPathSum","connect","Trees","componentDidMount","setTimeout","highlightAll","render","classes","props"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport Prism from \"prismjs\"\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\n\nimport '../../ReactJs/styles.css'\nimport Sidebar from '../sidebar';\nimport PrismCode from '../../ReactJs/prismCode';\n\nimport Stcksval from '../../../assets/stcks.png';\n\nconst titles = { backgroundColor: '#F0F8FF', padding: '1px', fontSize: '16px' }\n\nconst redesign = {\n  height: 200,\n  width: 500\n}\n\nconst styles = theme => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1)\n  },\n  smMargin: {\n    margin: theme.spacing(1)\n  },\n  actionDiv: {\n    textAlign: \"center\"\n  }\n})\n\nconst insertData = `\nfunction Nodes(data, left, right){\n  this.data=data;\n  this.left=left;\n  this.right=right;\n  this.show=show;\n}\n\nfunction show(){\n  return this.data;\n}\n\nfunction bst(){\n  this.root=null;\n  this.insert=insert;\n}\n\nfunction insert(data){\n  const node=new Nodes(data,null,null)\n  if(this.root === null){\n    this.root=node;\n  }else{\n    var current=this.root;\n    var parrent;\n    while(current){\n      parrent=current;\n      if(data < current.data){\n        current=current.left;\n        if(current === null){\n          parrent.left=node;\n        }\n      }else{\n        current = current.right;\n        if(current === null){\n          parrent.right = node;\n        }\n      }\n    }\n  }\n}\n\nconst obj= new bst();\nobj.insert(3)\nobj.insert(5)\nobj.insert(2)\nobj.insert(7)\nobj.insert(1)\n\nconsole.log(obj.root)`.trim()\n\nconst traversing = `\nfunction Nodes(data, left, right){\n  this.data=data;\n  this.left=left;\n  this.right=right;\n  this.show=show;\n}\n\nfunction show(){\n  return this.data;\n}\n\nfunction bst(){\n  this.root=null;\n  this.insert=insert;\n}\n\nfunction insert(data){\n  const node=new Nodes(data,null,null)\n  if(this.root === null){\n    this.root=node;\n  }else{\n    var current=this.root;\n    var parrent;\n    while(current){\n      parrent=current;\n      if(data < current.data){\n        current=current.left;\n        if(current === null){\n          parrent.left=node;\n        }\n      }else{\n        current = current.right;\n        if(current === null){\n          parrent.right = node;\n        }\n      }\n    }\n  }\n}\n\nfunction inOrder(node){\n  if(!(node==null)){\n    inOrder(node.left);\n    console.log(node.show()+ \" \")\n    inOrder(node.right)\n  }\n}\n\nfunction preOrder(node) {\n  if (node !== null) {\n    console.log(node.show() + \" \");\n    preOrder(node.left);\n    preOrder(node.right);\n  }\n}\n\nfunction postOrder(node) {\n  if (node !== null) {\n    postOrder(node.left);\n    postOrder(node.right);\n    console.log(node.show() + \" \");\n  }\n}\n\nconst obj= new bst();\nobj.insert(3)\nobj.insert(5)\nobj.insert(2)\nobj.insert(7)\nobj.insert(1)\n\nconsole.log(obj.root)\n\nconsole.log('Inorder Traversal')\ninOrder(obj.root)\n\nconsole.log('Pre-Order Traversal');\npreOrder(obj.root);\n\nconsole.log('Post-Order Traversal');\npostOrder(obj.root);`.trim()\n\nconst deleteNode = `\nfunction Node(data,left,right){\n  this.data=data;\n  this.left=left;\n  this.right=right;\n  this.show=show;\n}\n\nfunction show(){\n  return this.data;\n}\n\nfunction bst(){\n  this.root=null;\n  this.insert=insert;\n}\n\nfunction insert(data){\n  const node=new Node(data,null,null);\n\n  if(this.root===null){\n    this.root=node;\n  }else{\n    var current=this.root;\n    var parent;\n\n    while(current){\n      parent=current;\n      if(data < current.data){\n        current=current.left;\n        if(current === null){\n          parent.left = node;\n        }\n      }else{\n        current = current.right;\n        if(current === null){\n          parent.right = node;\n        }\n      }\n    }\n  }\n}\n\nfunction inOrder(node){\n  if(!(node === null)){\n    inOrder(node.left)\n    console.log(node.show())\n    inOrder(node.right)\n  }\n}\n\nfunction deleteNode(root, key){\n  if(root === null){\n    return root;\n  }\n\n  if(key < root.data){\n    root.left = deleteNode(root.left, key)\n  }else if(key > root.data){\n    root.right = deleteNode(root.right, key)\n  }else {\n    if(root.left === null){\n      return root.right;\n    }else if(root.right === null){\n      return root.right;\n    }\n  }\n  return root;\n}\n\nconst obj = new bst()\nobj.insert(5)\nobj.insert(6)\nobj.insert(1)\nobj.insert(2)\nobj.insert(3)\n\ninOrder(obj.root)\n\nobj.root = deleteNode(obj.root, 6)\nconsole.log('After Deleting')\ninOrder(obj.root)`.trim()\n\nconst updates = `\nfunction Node(data,left,right){\n  this.data=data;\n  this.left=left;\n  this.right=right;\n  this.show=show;\n}\n\nfunction show(){\n  return this.data;\n}\n\nfunction bst(){\n  this.root=null;\n  this.insert=insert;\n}\n\nfunction insert(data){\n  const node=new Node(data,null,null)\n  if(this.root===null){\n    this.root=node;\n  }else{\n    var current=this.root;\n    var parrent;\n    while(current){\n      parrent=current;\n      if(data<current.data){\n        current=current.left;;\n        if(current===null){\n          parrent.left=node;\n        }\n      }else{\n        current=current.right;\n        if(current===null){\n          parrent.right=node;\n        }\n      }\n    }\n  }\n}\n\nfunction inOrder(root){\n  if(!(root===null)){\n    inOrder(root.left)\n    console.log(root.show())\n    inOrder(root.right)\n  }\n}\n\nfunction updateNode(node, target, newValue) {\n  if (node === null) {\n    return null;                                // Target node not found\n  }\n\n  if (target < node.data) {\n    node.left = updateNode(node.left, target, newValue);\n  } else if (target > node.data) {\n    node.right = updateNode(node.right, target, newValue);\n  } else {\n    node.data = newValue;                       // Found the target node, update its data\n  }\n\n  return node;\n}\n\nconst obj=new bst()\nobj.insert(4)\nobj.insert(1)\nobj.insert(2)\nobj.insert(3)\n\ninOrder(obj.root)\n\nconsole.log('Update Node');\nobj.root = updateNode(obj.root, 4, 10);\ninOrder(obj.root);\n`.trim()\n\n// const traversing = ``.trim()\n\nconst generateTrees = `\nfunction Node(val, left, right) {\n  this.val = val;\n  this.left = left || null;\n  this.right = right || null;\n}\n\nfunction generateTrees(n) {\n  if (n === 0) return [];\n\n  // Helper function to generate BSTs recursively\n  function generateBST(start, end) {\n    if (start > end) return [null];\n    const result = [];\n\n    for (let i = start; i <= end; i++) {\n      const leftSubtrees = generateBST(start, i - 1);\n      const rightSubtrees = generateBST(i + 1, end);\n\n      for (const leftTree of leftSubtrees) {\n        for (const rightTree of rightSubtrees) {\n          const root = new Node(i);\n          root.left = leftTree;\n          root.right = rightTree;\n          result.push(root);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  return generateBST(1, n);\n}\n\nfunction preOrder(node) {\n  if (node !== null) {\n    console.log(node.val);\n    preOrder(node.left);\n    preOrder(node.right);\n  }\n}\n\nconst obj = generateTrees(3);\n\nfor (const tree of obj) {\n  preOrder(tree);\n  console.log('---');\n}\n\n\n//2\nfunction TreeNode(val) {\n  this.val = val\n  this.left = null\n  this.right = null\n}\n\nconst generateTrees = (n) => {\n  if (n === 0) return [];\n\n  const numbers = new Array(n).fill(0).map((v, index) => index + 1)\n  const memo = {}\n\n  const compose = (number, left, right) => {\n    const result = []\n    for (let i = 0; i < left.length; i++) {\n      for (let j = 0; j < right.length; j++) {\n            const node = new TreeNode(number)\n            node.left = left[i]\n            node.right = right[j]\n            result.push(node)\n          }\n        }\n        return result\n      }\n\n  const aux = (list = []) => {\n    const key = list.toString()\n    if (memo[key] !== undefined) {\n      return memo[list.toString()]\n    }\n\n    if (list.length === 0) return [null]\n\n    memo[key] = list.reduce((acc, number) => {\n        acc.push(...compose(number, aux(list.filter(x => x < number)), aux(list.filter(x => x > number)),\n          ),\n        )\n        return acc\n      },\n      [],\n    )\n    return memo[key]\n  }\n  \n  return aux(numbers)\n}\n\nconsole.log(generateTrees(3))\n`.trim();\n\nconst isValidBST = `\nfunction Nodes(data, left, right) {\n  this.data = data;\n  this.left = left;\n  this.right = right;\n  this.show = show;\n}\n\nfunction show() {\n  return this.data;\n}\n\nfunction bst() {\n  this.root = null;\n  this.insert = insert;\n  this.isValidBST = isValidBST; \n}\n\nfunction insert(data) {\n  const node = new Nodes(data, null, null);\n  if (this.root === null) {\n    this.root = node;\n  } else {\n    let current = this.root;\n    let parent;\n    while (current) {\n      parent = current;\n      if (data < current.data) {\n        current = current.left;\n        if (current === null) {\n          parent.left = node;\n        }\n      } else {\n        current = current.right;\n        if (current === null) {\n          parent.right = node;\n        }\n      }\n    }\n  }\n}\n\nfunction inOrder(node) {\n  if (!(node == null)) {\n    inOrder(node.left);\n    console.log(node.show() + \" \");\n    inOrder(node.right);\n  }\n}\n\nfunction isValidBST(node, min = null, max = null) {\n  if (node === null) return true;\n\n  if ((min !== null && node.data <= min) || (max !== null && node.data >= max)) {\n    return false;\n  }\n\n  return (\n    isValidBST(node.left, min, node.data) && isValidBST(node.right, node.data, max)\n  );\n}\n\nconst obj = new bst();\nobj.insert(3);\nobj.insert(5);\nobj.insert(2);\nobj.insert(7);\nobj.insert(1);\n\ninOrder(obj.root);\n\nconsole.log('Is Valid BST:', obj.isValidBST(obj.root));\n`.trim();\n\nconst recoverTree = `\nfunction recoverTree(root) {\n  let first = null\n  let second = null\n  let prev = null\n\n  const aux = (node) => {\n    if (node) {\n      aux(node.left)\n      if (prev && prev.val > node.val) {\n        if (!first) {\n          first = prev\n          second = node\n        } else {\n          second = node\n        }\n      }\n      prev = node\n      aux(node.right)\n    }\n  }\n  aux(root)\n\n  if (first && second) {\n    const temp = first.val\n    first.val = second.val\n    second.val = temp\n  }\n}\n\nconsole.log(recoverTree([1,3,null,2]))`.trim();\n\nconst isSameTree = `\nfunction TreeNode(val, left, right) {\n  this.val = val;\n  this.left = left || null;\n  this.right = right || null;\n}\n\nfunction isSameTree(p, q) {\n  if (!p && !q) return true; \n  if (!p || !q) return false;                     // One of the nodes is null, they are different.\n  if (p.val !== q.val) return false;              // Values are different.\n\n  // Recursively compare left and right subtrees.\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}\n\nfunction buildTreeFromArray(arr) {\n  if (!arr || arr.length === 0) return null;\n\n  const build = (index) => {\n    if (index >= arr.length || arr[index] === null) {\n      return null;\n    }\n    return new TreeNode(arr[index], build(2 * index + 1), build(2 * index + 2));\n  };\n\n  return build(0);\n}\n\nconst tree1Array = [1, 3, null, 2];\nconst tree2Array = [1, 3, null, 2];\n\nconst tree1 = buildTreeFromArray(tree1Array);\nconst tree2 = buildTreeFromArray(tree2Array);\n\nconsole.log(isSameTree(tree1, tree2)); \n`.trim();\n\nconst isSymmetric = `\nfunction TreeNode(val, left, right) {\n  this.val = val;\n  this.left = left || null;\n  this.right = right || null;\n}\n\nfunction isSymmetric(root) {\n  if (!root) return true;                           // An empty tree is symmetric.\n\n  function isMirror(left, right) {\n    if (!left && !right) return true;               // Both nodes are null, they are mirrors.\n    if (!left || !right) return false;              // One of the nodes is null, they are not mirrors.\n    if (left.val !== right.val) return false; \n\n    // Check if subtrees are mirrors of each other.\n    return isMirror(left.left, right.right) && isMirror(left.right, right.left);\n  }\n\n  // Start by comparing the left and right subtrees.\n  return isMirror(root.left, root.right);\n}\n\nfunction buildTreeFromArray(arr) {\n  if (!arr || arr.length === 0) return null;\n\n  const build = (index) => {\n    if (index >= arr.length || arr[index] === null) {\n      return null;\n    }\n    return new TreeNode(arr[index], build(2 * index + 1), build(2 * index + 2));\n  };\n\n  return build(0);\n}\n\nconst obj = [1, 2, 2, 3, 4, 4, 3];\nconst tree = buildTreeFromArray(obj);\n\nconsole.log(isSymmetric(tree)); \n `.trim();\n\nconst sortedArrayToBST = `\nfunction sortedArrayToBST (nums = []){\n  const aux = (low, high) => {\n    if (low <= high) {\n      const middle = Math.floor((low + high) / 2)\n      const node = { val: nums[middle] }\n      \n      node.left = aux(low, middle - 1)\n      node.right = aux(middle + 1, high)\n      return node\n    }\n    return null\n  }\n  return aux(0, nums.length - 1)\n}\n\nconsole.log(sortedArrayToBST([3,9,20,null,null,15,7]))\n`.trim();\n\nconst sortedListToBST = `\nfunction Node(data, left, right) {\n  this.data = data;\n  this.left = left;\n  this.right = right;\n  this.show = show;\n}\n\nfunction show() {\n  return this.data;\n}\n\nfunction bst() {\n  this.root = null;\n  this.insert = insert;\n  this.sortedArrayToBST = sortedArrayToBST;\n}\n\nfunction insert(data) {\n  const node = new Node(data, null, null);\n  if (this.root === null) {\n    this.root = node;\n  } else {\n    let current = this.root;\n    let parent;\n    while (current) {\n      parent = current;\n      if (data < current.data) {\n        current = current.left;\n        if (current === null) {\n          parent.left = node;\n        }\n      } else {\n        current = current.right;\n        if (current === null) {\n          parent.right = node;\n        }\n      }\n    }\n  }\n}\n\nfunction sortedArrayToBST(arr) {\n  this.root = sortedArray(arr, 0, arr.length - 1);\n}\n\nfunction sortedArray(arr, start, end) {\n  if (start > end) {\n    return null;\n  }\n\n  const mid = Math.floor((start + end) / 2);\n  const node = new Node(arr[mid], null, null);\n\n  node.left = sortedArray(arr, start, mid - 1);\n  node.right = sortedArray(arr, mid + 1, end);\n\n  return node;\n}\n\nfunction postOrder(node) {\n  if (node !== null) {\n    postOrder(node.left);\n    postOrder(node.right);\n    console.log(node.show() + \" \");\n  }\n}\n\nconst obj = new bst();\n\nobj.sortedArrayToBST([1, 2, 3, 5, 7]);\npostOrder(obj.root);\n`.trim();\n\nconst minDepth = `\nfunction Node(data, left, right) {\n  this.data = data;\n  this.left = left;\n  this.right = right;\n}\n\nfunction BST() {\n  this.root = null;\n  this.insert = insert;\n  this.insertArray = insertArray;\n}\n\nfunction insert(data) {\n  const node = new Node(data, null, null);\n  if (this.root === null) {\n    this.root = node;\n  } else {\n    let current = this.root;\n    let parent;\n    while (current) {\n      parent = current;\n      if (data < current.data) {\n        current = current.left;\n        if (current === null) {\n          parent.left = node;\n        }\n      } else {\n        current = current.right;\n        if (current === null) {\n          parent.right = node;\n        }\n      }\n    }\n  }\n}\n\nfunction insertArray(arr) {\n  for (const data of arr) {\n    this.insert(data);\n  }\n}\n\n\nfunction minDepth(root) {\n  let depth = 0;\n  const queue = [root];\n\n  while (queue.length > 0) {\n    depth++;\n    const levelSize = queue.length;\n\n    for (let i = 0; i < levelSize; i++) {\n      const currentNode = queue.shift();\n\n      // If a leaf node is encountered, return the depth.\n      if (currentNode.left === null && currentNode.right === null) {\n        return depth;\n      }\n\n     \n      if (currentNode.left !== null) {                       // Add the child nodes to the queue.\n        queue.push(currentNode.left);\n      }\n      if (currentNode.right !== null) {\n        queue.push(currentNode.right);\n      }\n    }\n  }\n\n  return depth;\n}\n\n\nconst obj = new BST();\nconst sortedArray = [3,9,20,null,null,15,7];\nobj.insertArray(sortedArray);\n\nconst minimumDepth = minDepth(obj.root);\nconsole.log(\"Minimum Depth of Binary Tree:\", minimumDepth);\n\n`.trim();\n\nconst hasPathSum = `\nfunction hasPathSum (root, sum){\n  function aux (node, currentSum){\n    if (!node) return false;\n\n    if (node && !node.left && !node.right) {\n      return (currentSum + node.val) === sum\n    }\n    const isLeftHas = aux(node.left, currentSum + node.val)\n    const isRightHas = aux(node.right, currentSum + node.val)\n    return (isLeftHas || isRightHas)\n  }\n\n  if (root === null) return false;\n  return aux(root, 0)\n}\n\nconsole.log(hasPathSum([5,4,1],10))\n`.trim();\n\nconst connect = `\nfunction connect (root){\n  if (!root) return null;\n  let frontier = [root];\n\n  while (frontier.length) {\n    const next = []\n    frontier.forEach((node, index) => {\n      if (frontier[index + 1]) {\n        node.next = frontier[index + 1]\n      } else {\n        node.next = null\n      }\n      if (node.left) {\n        next.push(node.left)\n      }\n      if (node.right) {\n        next.push(node.right)\n      }\n    })\n    frontier = next\n  }\n  return root\n}\n\nconsole.log(connect([1,2,3,4,5,null,7]))\n`.trim();\n\n\nclass Trees extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0)\n  }\n  render() {\n    const { classes } = this.props;\n    return (\n      <Grid container>\n        <Grid item xs={2}>\n          <Paper className={classes.paper}>\n            <h4><Sidebar /></h4>\n          </Paper>\n        </Grid>\n        <Grid item xs={10}>\n          <Paper className={classes.paper}>\n            <List>\n              <h3>Create Tree</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={insertData}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>Traversing</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={traversing}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>Delete</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={deleteNode}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>Update</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={updates}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>1. Unique Binary Search Trees.</h3>\n              <b>Input: </b>3<br/>\n              <b>Output: </b>\n              [<br/>\n                [1,null,3,2],<br/>\n                [3,2,null,1],<br/>\n                [3,1,null,null,2],<br/>\n                [2,1,3],<br/>\n                [1,null,2,null,3]\n              ]\n              <div style={titles}>\n                <PrismCode\n                  code={generateTrees}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>2. Validate Binary Search Tree.</h3>\n              To validate whether a binary tree is a binary search tree (BST), you can use an inorder traversal approach. In a BST, \n              when you traverse the tree in inorder, the values should be in ascending order. If they are not, the tree is not a \n              valid BST.\n              <div style={titles}>\n                <PrismCode\n                  code={isValidBST}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>3. Recover Binary Search Tree.</h3>\n              Two elements of a binary search tree (BST) are swapped by mistake.\n              <br/>\n              Recover the tree without changing its structure. <br/><br/>\n              <b>Input: </b> [3,1,4,null,null,2]<br/>\n              <b>Output: </b> [2,1,4,null,null,3]\n              <div style={titles}>\n                <PrismCode\n                  code={recoverTree}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>4. Same Tree.</h3>\n              Given two binary trees, write a function to check if they are the same or not.\n              <br/>\n              Two binary trees are considered the same if they are structurally identical and the nodes have the same value.\n              <div style={titles}>\n                <PrismCode\n                  code={isSameTree}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>5. Symmetric Tree.</h3>\n              Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\n              <div style={titles}>\n                <PrismCode\n                  code={isSymmetric}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>6. Convert Sorted Array to Binary Search Tree.</h3>\n              Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\n              <br/>\n              For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n              <div style={titles}>\n                <PrismCode\n                  code={sortedArrayToBST}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>7. Convert Sorted List to Binary Search Tree.</h3>\n              Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.\n              <br/>\n              For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n              <br/>\n              <br/>\n              <b>Input: </b>head = [-10,-3,0,5,9]<br/>\n              <b>Output: </b>[0,-3,9,-10,null,5]\n              <div style={titles}>\n                <PrismCode\n                  code={sortedListToBST}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>8. Minimum Depth of Binary Tree.</h3>\n              The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n              <div style={titles}>\n                <PrismCode\n                  code={minDepth}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>9. Path Sum.</h3>\n              Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\n              <div style={titles}>\n                <PrismCode\n                  code={hasPathSum}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>10. Populating Next Right Pointers in Each Node.</h3>\n              Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\n              <br/>\n              Initially, all next pointers are set to NULL.\n              <br/>\n              <ul>\n                <li>You may only use constant extra space.</li>\n                <li>Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</li>\n              </ul>\n              <div style={titles}>\n                <PrismCode\n                  code={connect}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              \n            </List>\n          </Paper>\n        </Grid>\n      </Grid>\n    )\n  }\n}\n\nexport default (withStyles(styles)(Trees));\n"]},"metadata":{},"sourceType":"module"}