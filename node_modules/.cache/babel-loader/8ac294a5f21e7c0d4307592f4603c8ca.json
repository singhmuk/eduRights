{"ast":null,"code":"import _classCallCheck from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/createClass\";import _possibleConstructorReturn from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";import _getPrototypeOf from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";import _inherits from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/inherits\";import React,{Component}from'react';import Prism from\"prismjs\";import{Grid,Paper,withStyles,List}from\"@material-ui/core\";import'../../ReactJs/styles.css';import Sidebar from'../sidebar';import PrismCode from'../../ReactJs/prismCode';import Stcksval from'../../../assets/stcks.png';var titles={backgroundColor:'#F0F8FF',padding:'1px',fontSize:'16px'};var redesign={height:200,width:500};var styles=function styles(theme){return{paper:{margin:theme.spacing(1),padding:theme.spacing(1)},smMargin:{margin:theme.spacing(1)},actionDiv:{textAlign:\"center\"}};};var generateTrees=\"\\nfunction TreeNode(val) {\\n  this.val = val\\n  this.left = null\\n  this.right = null\\n}\\n\\nconst generateTrees = (n) => {\\n  if (n === 0) return [];\\n\\n  const numbers = new Array(n).fill(0).map((v, index) => index + 1)\\n  const memo = {}\\n\\n  const compose = (number, left, right) => {\\n    const result = []\\n    for (let i = 0; i < left.length; i++) {\\n      for (let j = 0; j < right.length; j++) {\\n            const node = new TreeNode(number)\\n            node.left = left[i]\\n            node.right = right[j]\\n            result.push(node)\\n          }\\n        }\\n        return result\\n      }\\n\\n  const aux = (list = []) => {\\n    const key = list.toString()\\n    if (memo[key] !== undefined) {\\n      return memo[list.toString()]\\n    }\\n\\n    if (list.length === 0) return [null]\\n\\n    memo[key] = list.reduce((acc, number) => {\\n        acc.push(...compose(number, aux(list.filter(x => x < number)), aux(list.filter(x => x > number)),\\n          ),\\n        )\\n        return acc\\n      },\\n      [],\\n    )\\n    return memo[key]\\n  }\\n  \\n  return aux(numbers)\\n}\\n\\nconsole.log(generateTrees(3))\\n\".trim();var isValidBST=\"\\nfunction isValidBST(root) {\\n  const aux = (node) => {\\n    if (!node) return [true, null, null];\\n\\n    const [leftValid, leftMin, leftMax] = aux(node.left)\\n    const [rightValid, rightMin, rightMax] = aux(node.right)\\n    let valid = leftValid && rightValid\\n\\n    if (leftMax !== null && leftMax >= node.val) {\\n      valid = false\\n    }\\n    if (rightMin !== null && rightMin <= node.val) {\\n      valid = false\\n    }\\n    \\n    const currentMin = leftMin === null ? node.val : leftMin\\n    const currentMax = rightMax === null ? node.val : rightMax\\n    return [valid, currentMin, currentMax]\\n  }\\n  return aux(root)[0]\\n}\\n\\nconsole.log(isValidBST(3))\\n\".trim();var recoverTree=\"\\nfunction recoverTree(root) {\\n  let first = null\\n  let second = null\\n  let prev = null\\n\\n  const aux = (node) => {\\n    if (node) {\\n      aux(node.left)\\n      if (prev && prev.val > node.val) {\\n        if (!first) {\\n          first = prev\\n          second = node\\n        } else {\\n          second = node\\n        }\\n      }\\n      prev = node\\n      aux(node.right)\\n    }\\n  }\\n  aux(root)\\n\\n  if (first && second) {\\n    const temp = first.val\\n    first.val = second.val\\n    second.val = temp\\n  }\\n}\\n\\nconsole.log(recoverTree([1,3,null,2]))\".trim();var isSameTree=\"\\nfunction isSameTree(p, q) {\\n  if ((p && !q) || (!p && q)) return false;\\n  if (!p && !q) return true;\\n\\n  const leftSame = isSameTree(p.left, q.left)\\n  const rightSame = isSameTree(p.right, q.right)\\n  \\n  return leftSame && rightSame && (p.val === q.val)\\n}\\n\\nconsole.log(isSameTree([1,3,null,2], [1,3,null,2]))\\n\".trim();var isSymmetric=\"\\nfunction isSymmetric(root){\\n  function aux (node, level, result){\\n    if (!result[level]) {\\n      result[level] = []\\n    }\\n\\n    if (!node) {\\n      result[level].push(null)\\n      return result\\n    }\\n\\n    result[level].push(node.val)\\n    aux(node.left, level + 1, result)\\n    aux(node.right, level + 1, result)\\n    return result\\n  }\\n\\n  function isSymmetricHelper (values = []){\\n    for (let i = 0; i <= values.length / 2; i++) {\\n      if (values[i] !== values[values.length - 1 - i]) {\\n        return false\\n      }\\n    }\\n    return true\\n  }\\n\\n  const result = aux(root, 0, [])\\n  for (let i = 0; i < result.length; i++) {\\n    if (!isSymmetricHelper(result[i])) {\\n      return false\\n    }\\n  }\\n  return true\\n}\\n\\nconsole.log(isSymmetric([1,2,2,3,4,4,3]))\\n \".trim();var sortedArrayToBST=\"\\nfunction sortedArrayToBST (nums = []){\\n  const aux = (low, high) => {\\n    if (low <= high) {\\n      const middle = Math.floor((low + high) / 2)\\n      const node = { val: nums[middle] }\\n      \\n      node.left = aux(low, middle - 1)\\n      node.right = aux(middle + 1, high)\\n      return node\\n    }\\n    return null\\n  }\\n  return aux(0, nums.length - 1)\\n}\\n\\nconsole.log(sortedArrayToBST([3,9,20,null,null,15,7]))\\n\".trim();var sortedListToBST=\"\\nfunction sortedListToBST(head) {\\n  const nodes = []\\n\\n  while (head) {\\n    head.left = null\\n    head.right = null\\n    nodes.push(head)\\n    head = head.next\\n  }\\n\\n  const aux = (nodes, low, high) => { \\n    if (low > high) return null;\\n\\n    const middle = Math.floor((low + high) / 2)\\n    nodes[middle].left = aux(nodes, low, middle - 1)\\n    nodes[middle].right = aux(nodes, middle + 1, high)\\n    return nodes[middle]\\n  }\\n  return aux(nodes, 0, nodes.length - 1)\\n}\\n\\nconsole.log(sortedListToBST([-10,-3,0,5,9]))\\n\".trim();var minDepth=\"\\nfunction minDepth (root){\\n  if (!root) return 0;\\n\\n  const aux = (node, depth) => {\\n    if (!node || (!node.left && !node.right)) return depth;\\n\\n    if (node.left && !node.right) {\\n      return aux(node.left, depth + 1)\\n    }\\n\\n    if (node.right && !node.left) {\\n      return aux(node.right, depth + 1)\\n    }\\n\\n    const leftDepth = aux(node.left, depth + 1)\\n    const rightDepth = aux(node.right, depth + 1)\\n    return leftDepth < rightDepth ? leftDepth : rightDepth\\n  }\\n\\n  return aux(root, 1)\\n}\\n\\nconsole.log(minDepth([3,9,20,null,null,15,7]))\\n\".trim();var hasPathSum=\"\\nfunction hasPathSum (root, sum){\\n  function aux (node, currentSum){\\n    if (!node) return false;\\n\\n    if (node && !node.left && !node.right) {\\n      return (currentSum + node.val) === sum\\n    }\\n    const isLeftHas = aux(node.left, currentSum + node.val)\\n    const isRightHas = aux(node.right, currentSum + node.val)\\n    return (isLeftHas || isRightHas)\\n  }\\n\\n  if (root === null) return false;\\n  return aux(root, 0)\\n}\\n\\nconsole.log(hasPathSum([5,4,1],10))\\n\".trim();var connect=\"\\nfunction connect (root){\\n  if (!root) return null;\\n  let frontier = [root];\\n\\n  while (frontier.length) {\\n    const next = []\\n    frontier.forEach((node, index) => {\\n      if (frontier[index + 1]) {\\n        node.next = frontier[index + 1]\\n      } else {\\n        node.next = null\\n      }\\n      if (node.left) {\\n        next.push(node.left)\\n      }\\n      if (node.right) {\\n        next.push(node.right)\\n      }\\n    })\\n    frontier = next\\n  }\\n  return root\\n}\\n\\nconsole.log(connect([1,2,3,4,5,null,7]))\\n\".trim();var Trees=/*#__PURE__*/function(_Component){_inherits(Trees,_Component);function Trees(){_classCallCheck(this,Trees);return _possibleConstructorReturn(this,_getPrototypeOf(Trees).apply(this,arguments));}_createClass(Trees,[{key:\"componentDidMount\",value:function componentDidMount(){setTimeout(function(){return Prism.highlightAll();},0);}},{key:\"render\",value:function render(){var classes=this.props.classes;return React.createElement(Grid,{container:true},React.createElement(Grid,{item:true,xs:2},React.createElement(Paper,{className:classes.paper},React.createElement(\"h4\",null,React.createElement(Sidebar,null)))),React.createElement(Grid,{item:true,xs:10},React.createElement(Paper,{className:classes.paper},React.createElement(List,null,React.createElement(\"h3\",null,\"1. Unique Binary Search Trees.\"),React.createElement(\"b\",null,\"Input: \"),\"3\",React.createElement(\"br\",null),React.createElement(\"b\",null,\"Output: \"),\"[\",React.createElement(\"br\",null),\"[1,null,3,2],\",React.createElement(\"br\",null),\"[3,2,null,1],\",React.createElement(\"br\",null),\"[3,1,null,null,2],\",React.createElement(\"br\",null),\"[2,1,3],\",React.createElement(\"br\",null),\"[1,null,2,null,3] ]\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:generateTrees,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"2. Validate Binary Search Tree.\"),\"Given a binary tree, determine if it is a valid binary search tree (BST).\",React.createElement(\"br\",null),\"Assume a BST is defined as follows:\",React.createElement(\"ul\",null,React.createElement(\"li\",null,\"The left subtree of a node contains only nodes with keys less than the node's key.\"),React.createElement(\"li\",null,\"The right subtree of a node contains only nodes with keys greater than the node's key.\"),React.createElement(\"li\",null,\"Both the left and right subtrees must also be binary search trees.\")),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Input: \"),\" [2,1,3]\",React.createElement(\"b\",null,\"Output: \"),\" true\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Example 2: \"),React.createElement(\"b\",null,\"Input: \"),\"[5,1,4,null,null,3,6]\",React.createElement(\"br\",null),React.createElement(\"b\",null,\"Output: \"),\"false\",React.createElement(\"br\",null),React.createElement(\"b\",null,\"Explanation: \"),\"The root node's value is 5 but its right child's value is 4.\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:isValidBST,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"3. Recover Binary Search Tree.\"),\"Two elements of a binary search tree (BST) are swapped by mistake.\",React.createElement(\"br\",null),\"Recover the tree without changing its structure. \",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Input: \"),\" [3,1,4,null,null,2]\",React.createElement(\"br\",null),React.createElement(\"b\",null,\"Output: \"),\" [2,1,4,null,null,3]\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:recoverTree,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"4. Same Tree.\"),\"Given two binary trees, write a function to check if they are the same or not.\",React.createElement(\"br\",null),\"Two binary trees are considered the same if they are structurally identical and the nodes have the same value.\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:isSameTree,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"5. Symmetric Tree.\"),\"Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:isSymmetric,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"6. Convert Sorted Array to Binary Search Tree.\"),\"Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\",React.createElement(\"br\",null),\"For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:sortedArrayToBST,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"7. Convert Sorted List to Binary Search Tree.\"),\"Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.\",React.createElement(\"br\",null),\"For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Input: \"),\"head = [-10,-3,0,5,9]\",React.createElement(\"br\",null),React.createElement(\"b\",null,\"Output: \"),\"[0,-3,9,-10,null,5]\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:sortedListToBST,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"8. Minimum Depth of Binary Tree.\"),\"The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:minDepth,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"9. Path Sum.\"),\"Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:hasPathSum,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"10. Populating Next Right Pointers in Each Node.\"),\"Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\",React.createElement(\"br\",null),\"Initially, all next pointers are set to NULL.\",React.createElement(\"br\",null),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"You may only use constant extra space.\"),React.createElement(\"li\",null,\"Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.\")),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:connect,language:\"js\",plugins:[\"line-numbers\"]}))))));}}]);return Trees;}(Component);export default withStyles(styles)(Trees);","map":{"version":3,"sources":["/home/mukeshs/Projects/edurights/src/components/algorithams/deepAlgorithams/trees.js"],"names":["React","Component","Prism","Grid","Paper","withStyles","List","Sidebar","PrismCode","Stcksval","titles","backgroundColor","padding","fontSize","redesign","height","width","styles","theme","paper","margin","spacing","smMargin","actionDiv","textAlign","generateTrees","trim","isValidBST","recoverTree","isSameTree","isSymmetric","sortedArrayToBST","sortedListToBST","minDepth","hasPathSum","connect","Trees","setTimeout","highlightAll","classes","props"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport Prism from \"prismjs\"\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\n\nimport '../../ReactJs/styles.css'\nimport Sidebar from '../sidebar';\nimport PrismCode from '../../ReactJs/prismCode';\n\nimport Stcksval from '../../../assets/stcks.png';\n\nconst titles = { backgroundColor: '#F0F8FF', padding: '1px', fontSize: '16px' }\n\nconst redesign = {\n  height: 200,\n  width: 500\n}\n\nconst styles = theme => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1)\n  },\n  smMargin: {\n    margin: theme.spacing(1)\n  },\n  actionDiv: {\n    textAlign: \"center\"\n  }\n})\n\n\nconst generateTrees = `\nfunction TreeNode(val) {\n  this.val = val\n  this.left = null\n  this.right = null\n}\n\nconst generateTrees = (n) => {\n  if (n === 0) return [];\n\n  const numbers = new Array(n).fill(0).map((v, index) => index + 1)\n  const memo = {}\n\n  const compose = (number, left, right) => {\n    const result = []\n    for (let i = 0; i < left.length; i++) {\n      for (let j = 0; j < right.length; j++) {\n            const node = new TreeNode(number)\n            node.left = left[i]\n            node.right = right[j]\n            result.push(node)\n          }\n        }\n        return result\n      }\n\n  const aux = (list = []) => {\n    const key = list.toString()\n    if (memo[key] !== undefined) {\n      return memo[list.toString()]\n    }\n\n    if (list.length === 0) return [null]\n\n    memo[key] = list.reduce((acc, number) => {\n        acc.push(...compose(number, aux(list.filter(x => x < number)), aux(list.filter(x => x > number)),\n          ),\n        )\n        return acc\n      },\n      [],\n    )\n    return memo[key]\n  }\n  \n  return aux(numbers)\n}\n\nconsole.log(generateTrees(3))\n`.trim();\n\nconst isValidBST = `\nfunction isValidBST(root) {\n  const aux = (node) => {\n    if (!node) return [true, null, null];\n\n    const [leftValid, leftMin, leftMax] = aux(node.left)\n    const [rightValid, rightMin, rightMax] = aux(node.right)\n    let valid = leftValid && rightValid\n\n    if (leftMax !== null && leftMax >= node.val) {\n      valid = false\n    }\n    if (rightMin !== null && rightMin <= node.val) {\n      valid = false\n    }\n    \n    const currentMin = leftMin === null ? node.val : leftMin\n    const currentMax = rightMax === null ? node.val : rightMax\n    return [valid, currentMin, currentMax]\n  }\n  return aux(root)[0]\n}\n\nconsole.log(isValidBST(3))\n`.trim();\n\nconst recoverTree = `\nfunction recoverTree(root) {\n  let first = null\n  let second = null\n  let prev = null\n\n  const aux = (node) => {\n    if (node) {\n      aux(node.left)\n      if (prev && prev.val > node.val) {\n        if (!first) {\n          first = prev\n          second = node\n        } else {\n          second = node\n        }\n      }\n      prev = node\n      aux(node.right)\n    }\n  }\n  aux(root)\n\n  if (first && second) {\n    const temp = first.val\n    first.val = second.val\n    second.val = temp\n  }\n}\n\nconsole.log(recoverTree([1,3,null,2]))`.trim();\n\nconst isSameTree = `\nfunction isSameTree(p, q) {\n  if ((p && !q) || (!p && q)) return false;\n  if (!p && !q) return true;\n\n  const leftSame = isSameTree(p.left, q.left)\n  const rightSame = isSameTree(p.right, q.right)\n  \n  return leftSame && rightSame && (p.val === q.val)\n}\n\nconsole.log(isSameTree([1,3,null,2], [1,3,null,2]))\n`.trim();\n\nconst isSymmetric = `\nfunction isSymmetric(root){\n  function aux (node, level, result){\n    if (!result[level]) {\n      result[level] = []\n    }\n\n    if (!node) {\n      result[level].push(null)\n      return result\n    }\n\n    result[level].push(node.val)\n    aux(node.left, level + 1, result)\n    aux(node.right, level + 1, result)\n    return result\n  }\n\n  function isSymmetricHelper (values = []){\n    for (let i = 0; i <= values.length / 2; i++) {\n      if (values[i] !== values[values.length - 1 - i]) {\n        return false\n      }\n    }\n    return true\n  }\n\n  const result = aux(root, 0, [])\n  for (let i = 0; i < result.length; i++) {\n    if (!isSymmetricHelper(result[i])) {\n      return false\n    }\n  }\n  return true\n}\n\nconsole.log(isSymmetric([1,2,2,3,4,4,3]))\n `.trim();\n\nconst sortedArrayToBST = `\nfunction sortedArrayToBST (nums = []){\n  const aux = (low, high) => {\n    if (low <= high) {\n      const middle = Math.floor((low + high) / 2)\n      const node = { val: nums[middle] }\n      \n      node.left = aux(low, middle - 1)\n      node.right = aux(middle + 1, high)\n      return node\n    }\n    return null\n  }\n  return aux(0, nums.length - 1)\n}\n\nconsole.log(sortedArrayToBST([3,9,20,null,null,15,7]))\n`.trim();\n\nconst sortedListToBST = `\nfunction sortedListToBST(head) {\n  const nodes = []\n\n  while (head) {\n    head.left = null\n    head.right = null\n    nodes.push(head)\n    head = head.next\n  }\n\n  const aux = (nodes, low, high) => { \n    if (low > high) return null;\n\n    const middle = Math.floor((low + high) / 2)\n    nodes[middle].left = aux(nodes, low, middle - 1)\n    nodes[middle].right = aux(nodes, middle + 1, high)\n    return nodes[middle]\n  }\n  return aux(nodes, 0, nodes.length - 1)\n}\n\nconsole.log(sortedListToBST([-10,-3,0,5,9]))\n`.trim();\n\nconst minDepth = `\nfunction minDepth (root){\n  if (!root) return 0;\n\n  const aux = (node, depth) => {\n    if (!node || (!node.left && !node.right)) return depth;\n\n    if (node.left && !node.right) {\n      return aux(node.left, depth + 1)\n    }\n\n    if (node.right && !node.left) {\n      return aux(node.right, depth + 1)\n    }\n\n    const leftDepth = aux(node.left, depth + 1)\n    const rightDepth = aux(node.right, depth + 1)\n    return leftDepth < rightDepth ? leftDepth : rightDepth\n  }\n\n  return aux(root, 1)\n}\n\nconsole.log(minDepth([3,9,20,null,null,15,7]))\n`.trim();\n\nconst hasPathSum = `\nfunction hasPathSum (root, sum){\n  function aux (node, currentSum){\n    if (!node) return false;\n\n    if (node && !node.left && !node.right) {\n      return (currentSum + node.val) === sum\n    }\n    const isLeftHas = aux(node.left, currentSum + node.val)\n    const isRightHas = aux(node.right, currentSum + node.val)\n    return (isLeftHas || isRightHas)\n  }\n\n  if (root === null) return false;\n  return aux(root, 0)\n}\n\nconsole.log(hasPathSum([5,4,1],10))\n`.trim();\n\nconst connect = `\nfunction connect (root){\n  if (!root) return null;\n  let frontier = [root];\n\n  while (frontier.length) {\n    const next = []\n    frontier.forEach((node, index) => {\n      if (frontier[index + 1]) {\n        node.next = frontier[index + 1]\n      } else {\n        node.next = null\n      }\n      if (node.left) {\n        next.push(node.left)\n      }\n      if (node.right) {\n        next.push(node.right)\n      }\n    })\n    frontier = next\n  }\n  return root\n}\n\nconsole.log(connect([1,2,3,4,5,null,7]))\n`.trim();\n\n\nclass Trees extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0)\n  }\n  render() {\n    const { classes } = this.props;\n    return (\n      <Grid container>\n        <Grid item xs={2}>\n          <Paper className={classes.paper}>\n            <h4><Sidebar /></h4>\n          </Paper>\n        </Grid>\n        <Grid item xs={10}>\n          <Paper className={classes.paper}>\n            <List>\n              <h3>1. Unique Binary Search Trees.</h3>\n              <b>Input: </b>3<br/>\n              <b>Output: </b>\n              [<br/>\n                [1,null,3,2],<br/>\n                [3,2,null,1],<br/>\n                [3,1,null,null,2],<br/>\n                [2,1,3],<br/>\n                [1,null,2,null,3]\n              ]\n              <div style={titles}>\n                <PrismCode\n                  code={generateTrees}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>2. Validate Binary Search Tree.</h3>\n              Given a binary tree, determine if it is a valid binary search tree (BST).\n              <br/>\n              Assume a BST is defined as follows:\n              <ul>\n                <li>The left subtree of a node contains only nodes with keys less than the node's key.</li>\n                <li>The right subtree of a node contains only nodes with keys greater than the node's key.</li>\n                <li>Both the left and right subtrees must also be binary search trees.</li>\n              </ul>\n              <br/>\n              <b>Input: </b> [2,1,3]\n              <b>Output: </b> true\n              <br/>\n              <br/>\n              <b>Example 2: </b> \n              <b>Input: </b>[5,1,4,null,null,3,6]<br/>\n              <b>Output: </b>false<br/>\n              <b>Explanation: </b>The root node's value is 5 but its right child's value is 4.\n              <div style={titles}>\n                <PrismCode\n                  code={isValidBST}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>3. Recover Binary Search Tree.</h3>\n              Two elements of a binary search tree (BST) are swapped by mistake.\n              <br/>\n              Recover the tree without changing its structure. <br/><br/>\n              <b>Input: </b> [3,1,4,null,null,2]<br/>\n              <b>Output: </b> [2,1,4,null,null,3]\n              <div style={titles}>\n                <PrismCode\n                  code={recoverTree}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>4. Same Tree.</h3>\n              Given two binary trees, write a function to check if they are the same or not.\n              <br/>\n              Two binary trees are considered the same if they are structurally identical and the nodes have the same value.\n              <div style={titles}>\n                <PrismCode\n                  code={isSameTree}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>5. Symmetric Tree.</h3>\n              Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\n              <div style={titles}>\n                <PrismCode\n                  code={isSymmetric}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>6. Convert Sorted Array to Binary Search Tree.</h3>\n              Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\n              <br/>\n              For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n              <div style={titles}>\n                <PrismCode\n                  code={sortedArrayToBST}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>7. Convert Sorted List to Binary Search Tree.</h3>\n              Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.\n              <br/>\n              For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n              <br/>\n              <br/>\n              <b>Input: </b>head = [-10,-3,0,5,9]<br/>\n              <b>Output: </b>[0,-3,9,-10,null,5]\n              <div style={titles}>\n                <PrismCode\n                  code={sortedListToBST}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>8. Minimum Depth of Binary Tree.</h3>\n              The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n              <div style={titles}>\n                <PrismCode\n                  code={minDepth}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>9. Path Sum.</h3>\n              Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\n              <div style={titles}>\n                <PrismCode\n                  code={hasPathSum}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>10. Populating Next Right Pointers in Each Node.</h3>\n              Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\n              <br/>\n              Initially, all next pointers are set to NULL.\n              <br/>\n              <ul>\n                <li>You may only use constant extra space.</li>\n                <li>Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</li>\n              </ul>\n              <div style={titles}>\n                <PrismCode\n                  code={connect}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              \n            </List>\n          </Paper>\n        </Grid>\n      </Grid>\n    )\n  }\n}\n\nexport default (withStyles(styles)(Trees));\n"]},"metadata":{},"sourceType":"module"}