{"ast":null,"code":"var _jsxFileName = \"/home/mukeshs/Projects/edurights/src/components/algorithams/deepAlgorithams/graph.js\";\nimport React, { Component } from 'react';\nimport Prism from \"prismjs\";\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\nimport '../../ReactJs/styles.css';\nimport Sidebar from '../sidebar';\nimport PrismCode from '../../ReactJs/prismCode';\nimport Tree from '../../../assets/tree.gif';\nimport Graphs from '../../../assets/graph.jpg';\nconst titles = {\n  backgroundColor: '#F0F8FF',\n  padding: '1px',\n  fontSize: '16px'\n};\nconst redesign = {\n  height: 200,\n  width: 500\n};\n\nconst styles = theme => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1)\n  },\n  smMargin: {\n    margin: theme.spacing(1)\n  },\n  actionDiv: {\n    textAlign: \"center\"\n  }\n});\n\nconst graph = `class Graph {\n  constructor() {\n      this.adjacencyMap = {}\n  }\n\n  addVertex(v) {\n      this.adjacencyMap[v] = [];\n  }\n  \n  containsVertex(vertex) {\n      return typeof(this.adjacencyMap[vertex]) !== \"undefined\"\n  }\n  \n  addEdge(v, w) {\n      let result = false\n      if (this.containsVertex(v) && this.containsVertex(w)) {\n          this.adjacencyMap[v].push(w);\n          this.adjacencyMap[w].push(v);\n          result = true\n      }\n      return result\n  }\n\n  printGraph() {\n      let keys = Object.keys(this.adjacencyMap);\n      for (let i of keys) {\n          let values = this.adjacencyMap[i];\n          let vertex = \"\";\n          for (let j of values)\n              vertex += j + \" \";\n          console.log(i + \" -> \" + vertex);\n      }\n    }\n  }\n\nconst example = () => {\n  let g = new Graph()\n  g.addVertex(1)\n  g.addVertex(2)\n  g.addVertex(3)\n  g.addEdge(1, 2)\n  g.addEdge(1, 3)\n  g.printGraph()\n}`.trim();\nconst create = `\nfunction createGraph() {\n  return {\n    vertices: new Map(),\n  };\n}\n\nfunction addVertex(graph, vertex) {\n  if (!graph.vertices.has(vertex)) {\n    graph.vertices.set(vertex, []);\n  }\n  return graph;\n}\n\nfunction addEdge(graph, vertex1, vertex2) {\n  if (graph.vertices.has(vertex1) && graph.vertices.has(vertex2)) {\n    graph.vertices.get(vertex1).push(vertex2);\n    graph.vertices.get(vertex2).push(vertex1);\n  }\n  return graph;\n}\n\nconst graph = createGraph();\n\naddVertex(graph, 'A');\naddVertex(graph, 'B');\naddVertex(graph, 'C');\naddVertex(graph, 'D');\n\naddEdge(graph, 'A', 'B');\naddEdge(graph, 'B', 'C');\naddEdge(graph, 'C', 'D');\naddEdge(graph, 'D', 'A');\n\nconsole.log(graph);\n\n`.trim();\nconst removed = `\nfunction createGraph(){\n  return{\n    vertices:new Map()\n  }\n}\n\nfunction addVertices(graph, vertex){\n  if(!graph.vertices.has(vertex)){\n    graph.vertices.set(vertex,[])\n  }\n  return graph;\n}\n\nfunction addEdge(graph, vertext1, vertex2){\n  if(graph.vertices.has(vertext1) && graph.vertices.has(vertex2)){\n    graph.vertices.get(vertext1).push(vertex2);\n    graph.vertices.get(vertex2).push(vertext1);\n  }\n  return graph;\n}\n\nfunction removeVertex(graph, vertex) {\n  if (graph.vertices.has(vertex)) {\n    const neighbors = graph.vertices.get(vertex);\n    for (const neighbor of neighbors) {\n      const adjList = graph.vertices.get(neighbor);\n      const index = adjList.indexOf(vertex);\n      if (index !== -1) {\n        adjList.splice(index, 1);\n      }\n    }\n    graph.vertices.delete(vertex);\n  }\n  return graph;\n}\n\nfunction removeEdge(graph, vertex1, vertex2) {\n  if (graph.vertices.has(vertex1) && graph.vertices.has(vertex2)) {\n    const adjList1 = graph.vertices.get(vertex1);\n    const index1 = adjList1.indexOf(vertex2);\n    if (index1 !== -1) {\n      adjList1.splice(index1, 1);\n    }\n\n    const adjList2 = graph.vertices.get(vertex2);\n    const index2 = adjList2.indexOf(vertex1);\n    if (index2 !== -1) {\n      adjList2.splice(index2, 1);\n    }\n  }\n  return graph;\n}\n\nconst obj=createGraph()\naddVertices(obj, 'A');\naddVertices(obj, 'B');\naddVertices(obj, 'C');\n\naddEdge(obj, 'A','B')\naddEdge(obj, 'A','C')\nconsole.log(obj)\n\nremoveVertex(obj, 'B');\nconsole.log('Graph after removing B:');\nconsole.log(obj);\n`.trim(); // const create=``.trim();\n// const create=``.trim();\n\nclass Graph extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0);\n  }\n\n  render() {\n    const {\n      classes\n    } = this.props;\n    return React.createElement(Grid, {\n      container: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 198\n      },\n      __self: this\n    }, React.createElement(Grid, {\n      item: true,\n      xs: 2,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 199\n      },\n      __self: this\n    }, React.createElement(Paper, {\n      className: classes.paper,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 200\n      },\n      __self: this\n    }, React.createElement(\"h4\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 201\n      },\n      __self: this\n    }, React.createElement(Sidebar, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 201\n      },\n      __self: this\n    })))), React.createElement(Grid, {\n      item: true,\n      xs: 10,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 204\n      },\n      __self: this\n    }, React.createElement(Paper, {\n      className: classes.paper,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 205\n      },\n      __self: this\n    }, React.createElement(List, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 206\n      },\n      __self: this\n    }, React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 207\n      },\n      __self: this\n    }, \"Tree\"), React.createElement(\"img\", {\n      src: Tree,\n      alt: \"DeadLock\",\n      className: \"responsive\",\n      style: redesign,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 208\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 209\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 210\n      },\n      __self: this\n    }), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 212\n      },\n      __self: this\n    }, React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 213\n      },\n      __self: this\n    }, \"In Binary Search Tree is each node can have no more than two children. We can search for any value in logarithmic time because we can ignore one-half of the branching with each iteration. Inserting and deleting can also happen in logarithmic time. Moreover, the smallest and largest value can easily be found at the leftmost and rightmost leaf, respectively.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 220\n      },\n      __self: this\n    }, \"Traversal through the tree can happen in a vertical or horizontal procedure.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 221\n      },\n      __self: this\n    }, \"In DFT the vertical direction, Nodes traversed in.\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 222\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 223\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 225\n      },\n      __self: this\n    }, \"Depth-First Traversal (DFT): \"), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 226\n      },\n      __self: this\n    }, React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 227\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 227\n      },\n      __self: this\n    }, \"pre-order (Root, Left, Right): \"), \"1 2 4 5 3 \"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 228\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 228\n      },\n      __self: this\n    }, \"in-order (Left, Root, Right): \"), \"4 2 5 1 3 \"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 229\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 229\n      },\n      __self: this\n    }, \"post-order (Left, Right, Root): \"), \"4 5 2 3 1\")), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 231\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 232\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 233\n      },\n      __self: this\n    }, \"Breadth-First Traversal (BFT): \"), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 234\n      },\n      __self: this\n    }, React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 235\n      },\n      __self: this\n    }, \"Level order traversal of a tree is breadth first traversal for the tree.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 236\n      },\n      __self: this\n    }, \"BFT In the horizontal direction. This requires the use of a queue to track all the children nodes with each iteration. If the shape of a tree is wider than deep, BFT is a better choice than DFT.\"))), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 245\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 247\n      },\n      __self: this\n    }, \"Graph\"), React.createElement(\"img\", {\n      src: Graphs,\n      alt: \"DeadLock\",\n      className: \"responsive\",\n      style: redesign,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 248\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 249\n      },\n      __self: this\n    }), \"If a tree is free to have more than one parent, it becomes a Graph.\", React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 252\n      },\n      __self: this\n    }, React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 253\n      },\n      __self: this\n    }, \"Edges that connect nodes together in a graph can be directed/ undirected, weighted/ unweighted\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 254\n      },\n      __self: this\n    }, \"Edges that have both direction and weight are analogous to vectors.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 255\n      },\n      __self: this\n    }, \"Multiple inheritances in the form of Mixins and data objects that have many-to-many relationships produce graph structures.\"), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 259\n      },\n      __self: this\n    }, \"Ex. \"), \"Social network and the Internet.\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 261\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 263\n      },\n      __self: this\n    }, \"Create\"), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 264\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: create,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 265\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 271\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 273\n      },\n      __self: this\n    }, \"Remove\"), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 274\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: removed,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 275\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 281\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 283\n      },\n      __self: this\n    }), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 284\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: graph,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 285\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 291\n      },\n      __self: this\n    })))));\n  }\n\n}\n\nexport default withStyles(styles)(Graph);","map":{"version":3,"sources":["/home/mukeshs/Projects/edurights/src/components/algorithams/deepAlgorithams/graph.js"],"names":["React","Component","Prism","Grid","Paper","withStyles","List","Sidebar","PrismCode","Tree","Graphs","titles","backgroundColor","padding","fontSize","redesign","height","width","styles","theme","paper","margin","spacing","smMargin","actionDiv","textAlign","graph","trim","create","removed","Graph","componentDidMount","setTimeout","highlightAll","render","classes","props"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport Prism from \"prismjs\"\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\n\nimport '../../ReactJs/styles.css'\nimport Sidebar from '../sidebar';\nimport PrismCode from '../../ReactJs/prismCode';\n\nimport Tree from '../../../assets/tree.gif';\nimport Graphs from '../../../assets/graph.jpg';\n\n\nconst titles = { backgroundColor: '#F0F8FF', padding: '1px', fontSize: '16px' }\n\nconst redesign = {\n  height: 200,\n  width: 500\n}\n\nconst styles = theme => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1)\n  },\n  smMargin: {\n    margin: theme.spacing(1)\n  },\n  actionDiv: {\n    textAlign: \"center\"\n  }\n})\n\n\nconst graph = `class Graph {\n  constructor() {\n      this.adjacencyMap = {}\n  }\n\n  addVertex(v) {\n      this.adjacencyMap[v] = [];\n  }\n  \n  containsVertex(vertex) {\n      return typeof(this.adjacencyMap[vertex]) !== \"undefined\"\n  }\n  \n  addEdge(v, w) {\n      let result = false\n      if (this.containsVertex(v) && this.containsVertex(w)) {\n          this.adjacencyMap[v].push(w);\n          this.adjacencyMap[w].push(v);\n          result = true\n      }\n      return result\n  }\n\n  printGraph() {\n      let keys = Object.keys(this.adjacencyMap);\n      for (let i of keys) {\n          let values = this.adjacencyMap[i];\n          let vertex = \"\";\n          for (let j of values)\n              vertex += j + \" \";\n          console.log(i + \" -> \" + vertex);\n      }\n    }\n  }\n\nconst example = () => {\n  let g = new Graph()\n  g.addVertex(1)\n  g.addVertex(2)\n  g.addVertex(3)\n  g.addEdge(1, 2)\n  g.addEdge(1, 3)\n  g.printGraph()\n}`.trim()\n\nconst create=`\nfunction createGraph() {\n  return {\n    vertices: new Map(),\n  };\n}\n\nfunction addVertex(graph, vertex) {\n  if (!graph.vertices.has(vertex)) {\n    graph.vertices.set(vertex, []);\n  }\n  return graph;\n}\n\nfunction addEdge(graph, vertex1, vertex2) {\n  if (graph.vertices.has(vertex1) && graph.vertices.has(vertex2)) {\n    graph.vertices.get(vertex1).push(vertex2);\n    graph.vertices.get(vertex2).push(vertex1);\n  }\n  return graph;\n}\n\nconst graph = createGraph();\n\naddVertex(graph, 'A');\naddVertex(graph, 'B');\naddVertex(graph, 'C');\naddVertex(graph, 'D');\n\naddEdge(graph, 'A', 'B');\naddEdge(graph, 'B', 'C');\naddEdge(graph, 'C', 'D');\naddEdge(graph, 'D', 'A');\n\nconsole.log(graph);\n\n`.trim();\n\nconst removed=`\nfunction createGraph(){\n  return{\n    vertices:new Map()\n  }\n}\n\nfunction addVertices(graph, vertex){\n  if(!graph.vertices.has(vertex)){\n    graph.vertices.set(vertex,[])\n  }\n  return graph;\n}\n\nfunction addEdge(graph, vertext1, vertex2){\n  if(graph.vertices.has(vertext1) && graph.vertices.has(vertex2)){\n    graph.vertices.get(vertext1).push(vertex2);\n    graph.vertices.get(vertex2).push(vertext1);\n  }\n  return graph;\n}\n\nfunction removeVertex(graph, vertex) {\n  if (graph.vertices.has(vertex)) {\n    const neighbors = graph.vertices.get(vertex);\n    for (const neighbor of neighbors) {\n      const adjList = graph.vertices.get(neighbor);\n      const index = adjList.indexOf(vertex);\n      if (index !== -1) {\n        adjList.splice(index, 1);\n      }\n    }\n    graph.vertices.delete(vertex);\n  }\n  return graph;\n}\n\nfunction removeEdge(graph, vertex1, vertex2) {\n  if (graph.vertices.has(vertex1) && graph.vertices.has(vertex2)) {\n    const adjList1 = graph.vertices.get(vertex1);\n    const index1 = adjList1.indexOf(vertex2);\n    if (index1 !== -1) {\n      adjList1.splice(index1, 1);\n    }\n\n    const adjList2 = graph.vertices.get(vertex2);\n    const index2 = adjList2.indexOf(vertex1);\n    if (index2 !== -1) {\n      adjList2.splice(index2, 1);\n    }\n  }\n  return graph;\n}\n\nconst obj=createGraph()\naddVertices(obj, 'A');\naddVertices(obj, 'B');\naddVertices(obj, 'C');\n\naddEdge(obj, 'A','B')\naddEdge(obj, 'A','C')\nconsole.log(obj)\n\nremoveVertex(obj, 'B');\nconsole.log('Graph after removing B:');\nconsole.log(obj);\n`.trim();\n\n// const create=``.trim();\n\n// const create=``.trim();\n\n\n\nclass Graph extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0)\n  }\n  render() {\n    const { classes } = this.props;\n    return (\n      <Grid container>\n        <Grid item xs={2}>\n          <Paper className={classes.paper}>\n            <h4><Sidebar /></h4>\n          </Paper>\n        </Grid>\n        <Grid item xs={10}>\n          <Paper className={classes.paper}>\n            <List>\n              <h3>Tree</h3>\n              <img src={Tree} alt=\"DeadLock\" className=\"responsive\" style={redesign} />\n              <br />\n              <br />\n\n              <ul>\n                <li>\n                  In Binary Search Tree is each node can have no more than two children.\n                  We can search for any value in logarithmic time because we can ignore one-half of the branching with\n                  each iteration. Inserting and deleting can also happen in logarithmic time. Moreover, the\n                  smallest and largest value can easily be found at the leftmost and rightmost leaf,\n                  respectively.\n                </li>\n                <li>Traversal through the tree can happen in a vertical or horizontal procedure.</li>\n                <li>In DFT the vertical direction, Nodes traversed in.</li>\n                <br />\n                <br />\n\n                <b>Depth-First Traversal (DFT): </b>\n                <ul>\n                  <li><b>pre-order (Root, Left, Right): </b>1 2 4 5 3 </li>\n                  <li><b>in-order (Left, Root, Right): </b>4 2 5 1 3 </li>\n                  <li><b>post-order (Left, Right, Root): </b>4 5 2 3 1</li>\n                </ul>\n                <br />\n                <br />\n                <b>Breadth-First Traversal (BFT): </b>\n                <ul>\n                  <li>Level order traversal of a tree is breadth first traversal for the tree.</li>\n                  <li>\n                    BFT In the horizontal direction. This requires the use of a queue to\n                    track all the children nodes with each iteration.\n                    If the shape of a tree is wider than deep, BFT is a better choice than\n                    DFT.\n                  </li>\n                </ul>\n\n              </ul>\n              <br />\n\n              <h3>Graph</h3>\n              <img src={Graphs} alt=\"DeadLock\" className=\"responsive\" style={redesign} />\n              <br />\n              If a tree is free to have more than one parent, it becomes a Graph.\n\n              <ul>\n                <li>Edges that connect nodes together in a graph can be directed/ undirected, weighted/ unweighted</li>\n                <li>Edges that have both direction and weight are analogous to vectors.</li>\n                <li>\n                  Multiple inheritances in the form of Mixins and data objects that have many-to-many\n                  relationships produce graph structures.\n                </li>\n                <b>Ex. </b>Social network and the Internet.\n              </ul>\n              <br />\n\n              <h3>Create</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={create}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>Remove</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={removed}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3></h3>\n              <div style={titles}>\n                <PrismCode\n                  code={graph}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n            </List>\n          </Paper>\n        </Grid>\n      </Grid>\n    )\n  }\n}\n\nexport default (withStyles(styles)(Graph));\n"]},"metadata":{},"sourceType":"module"}