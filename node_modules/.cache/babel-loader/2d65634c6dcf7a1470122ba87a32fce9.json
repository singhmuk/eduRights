{"ast":null,"code":"var _jsxFileName = \"/home/mukeshs/Projects/edurights/src/components/algorithams/deepAlgorithams/linkedList.js\";\nimport React, { Component } from 'react';\nimport Prism from \"prismjs\";\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\nimport '../../ReactJs/styles.css';\nimport Sidebar from '../sidebar';\nimport PrismCode from '../../ReactJs/prismCode';\nconst titles = {\n  backgroundColor: '#F0F8FF',\n  padding: '1px',\n  fontSize: '16px'\n};\n\nconst styles = theme => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1)\n  },\n  smMargin: {\n    margin: theme.spacing(1)\n  },\n  actionDiv: {\n    textAlign: \"center\"\n  }\n});\n\nconst simple = `\nfunction createNode(data){\n  return{\n    data,\n    next:null\n  }\n}\n\nfunction linkedList(){\n  let head=null;\n\n  function add(data){\n    const newNode=createNode(data);\n    const newNode = { data, next: null };\n\n    if(!head){\n      head=newNode;\n    }else{\n      let current=head;\n      while(current.next){\n        current=current.next;\n      }\n      current.next=newNode;\n    }\n  }\n\n  function remove(data){\n    if(!head) return;\n    if(head.data === data){\n      head = head.next;\n    }\n\n    let current = head;\n    while(current.next){\n      if(current.next.data === data){\n        current.next =current.next.next;\n      }\n      current = current.next\n    }\n  }\n\n  function toArray(){\n    const result=[];\n    let current=head;\n    while(current){\n      result.push(current.data);\n      current=current.next;\n    }\n    return result;\n  }\n\n  return{ add, toArray, remove }\n}\n\nconst obj=new linkedList();\nobj.add(1);\nobj.add(2);\nobj.add(3);\nconsole.log(obj.toArray())\n \nobj.remove(2)\nconsole.log(obj.toArray())\n`.trim();\nconst hasCycle = `\nfunction createNode(data){\n  return{\n    data,\n    next:null\n  }\n}\n\nfunction linkedList(){\n  let head=null;\n\n  function add(data){\n    const newNode=createNode(data);\n\n    if(!head){\n      head=newNode;\n    }else{\n      let current=head;\n      while(current.next){\n        current=current.next;\n      }\n      current.next=newNode;\n    }\n  }\n\n  function toArray(){\n    const result=[];\n    let current=head;\n    while(current){\n      result.push(current.data);\n      current=current.next;\n    }\n    return result;\n  }\n\n  function makeCyclic(position){\n    if(position < 0) return;\n\n    let current=head;\n    let tail=null;\n    let index=0;\n\n    while(current && index < position){\n      tail=current;\n      current=current.next;\n      index++;\n    }\n\n    if(tail && current){\n      tail.next = current                // Make it cyclic\n    }\n  }\n\n  return{ add, toArray, makeCyclic }\n}\n\nconst obj=new linkedList();\nobj.add(1);\nobj.add(2);\nobj.add(3);\nconsole.log(obj.toArray())\n\nobj.makeCyclic(1);                      // Make it cyclic at position 1 (connecting 2 to 1)\n`.trim();\nconst removeNthFromEnd = `\nfunction createNode(data){\n  return{\n    data,\n    next:null\n  }\n}\n\nfunction linkedList(){\n  let head=null;\n\n  function add(data){\n    const newNode=createNode(data);\n\n    if(!head){\n      head=newNode;\n    }else{\n      let current=head;\n      while(current.next){\n        current=current.next;\n      }\n      current.next=newNode;\n    }\n  }\n\n  function toArray(){\n    const result=[];\n    let current=head;\n    while(current){\n      result.push(current.data);\n      current=current.next;\n    }\n    return result;\n  }\n\n  function removeNthFromEnd(n) {\n    if (n <= 0) {\n      return;\n    }\n\n    let fast = head;\n    let slow = head;\n    let prev = null;\n\n    // Move the fast pointer n nodes ahead\n    for (let i = 0; i < n; i++) {\n      if (fast === null) {\n        return; // Invalid input; n is greater than the length of the list\n      }\n      fast = fast.next;\n    }\n\n     // Move the fast and slow pointers simultaneously until fast reaches the end\n     while (fast !== null) {\n      prev = slow;\n      slow = slow.next;\n      fast = fast.next;\n    }\n\n    // Remove the Nth node by updating the pointers\n    if (prev === null) {\n      head = head.next; // If we're removing the first node\n    } else {\n      prev.next = slow.next;\n    }\n  }\n\n  return{ add, toArray, removeNthFromEnd }\n}\n\nconst obj=new linkedList();\nobj.add(1);\nobj.add(2);\nobj.add(3);\nobj.add(4);\nconsole.log(obj.toArray())\n\nobj.removeNthFromEnd(2); // Remove the 2nd node from the end\nconsole.log(obj.toArray()); \n`.trim();\nconst mergeTwoLists = `\nconst mergeTwoLists = (l1, l2) => {\n  const aux = (current1, current2, acc) => {\n    if (!current1) {\n      acc.next = current2\n      return acc\n    }\n    if (!current2) {\n      acc.next = current1\n      return acc\n    }\n    if (current1.val < current2.val) {\n      acc.next = {\n        val: current1.val,\n        next: null,\n      }\n      return aux(current1.next, current2, acc.next)\n    }\n    acc.next = {\n      val: current2.val,\n      next: null,\n    }\n    return aux(current2.next, current1, acc.next)\n  }\n  const head = { val: null, next: null }\n  aux(l1, l2, head)\n    return head.next\n}`.trim();\nconst swap = `const swap = (a, b, arr) => { \n  if (a !== b) {\n    const temp = arr[a]\n    arr[a] = arr[b] \n    arr[b] = temp \n  }\n}\n\nconst Heap = compareFn => (arr = []) => {\n  const left = index => 2 * index + 1\n  const right = index => 2 * index + 2\n  const parent = index => Math.floor((index - 1) / 2)\n  const size = () => arr.length\n\n  // log(n)\n  const heapify = (index) => {\n    const l = left(index)\n    const r = right(index)\n    let current = index\n    if ((l < size()) && compareFn(arr[current], arr[l]) > 0) {\n      current = l\n    }\n    if ((r < size()) && compareFn(arr[current], arr[r]) > 0) {\n      current = r\n    }\n    if (current !== index) {\n      swap(current, index, arr)\n      heapify(current)\n    }\n  }\n  // log(n)\n  const heapifyUp = (index) => {\n    const p = parent(index)\n    if (p >= 0 && compareFn(arr[p], arr[index]) > 0) {\n      swap(p, index, arr)\n      heapifyUp(p)\n    }\n  }\n  // O(n)\n  const buildHeap = () => {\n    for (let i = Math.floor(arr.length / 2); i >= 0; i--) {\n      heapify(i)\n    }\n  }\n  const extract = () => {\n    swap(0, arr.length - 1, arr)\n    const top = arr.pop()\n    heapify(0)\n    return top\n  }\n  const remove = (item) => {\n    const index = arr.findIndex(x => compareFn(x, item) === 0)\n    if (index === -1) {\n      return\n    }\n    arr[index] = arr.pop() // eslint-disable-line\n    const p = parent(index)\n    if (p < 0 || compareFn(p, arr[index]) < 0) {\n      heapify(index)\n    } else {\n      heapifyUp(index)\n    }\n  }\n  buildHeap()\n  return {\n    getHeap: () => arr,\n    peek: () => {\n      if (arr.length === 0) {\n        return null\n      }\n      return arr[0]\n    },\n    add: (item) => {\n      arr.push(item)\n      heapifyUp(arr.length - 1)\n    },\n    extract,\n    remove,\n    size,\n  }\n}\n\nconst mergeKLists = (lists = []) => {\n  const minHeap = Heap((a, b) => a.val - b.val)([])\n  lists.forEach((node) => {\n    if (node) {\n      minHeap.add(node)\n    }\n  })\n  const head = minHeap.extract() || null\n  let current = head\n  while (minHeap.size() > 0) {\n      console.log(minHeap.size())\n    if (current.next) {\n      minHeap.add(current.next)\n    }\n    current.next = minHeap.extract()\n    current = current.next\n  }\n  return head\n}\n\nconsole.log(swap([[1,4,5],[1,3,4],[2,6]]))`.trim();\n\nclass LinkedList extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0);\n  }\n\n  render() {\n    const {\n      classes\n    } = this.props;\n    return React.createElement(Grid, {\n      container: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 376\n      },\n      __self: this\n    }, React.createElement(Grid, {\n      item: true,\n      xs: 2,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 377\n      },\n      __self: this\n    }, React.createElement(Paper, {\n      className: classes.paper,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 378\n      },\n      __self: this\n    }, React.createElement(\"h4\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 379\n      },\n      __self: this\n    }, React.createElement(Sidebar, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 379\n      },\n      __self: this\n    })))), React.createElement(Grid, {\n      item: true,\n      xs: 10,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 382\n      },\n      __self: this\n    }, React.createElement(Paper, {\n      className: classes.paper,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 383\n      },\n      __self: this\n    }, React.createElement(List, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 384\n      },\n      __self: this\n    }, React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 385\n      },\n      __self: this\n    }, \"Linked List\"), React.createElement(\"ol\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 386\n      },\n      __self: this\n    }, React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 387\n      },\n      __self: this\n    }, \"Like arrays, Linked Lists store data elements in sequential order. Instead of keeping indexes, linked lists hold pointers to other elements. The first node is called the head while the last node is called the tail.\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 392\n      },\n      __self: this\n    }), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 394\n      },\n      __self: this\n    }, \"Linked lists have constant-time insertions and deletions because we can just change the pointers. To do the same operations in arrays requires linear time because subsequent items need to be shifted over.\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 399\n      },\n      __self: this\n    }), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 401\n      },\n      __self: this\n    }, \"Like arrays, linked lists can operate as stacks. It\\u2019s as simple as having the head be the only place for insertion and removal.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 404\n      },\n      __self: this\n    }), \"Linked lists can also operate as queues with the help of doubly-linked list, where insertion occurs at the tail and removal occurs at the head.\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 409\n      },\n      __self: this\n    }), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 411\n      },\n      __self: this\n    }, \"Linked lists are useful on both the client and server.\"), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 413\n      },\n      __self: this\n    }, React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 414\n      },\n      __self: this\n    }, \"On the client, state management libraries like Redux structure its middleware logic in a linked-list fashion. When actions are dispatched, they are piped from one middleware to the next until all is visited before reaching the reducers.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 416\n      },\n      __self: this\n    }, \"On the server, web frameworks like Express also structure its middleware logic in a similar fashion. When a request is received, it is piped from one middleware to the next until a response is issued.\")), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 419\n      },\n      __self: this\n    }), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 421\n      },\n      __self: this\n    }, \"Links in a linked list do not have indexes.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 422\n      },\n      __self: this\n    }, \"A linked list grows and shrinks as it is edited. Do not need to predetermine it's size.\")), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 424\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 426\n      },\n      __self: this\n    }, \"Functions -\"), \" add, remove, indexOf, elementAt, addAt, removeAt, view.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 427\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 429\n      },\n      __self: this\n    }, \"Linked list\"), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 430\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: simple,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 431\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 437\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 440\n      },\n      __self: this\n    }, \"1. Linked List Cycle.\"), \"Given head, the head of a linked list, determine if the linked list has a cycle in it.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 442\n      },\n      __self: this\n    }), \"There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 444\n      },\n      __self: this\n    }), \"Return true if there is a cycle in the linked list. Otherwise, return false\", React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 446\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: hasCycle,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 447\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 453\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 455\n      },\n      __self: this\n    }, \"4. Remove Nth Node From End of List\"), \"To remove the Nth node from the end of a singly linked list, you can use a two-pointer approach.\", React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 457\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: removeNthFromEnd,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 458\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 464\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 466\n      },\n      __self: this\n    }, \"break\"), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 467\n      },\n      __self: this\n    }, \"6. Merge Two Sorted Lists.\"), \"Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.\", React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 469\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: mergeTwoLists,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 470\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 476\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 478\n      },\n      __self: this\n    }, \"8. Merge k Sorted Lists.\"), \"You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 480\n      },\n      __self: this\n    }), \"Merge all the linked-lists into one sorted linked-list and return it.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 481\n      },\n      __self: this\n    }), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 481\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 483\n      },\n      __self: this\n    }, \"Example: \"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 483\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 485\n      },\n      __self: this\n    }, \"Input: \"), \"lists = [[1,4,5],[1,3,4],[2,6]]\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 485\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 486\n      },\n      __self: this\n    }, \"Output: \"), \"[1,1,2,3,4,4,5,6]\", React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 487\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: swap,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 488\n      },\n      __self: this\n    }))))));\n  }\n\n}\n\nexport default withStyles(styles)(LinkedList);","map":{"version":3,"sources":["/home/mukeshs/Projects/edurights/src/components/algorithams/deepAlgorithams/linkedList.js"],"names":["React","Component","Prism","Grid","Paper","withStyles","List","Sidebar","PrismCode","titles","backgroundColor","padding","fontSize","styles","theme","paper","margin","spacing","smMargin","actionDiv","textAlign","simple","trim","hasCycle","removeNthFromEnd","mergeTwoLists","swap","LinkedList","componentDidMount","setTimeout","highlightAll","render","classes","props"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport Prism from \"prismjs\"\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\n\nimport '../../ReactJs/styles.css'\nimport Sidebar from '../sidebar';\nimport PrismCode from '../../ReactJs/prismCode';\n\n\nconst titles = { backgroundColor: '#F0F8FF', padding: '1px', fontSize: '16px' }\n\nconst styles = theme => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1)\n  },\n  smMargin: {\n    margin: theme.spacing(1)\n  },\n  actionDiv: {\n    textAlign: \"center\"\n  }\n})\n\nconst simple = `\nfunction createNode(data){\n  return{\n    data,\n    next:null\n  }\n}\n\nfunction linkedList(){\n  let head=null;\n\n  function add(data){\n    const newNode=createNode(data);\n    const newNode = { data, next: null };\n\n    if(!head){\n      head=newNode;\n    }else{\n      let current=head;\n      while(current.next){\n        current=current.next;\n      }\n      current.next=newNode;\n    }\n  }\n\n  function remove(data){\n    if(!head) return;\n    if(head.data === data){\n      head = head.next;\n    }\n\n    let current = head;\n    while(current.next){\n      if(current.next.data === data){\n        current.next =current.next.next;\n      }\n      current = current.next\n    }\n  }\n\n  function toArray(){\n    const result=[];\n    let current=head;\n    while(current){\n      result.push(current.data);\n      current=current.next;\n    }\n    return result;\n  }\n\n  return{ add, toArray, remove }\n}\n\nconst obj=new linkedList();\nobj.add(1);\nobj.add(2);\nobj.add(3);\nconsole.log(obj.toArray())\n \nobj.remove(2)\nconsole.log(obj.toArray())\n`.trim();\n\nconst hasCycle = `\nfunction createNode(data){\n  return{\n    data,\n    next:null\n  }\n}\n\nfunction linkedList(){\n  let head=null;\n\n  function add(data){\n    const newNode=createNode(data);\n\n    if(!head){\n      head=newNode;\n    }else{\n      let current=head;\n      while(current.next){\n        current=current.next;\n      }\n      current.next=newNode;\n    }\n  }\n\n  function toArray(){\n    const result=[];\n    let current=head;\n    while(current){\n      result.push(current.data);\n      current=current.next;\n    }\n    return result;\n  }\n\n  function makeCyclic(position){\n    if(position < 0) return;\n\n    let current=head;\n    let tail=null;\n    let index=0;\n\n    while(current && index < position){\n      tail=current;\n      current=current.next;\n      index++;\n    }\n\n    if(tail && current){\n      tail.next = current                // Make it cyclic\n    }\n  }\n\n  return{ add, toArray, makeCyclic }\n}\n\nconst obj=new linkedList();\nobj.add(1);\nobj.add(2);\nobj.add(3);\nconsole.log(obj.toArray())\n\nobj.makeCyclic(1);                      // Make it cyclic at position 1 (connecting 2 to 1)\n`.trim();\n\nconst removeNthFromEnd = `\nfunction createNode(data){\n  return{\n    data,\n    next:null\n  }\n}\n\nfunction linkedList(){\n  let head=null;\n\n  function add(data){\n    const newNode=createNode(data);\n\n    if(!head){\n      head=newNode;\n    }else{\n      let current=head;\n      while(current.next){\n        current=current.next;\n      }\n      current.next=newNode;\n    }\n  }\n\n  function toArray(){\n    const result=[];\n    let current=head;\n    while(current){\n      result.push(current.data);\n      current=current.next;\n    }\n    return result;\n  }\n\n  function removeNthFromEnd(n) {\n    if (n <= 0) {\n      return;\n    }\n\n    let fast = head;\n    let slow = head;\n    let prev = null;\n\n    // Move the fast pointer n nodes ahead\n    for (let i = 0; i < n; i++) {\n      if (fast === null) {\n        return; // Invalid input; n is greater than the length of the list\n      }\n      fast = fast.next;\n    }\n\n     // Move the fast and slow pointers simultaneously until fast reaches the end\n     while (fast !== null) {\n      prev = slow;\n      slow = slow.next;\n      fast = fast.next;\n    }\n\n    // Remove the Nth node by updating the pointers\n    if (prev === null) {\n      head = head.next; // If we're removing the first node\n    } else {\n      prev.next = slow.next;\n    }\n  }\n\n  return{ add, toArray, removeNthFromEnd }\n}\n\nconst obj=new linkedList();\nobj.add(1);\nobj.add(2);\nobj.add(3);\nobj.add(4);\nconsole.log(obj.toArray())\n\nobj.removeNthFromEnd(2); // Remove the 2nd node from the end\nconsole.log(obj.toArray()); \n`.trim();\n\nconst mergeTwoLists = `\nconst mergeTwoLists = (l1, l2) => {\n  const aux = (current1, current2, acc) => {\n    if (!current1) {\n      acc.next = current2\n      return acc\n    }\n    if (!current2) {\n      acc.next = current1\n      return acc\n    }\n    if (current1.val < current2.val) {\n      acc.next = {\n        val: current1.val,\n        next: null,\n      }\n      return aux(current1.next, current2, acc.next)\n    }\n    acc.next = {\n      val: current2.val,\n      next: null,\n    }\n    return aux(current2.next, current1, acc.next)\n  }\n  const head = { val: null, next: null }\n  aux(l1, l2, head)\n    return head.next\n}`.trim();\n\nconst swap = `const swap = (a, b, arr) => { \n  if (a !== b) {\n    const temp = arr[a]\n    arr[a] = arr[b] \n    arr[b] = temp \n  }\n}\n\nconst Heap = compareFn => (arr = []) => {\n  const left = index => 2 * index + 1\n  const right = index => 2 * index + 2\n  const parent = index => Math.floor((index - 1) / 2)\n  const size = () => arr.length\n\n  // log(n)\n  const heapify = (index) => {\n    const l = left(index)\n    const r = right(index)\n    let current = index\n    if ((l < size()) && compareFn(arr[current], arr[l]) > 0) {\n      current = l\n    }\n    if ((r < size()) && compareFn(arr[current], arr[r]) > 0) {\n      current = r\n    }\n    if (current !== index) {\n      swap(current, index, arr)\n      heapify(current)\n    }\n  }\n  // log(n)\n  const heapifyUp = (index) => {\n    const p = parent(index)\n    if (p >= 0 && compareFn(arr[p], arr[index]) > 0) {\n      swap(p, index, arr)\n      heapifyUp(p)\n    }\n  }\n  // O(n)\n  const buildHeap = () => {\n    for (let i = Math.floor(arr.length / 2); i >= 0; i--) {\n      heapify(i)\n    }\n  }\n  const extract = () => {\n    swap(0, arr.length - 1, arr)\n    const top = arr.pop()\n    heapify(0)\n    return top\n  }\n  const remove = (item) => {\n    const index = arr.findIndex(x => compareFn(x, item) === 0)\n    if (index === -1) {\n      return\n    }\n    arr[index] = arr.pop() // eslint-disable-line\n    const p = parent(index)\n    if (p < 0 || compareFn(p, arr[index]) < 0) {\n      heapify(index)\n    } else {\n      heapifyUp(index)\n    }\n  }\n  buildHeap()\n  return {\n    getHeap: () => arr,\n    peek: () => {\n      if (arr.length === 0) {\n        return null\n      }\n      return arr[0]\n    },\n    add: (item) => {\n      arr.push(item)\n      heapifyUp(arr.length - 1)\n    },\n    extract,\n    remove,\n    size,\n  }\n}\n\nconst mergeKLists = (lists = []) => {\n  const minHeap = Heap((a, b) => a.val - b.val)([])\n  lists.forEach((node) => {\n    if (node) {\n      minHeap.add(node)\n    }\n  })\n  const head = minHeap.extract() || null\n  let current = head\n  while (minHeap.size() > 0) {\n      console.log(minHeap.size())\n    if (current.next) {\n      minHeap.add(current.next)\n    }\n    current.next = minHeap.extract()\n    current = current.next\n  }\n  return head\n}\n\nconsole.log(swap([[1,4,5],[1,3,4],[2,6]]))`.trim();\n\n\nclass LinkedList extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0)\n  }\n  render() {\n    const { classes } = this.props;\n    return (\n      <Grid container>\n        <Grid item xs={2}>\n          <Paper className={classes.paper}>\n            <h4><Sidebar /></h4>\n          </Paper>\n        </Grid>\n        <Grid item xs={10}>\n          <Paper className={classes.paper}>\n            <List>\n              <h3>Linked List</h3>\n              <ol>\n                <li>\n                  Like arrays, Linked Lists store data elements in sequential order. Instead of keeping\n                  indexes, linked lists hold pointers to other elements. The first node is called the\n                  head while the last node is called the tail.\n                </li>\n                <br />\n\n                <li>\n                  Linked lists have constant-time insertions and deletions because we can just change the\n                  pointers. To do the same operations in arrays requires linear time because subsequent\n                  items need to be shifted over.\n                </li>\n                <br />\n\n                <li>\n                  Like arrays, linked lists can operate as stacks. Itâ€™s as simple as having the head be the\n                  only place for insertion and removal.\n                  <br />\n\n                  Linked lists can also operate as queues with the help of doubly-linked list, where insertion occurs at the tail and removal\n                  occurs at the head.\n                </li>\n                <br />\n\n                <li>\n                  Linked lists are useful on both the client and server.</li>\n                <ul>\n                  <li>On the client, state management libraries like Redux structure its middleware logic in a linked-list fashion. When\n                    actions are dispatched, they are piped from one middleware to the next until all is visited before reaching the reducers.</li>\n                  <li>On the server, web frameworks like Express also structure its middleware logic in a similar fashion. When a request is received,\n                    it is piped from one middleware to the next until a response is issued.</li>\n                </ul>\n                <br />\n\n                <li>Links in a linked list do not have indexes.</li>\n                <li>A linked list grows and shrinks as it is edited. Do not need to predetermine it's size.</li>\n              </ol>\n              <br />\n\n              <b>Functions -</b> add, remove, indexOf, elementAt, addAt, removeAt, view.\n              <br />\n\n              <h3>Linked list</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={simple}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              \n              <h3>1. Linked List Cycle.</h3>\n              Given head, the head of a linked list, determine if the linked list has a cycle in it.\n              <br />\n              There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\n              <br />\n              Return true if there is a cycle in the linked list. Otherwise, return false\n              <div style={titles}>\n                <PrismCode\n                  code={hasCycle}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3>4. Remove Nth Node From End of List</h3>\n              To remove the Nth node from the end of a singly linked list, you can use a two-pointer approach. \n              <div style={titles}>\n                <PrismCode\n                  code={removeNthFromEnd}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <b>break</b>\n              <h3>6. Merge Two Sorted Lists.</h3>\n              Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.\n              <div style={titles}>\n                <PrismCode\n                  code={mergeTwoLists}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>8. Merge k Sorted Lists.</h3>\n                You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n                <br/>\n                Merge all the linked-lists into one sorted linked-list and return it.<br/><br/>\n\n                <b>Example: </b><br/>\n\n                <b>Input: </b>lists = [[1,4,5],[1,3,4],[2,6]]<br/>\n                <b>Output: </b>[1,1,2,3,4,4,5,6]\n              <div style={titles}>\n                <PrismCode\n                  code={swap}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n            </List>\n          </Paper>\n        </Grid>\n      </Grid>\n    )\n  }\n}\n\nexport default (withStyles(styles)(LinkedList));\n"]},"metadata":{},"sourceType":"module"}