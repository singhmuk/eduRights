{"ast":null,"code":"import _classCallCheck from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/createClass\";import _possibleConstructorReturn from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";import _getPrototypeOf from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";import _inherits from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/inherits\";import React,{Component}from\"react\";import Prism from\"prismjs\";import{Grid,Paper,withStyles,List}from\"@material-ui/core\";import\"../../ReactJs/styles.css\";import Sidebar from\"../sidebar\";import PrismCode from\"../../ReactJs/prismCode\";var titles={backgroundColor:\"#F0F8FF\",padding:\"1px\",fontSize:\"16px\"};var styles=function styles(theme){return{paper:{margin:theme.spacing(1),padding:theme.spacing(1)},smMargin:{margin:theme.spacing(1)},actionDiv:{textAlign:\"center\"}};};var DepenInjection=/*#__PURE__*/function(_Component){_inherits(DepenInjection,_Component);function DepenInjection(){_classCallCheck(this,DepenInjection);return _possibleConstructorReturn(this,_getPrototypeOf(DepenInjection).apply(this,arguments));}_createClass(DepenInjection,[{key:\"componentDidMount\",value:function componentDidMount(){setTimeout(function(){return Prism.highlightAll();},0);}},{key:\"render\",value:function render(){var classes=this.props.classes;return React.createElement(Grid,{container:true},React.createElement(Grid,{item:true,xs:2},React.createElement(Paper,{className:classes.paper},React.createElement(\"h4\",null,React.createElement(Sidebar,null)))),React.createElement(Grid,{item:true,xs:10},React.createElement(Paper,{className:classes.paper},React.createElement(List,null,React.createElement(\"h3\",null,\"1. How does an Angular application work?\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Every Angular app consists of a file named\\xA0angular.json. This file will contain all the configurations of the app. While building the app, the builder looks at this file to find the entry point of the application.\\xA0\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"AppModule\\xA0is getting bootstrapped. The AppModule is declared in the app.module.ts file. This module contains declarations of all the components.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"Now, AppComponent\\xA0is getting bootstrapped.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Initialization: \"),\"When an Angular application is loaded in the browser, the main.ts file is executed, which initializes the application and bootstraps the root module.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"When an Angular application is launched, the main component is loaded, which in turn loads the other components and services that the application requires. The main component is typically called AppComponent and is defined in the app.component.ts file.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"Angular uses a reactive programming approach based on the Observable design pattern to handle events and data streams. This means that the application subscribes to data streams and reacts to changes as they occur, rather than polling for changes at regular intervals.\")),React.createElement(\"br\",null),React.createElement(\"b\",null,\"index.html \"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"The index.html file is the main entry point for an Angular application. When a user navigates to the URL of an Angular application, the web server serves the index.html file, which is loaded into the browser.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"The index.html file contains the necessary scripts and stylesheets that are required to load the Angular application into the browser. It also includes a 'base' tag, which is used by Angular's router to determine the base URL for the application.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"The main app component is usually loaded inside a 'div' element with an id of app-root in the index.html file. This component acts as the root of the application and is responsible for loading and rendering other components in the application.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"In addition to loading the Angular application, the index.html file can also be used to add any other necessary HTML, CSS, or JavaScript to the application, such as third-party libraries or custom stylesheets.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"Overall, the index.html file is an important part of an Angular application, as it serves as the entry point for the application and contains the necessary scripts and stylesheets to load the application into the browser.\")),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"2. What is AOT compilation? What are the advantages of AOT?\"),\"Every Angular application consists of components and templates which the browser cannot understand. Therefore, all the Angular applications need to be compiled first before running inside the browser.\",React.createElement(\"br\",null),\"Angular provides two types of compilation:\",React.createElement(\"ul\",null,React.createElement(\"li\",null,\"JIT(Just-in-Time) compilation\"),React.createElement(\"li\",null,\"AOT(Ahead-of-Time) compilation\")),React.createElement(\"br\",null),\"The advantages of using AOT compilation are:\",React.createElement(\"ul\",null,React.createElement(\"li\",null,React.createElement(\"b\",null,\"Faster rendering: \"),\"The browser downloads a pre-compiled version of the application. So it can render the application immediately without compiling the app.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Fewer asynchronous requests: \"),\"It inlines external HTML templates and CSS style sheets within the application javascript which eliminates separate ajax requests.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Smaller Angular framework download size: \"),\"Doesn't require downloading the Angular compiler. Hence it dramatically reduces the application payload.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Detect template errors earlie: \"),\"Detects and reports template binding errors during the build step itself\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Better security: \"),\"It compiles HTML templates and components into JavaScript. So there won't be any injection attacks.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"By default, angular builds and serves the application using JIT compiler:\",React.createElement(\"ul\",null,React.createElement(\"li\",null,\"ng build\"),React.createElement(\"li\",null,\"ng serve\"))),React.createElement(\"br\",null),React.createElement(\"li\",null,\"For using AOT compiler following changes should be made:\",React.createElement(\"ul\",null,React.createElement(\"li\",null,\"ng build --aot\"),React.createElement(\"li\",null,\"ng serve --aot\")))),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"3. What are the three phases of AOT\"),\"The AOT compiler works in three phases\",React.createElement(\"ul\",null,React.createElement(\"li\",null,React.createElement(\"b\",null,\"Code Analysis: \"),\"The TypeScript compiler and AOT collector create a representation of the source.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Code generation: \"),\"It handles the interpretation as well as places restrictions on what it interprets.\"),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Validation: \"),\"Angular template compiler uses the TypeScript compiler to validate the binding expressions in templates.\")),React.createElement(\"br\",null),\"If true, the AOT compiler will ignore this directive/ component and will therefore always be compiled using JIT.\",React.createElement(\"br\",null),React.createElement(\"b\",null,\"jit: true\"),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"4. Can I use any javascript feature for expression syntax in AOT\"),\"No, the AOT collector understands limited JavaScript features. If an expression uses unsupported syntax, the collector writes an error node to the .metadata.json file. Later point of time, the compiler reports an error if it needs that piece of metadata to generate the application code.\",React.createElement(\"br\",null),React.createElement(\"h3\",null,\"5. JIT compilation: \"),\"Just-in-Time is a type of compilation that compiles your app in the browser at runtime. JIT compilation is the default when you run the ng build or ng serve.\",React.createElement(\"ul\",null,React.createElement(\"li\",null,\"A JIT compiler runs after the program has started and compiles the code (usually bytecode or some kind of VM instructions). A JIT has access to dynamic runtime information whereas a standard compiler doesn't and can make better optimizations like inlining functions that are used frequently.\"),React.createElement(\"li\",null,\"This is in contrast to a traditional compiler that compiles all the code to machine language before the program is first run.\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"6. Ivy Compiler\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Ivy is now default compiler and runtime. Ivy improves budle size, allows for better debugging, adds improves type checking, faster testing, enables the AOT compiler on by default, and improves CSS class and style binding.\"),React.createElement(\"li\",null,\"Reach better build times.\"),React.createElement(\"li\",null,\"reach better build sizes (with a generated code more compatible with tree-shaking).\"),React.createElement(\"li\",null,\"Unlock new potential features (metaprogramming or higher order components, lazy loading of component instead of modules).\")),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"7. What is metadata rewriting\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Metadata rewriting in Angular refers to the process of modifying the metadata associated with a class or component during the build process. Metadata in Angular is defined using decorators, which are special functions that modify the behavior of a class or component.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"During the build process, Angular's compiler analyzes the application's source code and generates an optimized version of the application's JavaScript code. As part of this process, the compiler can also modify the metadata associated with the application's components.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"Metadata rewriting is used to add or modify the metadata of a component, such as changing the selector, modifying the template or styles, or adding new input or output properties. This can be useful in situations where the component needs to be customized or extended for a specific use case.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"For example, suppose you have a third-party library that provides a component that you want to use in your Angular application. However, the component's selector conflicts with another component in your application, and you cannot change the selector of either component. In this case, you can use metadata rewriting to modify the selector of the third-party component during the build process, so that it does not conflict with the other component.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"Overall, metadata rewriting is a powerful feature of Angular that allows developers to modify the metadata associated with a component during the build process. This can be useful in a variety of situations, such as customizing third-party components, optimizing component performance, or adding new functionality to existing components.\")),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"8. Explain the purpose of Service Workers in Angular\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Service Workers are implemented using the @angular/service-worker package. This package provides a set of tools and utilities for configuring and deploying a Service Worker in an Angular application.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"The purpose of Service Workers in Angular is to provide advanced caching and offline capabilities to web applications. By intercepting network requests and caching responses, Service Workers can greatly reduce the amount of data that needs to be downloaded and improve the performance of the application. They can also provide offline support, allowing users to continue using the application even when they are not connected to the internet.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"Service Workers can also be used to provide push notifications and background synchronization, which can be useful for applications that need to update data in real-time.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"Overall, the purpose of Service Workers in Angular is to provide advanced caching, offline, and real-time capabilities to web applications. By leveraging Service Workers, developers can create faster, more reliable, and more engaging web applications that can work seamlessly across different devices and network conditions.\")),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"9. What are the design goals of service workers\"),\"Service workers in Angular are designed to help developers build progressive web applications (PWAs) that are reliable, fast, and engaging. The primary design goals of service workers in Angular are as follows:\",React.createElement(\"ul\",null,React.createElement(\"li\",null,React.createElement(\"b\",null,\"Offline support: \"),\"Service workers allow Angular applications to work offline by caching assets and data that are necessary for the application to function.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Performance: \"),\"Service workers can improve the performance of Angular applications by caching assets and data on the client-side, reducing the number of requests that need to be made to the server. This can lead to faster load times and a smoother user experience.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Push notifications: \"),\"Service workers enable Angular applications to send push notifications to users, even when the application is not open in the user's browser. This can be used to keep users engaged with the application and to provide timely updates.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Security: \"),\"Service workers are designed to be secure and reliable. They run in a separate context from the main application and cannot access sensitive user data or resources without permission.\")),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"10. Difference between local storage, cookies and Session.\"),\"In Angular, there are three common ways to store data on the client-side: local storage, cookies, and session storage. Each has its own advantages and disadvantages, and the choice of which to use depends on the specific needs of the application.\",React.createElement(\"ul\",null,React.createElement(\"li\",null,React.createElement(\"b\",null,\"Local Storage: \"),\"Local storage is a key-value store that allows data to be stored on the client-side in a persistent manner. The data stored in local storage is accessible even after the browser is closed, and can be accessed by any page in the same domain. Local storage is a good option for storing large amounts of data that need to persist between sessions.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Cookies: \"),\"Cookies are small text files that are stored on the client-side by the browser. Cookies can be used to store small amounts of data, such as user preferences or authentication tokens. Cookies are accessible by any page in the same domain and can be set to expire after a certain period of time.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Session Storage: \"),\"Session storage is similar to local storage, but the data stored in session storage is only accessible within the current browser session. Once the browser is closed, the data is deleted. Session storage is a good option for storing data that needs to be accessible across multiple pages within the same session, but does not need to persist between sessions.\")),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"11. What is authentication and authorization in Angular.\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,React.createElement(\"b\",null,\"Authentication: \"),\"During login, the credential are sent to an authentication API. This API is present on the server and validation is done there. After a JWT is returned, this token has information about the usr and is used to identify the user. This process is called Authentication.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Authorization: \"),\"After authentication, user are given various levels of permission/ access. Some users may have access to all the pages and some might not. This process of restricting the content is called Authorization.\")),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"12. How we handle large data api in frontend.\"),\"Pagination, infinite scroll\"))));}}]);return DepenInjection;}(Component);export default withStyles(styles)(DepenInjection);","map":{"version":3,"sources":["/home/mukeshs/Projects/edurights/src/components/angularjsd/deepAngularjs/depenInjection.js"],"names":["React","Component","Prism","Grid","Paper","withStyles","List","Sidebar","PrismCode","titles","backgroundColor","padding","fontSize","styles","theme","paper","margin","spacing","smMargin","actionDiv","textAlign","DepenInjection","setTimeout","highlightAll","classes","props"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport Prism from \"prismjs\";\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\n\nimport \"../../ReactJs/styles.css\";\nimport Sidebar from \"../sidebar\";\nimport PrismCode from \"../../ReactJs/prismCode\";\n\nconst titles = { backgroundColor: \"#F0F8FF\", padding: \"1px\", fontSize: \"16px\" };\n\nconst styles = (theme) => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1),\n  },\n  smMargin: {\n    margin: theme.spacing(1),\n  },\n  actionDiv: {\n    textAlign: \"center\",\n  },\n});\n\nclass DepenInjection extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0);\n  }\n  render() {\n    const { classes } = this.props;\n    return (\n      <Grid container>\n        <Grid item xs={2}>\n          <Paper className={classes.paper}>\n            <h4>\n              <Sidebar />\n            </h4>\n          </Paper>\n        </Grid>\n        <Grid item xs={10}>\n          <Paper className={classes.paper}>\n            <List>\n              <h3>1. How does an Angular application work?</h3>\n              <ul>\n                <li>\n                  Every Angular app consists of a file named angular.json. This\n                  file will contain all the configurations of the app. While\n                  building the app, the builder looks at this file to find the\n                  entry point of the application. \n                </li>\n                <br />\n                <li>\n                  AppModule is getting bootstrapped. The AppModule is declared\n                  in the app.module.ts file. This module contains declarations\n                  of all the components.\n                </li>\n                <br />\n                <li>Now, AppComponent is getting bootstrapped.</li>\n                <br />\n                <li>\n                  <b>Initialization: </b>When an Angular application is loaded\n                  in the browser, the main.ts file is executed, which\n                  initializes the application and bootstraps the root module.\n                </li>\n                <br />\n\n                <li>\n                  When an Angular application is launched, the main component is\n                  loaded, which in turn loads the other components and services\n                  that the application requires. The main component is typically\n                  called AppComponent and is defined in the app.component.ts\n                  file.\n                </li>\n                <br />\n                <li>\n                  Angular uses a reactive programming approach based on the\n                  Observable design pattern to handle events and data streams.\n                  This means that the application subscribes to data streams and\n                  reacts to changes as they occur, rather than polling for\n                  changes at regular intervals.\n                </li>\n              </ul>\n              <br />\n              <b>index.html </b>\n              <ul>\n                <li>\n                  The index.html file is the main entry point for an Angular\n                  application. When a user navigates to the URL of an Angular\n                  application, the web server serves the index.html file, which\n                  is loaded into the browser.\n                </li>\n                <br />\n                <li>\n                  The index.html file contains the necessary scripts and\n                  stylesheets that are required to load the Angular application\n                  into the browser. It also includes a 'base' tag, which is used\n                  by Angular's router to determine the base URL for the\n                  application.\n                </li>\n                <br />\n                <li>\n                  The main app component is usually loaded inside a 'div'\n                  element with an id of app-root in the index.html file. This\n                  component acts as the root of the application and is\n                  responsible for loading and rendering other components in the\n                  application.\n                </li>\n                <br />\n                <li>\n                  In addition to loading the Angular application, the index.html\n                  file can also be used to add any other necessary HTML, CSS, or\n                  JavaScript to the application, such as third-party libraries\n                  or custom stylesheets.\n                </li>\n                <br />\n                <li>\n                  Overall, the index.html file is an important part of an\n                  Angular application, as it serves as the entry point for the\n                  application and contains the necessary scripts and stylesheets\n                  to load the application into the browser.\n                </li>\n              </ul>\n              <br />\n              <br />\n              <h3>\n                2. What is AOT compilation? What are the advantages of AOT?\n              </h3>\n              Every Angular application consists of components and templates\n              which the browser cannot understand. Therefore, all the Angular\n              applications need to be compiled first before running inside the\n              browser.\n              <br />\n              Angular provides two types of compilation:\n              <ul>\n                <li>JIT(Just-in-Time) compilation</li>\n                <li>AOT(Ahead-of-Time) compilation</li>\n              </ul>\n              <br />\n              The advantages of using AOT compilation are:\n              <ul>\n                <li>\n                  <b>Faster rendering: </b>The browser downloads a pre-compiled\n                  version of the application. So it can render the application\n                  immediately without compiling the app.\n                </li>\n                <li>\n                  <b>Fewer asynchronous requests: </b>It inlines external HTML\n                  templates and CSS style sheets within the application\n                  javascript which eliminates separate ajax requests.\n                </li>\n                <li>\n                  <b>Smaller Angular framework download size: </b>Doesn't\n                  require downloading the Angular compiler. Hence it\n                  dramatically reduces the application payload.\n                </li>\n                <li>\n                  <b>Detect template errors earlie: </b>Detects and reports\n                  template binding errors during the build step itself\n                </li>\n                <li>\n                  <b>Better security: </b>It compiles HTML templates and\n                  components into JavaScript. So there won't be any injection\n                  attacks.\n                </li>\n                <br />\n                <li>\n                  By default, angular builds and serves the application using\n                  JIT compiler:\n                  <ul>\n                    <li>ng build</li>\n                    <li>ng serve</li>\n                  </ul>\n                </li>\n                <br />\n                <li>\n                  For using AOT compiler following changes should be made:\n                  <ul>\n                    <li>ng build --aot</li>\n                    <li>ng serve --aot</li>\n                  </ul>\n                </li>\n              </ul>\n              <br />\n              <h3>3. What are the three phases of AOT</h3>\n              The AOT compiler works in three phases\n              <ul>\n                <li>\n                  <b>Code Analysis: </b>The TypeScript compiler and AOT\n                  collector create a representation of the source.\n                </li>\n                <li>\n                  <b>Code generation: </b>It handles the interpretation as well\n                  as places restrictions on what it interprets.\n                </li>\n                <li>\n                  <b>Validation: </b>Angular template compiler uses the\n                  TypeScript compiler to validate the binding expressions in\n                  templates.\n                </li>\n              </ul>\n              <br />\n              If true, the AOT compiler will ignore this directive/ component\n              and will therefore always be compiled using JIT.\n              <br />\n              <b>jit: true</b>\n              <br />\n              <br />\n              <h3>\n                4. Can I use any javascript feature for expression syntax in AOT\n              </h3>\n              No, the AOT collector understands limited JavaScript features. If\n              an expression uses unsupported syntax, the collector writes an\n              error node to the .metadata.json file. Later point of time, the\n              compiler reports an error if it needs that piece of metadata to\n              generate the application code.\n              <br />\n              <h3>5. JIT compilation: </h3>\n              Just-in-Time is a type of compilation that compiles your app in\n              the browser at runtime. JIT compilation is the default when you\n              run the ng build or ng serve.\n              <ul>\n                <li>\n                  A JIT compiler runs after the program has started and compiles\n                  the code (usually bytecode or some kind of VM instructions). A\n                  JIT has access to dynamic runtime information whereas a\n                  standard compiler doesn't and can make better optimizations\n                  like inlining functions that are used frequently.\n                </li>\n                <li>\n                  This is in contrast to a traditional compiler that compiles\n                  all the code to machine language before the program is first\n                  run.\n                </li>\n              </ul>\n              <br />\n              <h3>6. Ivy Compiler</h3>\n              <ul>\n                <li>\n                  Ivy is now default compiler and runtime. Ivy improves budle\n                  size, allows for better debugging, adds improves type\n                  checking, faster testing, enables the AOT compiler on by\n                  default, and improves CSS class and style binding.\n                </li>\n                <li>Reach better build times.</li>\n                <li>\n                  reach better build sizes (with a generated code more\n                  compatible with tree-shaking).\n                </li>\n                <li>\n                  Unlock new potential features (metaprogramming or higher order\n                  components, lazy loading of component instead of modules).\n                </li>\n              </ul>\n              <br />\n              <br />\n              <h3>7. What is metadata rewriting</h3>\n              <ul>\n                <li>\n                  Metadata rewriting in Angular refers to the process of\n                  modifying the metadata associated with a class or component\n                  during the build process. Metadata in Angular is defined using\n                  decorators, which are special functions that modify the\n                  behavior of a class or component.\n                </li>\n                <br />\n                <li>\n                  During the build process, Angular's compiler analyzes the\n                  application's source code and generates an optimized version\n                  of the application's JavaScript code. As part of this process,\n                  the compiler can also modify the metadata associated with the\n                  application's components.\n                </li>\n                <br />\n                <li>\n                  Metadata rewriting is used to add or modify the metadata of a\n                  component, such as changing the selector, modifying the\n                  template or styles, or adding new input or output properties.\n                  This can be useful in situations where the component needs to\n                  be customized or extended for a specific use case.\n                </li>\n                <br />\n                <li>\n                  For example, suppose you have a third-party library that\n                  provides a component that you want to use in your Angular\n                  application. However, the component's selector conflicts with\n                  another component in your application, and you cannot change\n                  the selector of either component. In this case, you can use\n                  metadata rewriting to modify the selector of the third-party\n                  component during the build process, so that it does not\n                  conflict with the other component.\n                </li>\n                <br />\n                <li>\n                  Overall, metadata rewriting is a powerful feature of Angular\n                  that allows developers to modify the metadata associated with\n                  a component during the build process. This can be useful in a\n                  variety of situations, such as customizing third-party\n                  components, optimizing component performance, or adding new\n                  functionality to existing components.\n                </li>\n              </ul>\n              <br />\n              <br />\n              <h3>8. Explain the purpose of Service Workers in Angular</h3>\n              <ul>\n                <li>\n                  Service Workers are implemented using the\n                  @angular/service-worker package. This package provides a set\n                  of tools and utilities for configuring and deploying a Service\n                  Worker in an Angular application.\n                </li>\n                <br />\n                <li>\n                  The purpose of Service Workers in Angular is to provide\n                  advanced caching and offline capabilities to web applications.\n                  By intercepting network requests and caching responses,\n                  Service Workers can greatly reduce the amount of data that\n                  needs to be downloaded and improve the performance of the\n                  application. They can also provide offline support, allowing\n                  users to continue using the application even when they are not\n                  connected to the internet.\n                </li>\n                <br />\n                <li>\n                  Service Workers can also be used to provide push notifications\n                  and background synchronization, which can be useful for\n                  applications that need to update data in real-time.\n                </li>\n                <br />\n                <li>\n                  Overall, the purpose of Service Workers in Angular is to\n                  provide advanced caching, offline, and real-time capabilities\n                  to web applications. By leveraging Service Workers, developers\n                  can create faster, more reliable, and more engaging web\n                  applications that can work seamlessly across different devices\n                  and network conditions.\n                </li>\n              </ul>\n              <br />\n              <br />\n              <h3>9. What are the design goals of service workers</h3>\n              Service workers in Angular are designed to help developers build\n              progressive web applications (PWAs) that are reliable, fast, and\n              engaging. The primary design goals of service workers in Angular\n              are as follows:\n              <ul>\n                <li>\n                  <b>Offline support: </b>Service workers allow Angular\n                  applications to work offline by caching assets and data that\n                  are necessary for the application to function.\n                </li>\n                <br />\n                <li>\n                  <b>Performance: </b>Service workers can improve the\n                  performance of Angular applications by caching assets and data\n                  on the client-side, reducing the number of requests that need\n                  to be made to the server. This can lead to faster load times\n                  and a smoother user experience.\n                </li>\n                <br />\n                <li>\n                  <b>Push notifications: </b>Service workers enable Angular\n                  applications to send push notifications to users, even when\n                  the application is not open in the user's browser. This can be\n                  used to keep users engaged with the application and to provide\n                  timely updates.\n                </li>\n                <br />\n                <li>\n                  <b>Security: </b>Service workers are designed to be secure and\n                  reliable. They run in a separate context from the main\n                  application and cannot access sensitive user data or resources\n                  without permission.\n                </li>\n              </ul>\n              <br />\n              <br />\n              <h3>\n                10. Difference between local storage, cookies and Session.\n              </h3>\n              In Angular, there are three common ways to store data on the\n              client-side: local storage, cookies, and session storage. Each has\n              its own advantages and disadvantages, and the choice of which to\n              use depends on the specific needs of the application.\n              <ul>\n                <li>\n                  <b>Local Storage: </b>Local storage is a key-value store that\n                  allows data to be stored on the client-side in a persistent\n                  manner. The data stored in local storage is accessible even\n                  after the browser is closed, and can be accessed by any page\n                  in the same domain. Local storage is a good option for storing\n                  large amounts of data that need to persist between sessions.\n                </li>\n                <br />\n                <li>\n                  <b>Cookies: </b>Cookies are small text files that are stored\n                  on the client-side by the browser. Cookies can be used to\n                  store small amounts of data, such as user preferences or\n                  authentication tokens. Cookies are accessible by any page in\n                  the same domain and can be set to expire after a certain\n                  period of time.\n                </li>\n                <br />\n                <li>\n                  <b>Session Storage: </b>Session storage is similar to local\n                  storage, but the data stored in session storage is only\n                  accessible within the current browser session. Once the\n                  browser is closed, the data is deleted. Session storage is a\n                  good option for storing data that needs to be accessible\n                  across multiple pages within the same session, but does not\n                  need to persist between sessions.\n                </li>\n              </ul>\n              <br />\n              <br />\n              <h3>11. What is authentication and authorization in Angular.</h3>\n              <ul>\n                <li>\n                  <b>Authentication: </b>During login, the credential are sent\n                  to an authentication API. This API is present on the server\n                  and validation is done there. After a JWT is returned, this\n                  token has information about the usr and is used to identify\n                  the user. This process is called Authentication.\n                </li>\n                <br />\n                <li>\n                  <b>Authorization: </b>After authentication, user are given\n                  various levels of permission/ access. Some users may have\n                  access to all the pages and some might not. This process of\n                  restricting the content is called Authorization.\n                </li>\n              </ul>\n              <br />\n              <br />\n              <h3>12. How we handle large data api in frontend.</h3>\n              Pagination, infinite scroll\n            </List>\n          </Paper>\n        </Grid>\n      </Grid>\n    );\n  }\n}\n\nexport default withStyles(styles)(DepenInjection);\n"]},"metadata":{},"sourceType":"module"}