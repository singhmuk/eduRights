{"ast":null,"code":"import _classCallCheck from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/createClass\";import _possibleConstructorReturn from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";import _getPrototypeOf from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";import _inherits from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/inherits\";import React,{Component}from\"react\";import Prism from\"prismjs\";import{Grid,Paper,withStyles,List}from\"@material-ui/core\";import\"../../ReactJs/styles.css\";import Sidebar from\"../sidebar\";import PrismCode from\"../../ReactJs/prismCode\";var titles={backgroundColor:\"#F0F8FF\",padding:\"1px\",fontSize:\"16px\"};var styles=function styles(theme){return{paper:{margin:theme.spacing(1),padding:theme.spacing(1)},smMargin:{margin:theme.spacing(1)},actionDiv:{textAlign:\"center\"}};};var fullResponse=\"\\nimport { HttpClient, HttpResponse } from '@angular/common/http';\\n\\n\\nconstructor(private http: HttpClient) {}\\n\\nthis.http.get('https://example.com/api', { observe: 'response' })\\n  .subscribe((response: HttpResponse<any>) => {\\n    console.log(response.headers); // headers of the response\\n    console.log(response.status); // status code of the response\\n    console.log(response.body);   // body of the response\\n  });\\n\".trim();var performError=\"\\n//html\\n<p>{{errorMessage}}</p>\\n\\n\\nimport { HttpClient, HttpErrorResponse } from '@angular/common/http';\\nimport { catchError } from 'rxjs/operators';\\nimport { throwError } from 'rxjs';\\n\\nexport class AppComponent {\\n  public errorMessage: string;\\n\\n  constructor(private http: HttpClient) {\\n    this.getData().subscribe((res) => console.log(res), (error: HttpErrorResponse) => {\\n\\n        if (error.error instanceof ErrorEvent) {\\n          this.errorMessage = 'Error: '$'{error.error.message}';                            // client-side error\\n        } \\n        else {\\n          this.errorMessage = 'Error Code: '$'{error.status} Message: '$'{error.message}';  // server-side error\\n        }\\n      }\\n    );\\n  }\\n\\n  private getData() {\\n    const url = 'https://my-api.com/data';\\n    return this.http.get(url).pipe(\\n      catchError((error: HttpErrorResponse) => {\\n        return throwError(error);\\n      })\\n    );\\n  }\\n}\\n\".trim();var interceptor=\"\\nimport { Injectable } from '@angular/core';\\nimport { HttpInterceptor, HttpHandler, HttpRequest } from '@angular/common/http';\\n\\n@Injectable()\\nexport class AuthInterceptor implements HttpInterceptor {\\n  intercept(request: HttpRequest<any>, next: HttpHandler) {\\n    const authToken = localStorage.getItem('authToken');\\n    \\n    const authRequest = request.clone({\\n      headers: request.headers.set('Authorization', 'Bearer '$'{authToken}')\\n    });\\n    \\n    // Pass the auth request on to the next interceptor or to the HttpClient if there are no more interceptors\\n    return next.handle(authRequest);\\n  }\\n}\\n\".trim();var AngularLifeCycle=/*#__PURE__*/function(_Component){_inherits(AngularLifeCycle,_Component);function AngularLifeCycle(){_classCallCheck(this,AngularLifeCycle);return _possibleConstructorReturn(this,_getPrototypeOf(AngularLifeCycle).apply(this,arguments));}_createClass(AngularLifeCycle,[{key:\"componentDidMount\",value:function componentDidMount(){setTimeout(function(){return Prism.highlightAll();},0);}},{key:\"render\",value:function render(){var classes=this.props.classes;return React.createElement(Grid,{container:true},React.createElement(Grid,{item:true,xs:2},React.createElement(Paper,{className:classes.paper},React.createElement(\"h4\",null,React.createElement(Sidebar,null)))),React.createElement(Grid,{item:true,xs:10},React.createElement(Paper,{className:classes.paper},React.createElement(List,null,React.createElement(\"h3\",null,\"1. lifecycle hook\"),\"Constructor excuite first. If we need to inject any dependencies into component, then Constructor is the best place to inject those dependencies. After excuitiing Constructor angular excuites its lifecycle hooks in a specific order.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Sequeces: \"),\"OnChange - OnInit - DoCheck - AfterContentInit - AfterContentChecked - AfterViewInit - AfterViewChecked - OnDestry.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Lifecycle of a component includes:\"),React.createElement(\"br\",null),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Creating a component\"),React.createElement(\"li\",null,\"Rendering a component\"),React.createElement(\"li\",null,\"Creating And Rendering its child component\"),React.createElement(\"li\",null,\"Checking data-bound properties\"),React.createElement(\"li\",null,\"Checking and removing it from DOM\")),React.createElement(\"br\",null),React.createElement(\"b\",null,\"ngOnChange:\"),\"Respond when Angular sets data-bound input properties. The method receives a SimpleChanges object of current and previous property values.\",React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Alwase called whenever one of our bound input changes.\"),React.createElement(\"li\",null,\"Used in any component that has an input.\"),React.createElement(\"li\",null,\"Called whenever an input value changes\"),React.createElement(\"li\",null,\"Is called the first time before ngOnInit\")),React.createElement(\"br\",null),React.createElement(\"b\",null,\"ngOnInit():\"),\"Initialize the directive/ component after Angular first displays the data-bound properties and sets the directive/ component's input properties.\",React.createElement(\"br\",null),\"can be excuited once component has been initialize. This hook is fired before any of the child directive properties are initialize. This place we put logic related to initialization of properties.\",React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Called once, after the first ngOnChanges().\"),React.createElement(\"li\",null,\"Used to initialize data in a component.\"),React.createElement(\"li\",null,\"called after input values are set when a component is initialized.\"),React.createElement(\"li\",null,\"Called only once.\")),React.createElement(\"br\",null),React.createElement(\"b\",null,\"ngDoCheck():\"),React.createElement(\"br\",null),\"Called during every change detection run, immediately after ngOnChanges() and ngOnInit().\",React.createElement(\"br\",null),\"whenever something changes on the template of a component or inside component then it excuites. it called during every changes detection run. This is similar to ngOnChanges() hook, but ngOnChanges() not detect all the changes made to the input properties.\",React.createElement(\"br\",null),React.createElement(\"br\",null),\"It detects changes for those properties which passed by value. However, ngDoCheck() detects changes for those properties also which are passed reference such as array.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Called during all changes detection runs.\"),React.createElement(\"li\",null,\"A run through the view by Angular to update/ detect changes.\")),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"ngAfterContentInit():\"),React.createElement(\"br\",null),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Respond after Angular projects external content into the component's view.\"),React.createElement(\"li\",null,\"Called once after the first ngDoCheck().\")),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"ngAfterContentChecked():\"),React.createElement(\"br\",null),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Respond after Angular checks the content projected into the directive/ component.\"),React.createElement(\"li\",null,\"Called after the ngAfterContentInit() and every subsequent ngDoCheck().\")),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"ngAfterViewInit():\"),React.createElement(\"br\",null),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Respond after Angular initializes the component's views and child views.\"),React.createElement(\"li\",null,\"Called once after the first ngAfterContentChecked().\")),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"ngAfterViewChecked():\"),React.createElement(\"br\",null),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Respond after Angular checks the component's views and child views.\"),React.createElement(\"li\",null,\"Called after the ngAfterViewInit() and every subsequent ngAfterContentChecked().\")),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"ngOnDestroy():\"),React.createElement(\"br\",null),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Cleanup just before Angular destroys the directive/ component. Unsubscribe Observables and detach event handlers to avoid memory leaks.\"),React.createElement(\"li\",null,\"Called just before Angular destroys the directive/ component.\")),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"2. What is the use of Codelyzer\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Codelyzer provides a set of rules and guidelines for writing high-quality, maintainable code. It is built on top of TSLint, a popular static analysis tool for TypeScript, and is specifically designed to analyze Angular-specific code.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"Codelyzer can be run via angular cli or npm directly.\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"3. Why should ngOnInit be used, if we already have a constructor\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"The constructor is a special method that is called when an instance of a component is created. It's primarily used for dependency injection, where you inject services or other dependencies into the component's constructor parameters. You can also perform initialization tasks in the constructor, such as setting default property values.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"ngOnInit is a lifecycle hook that is called after the component's constructor is called and all its inputs are set. It's used for initialization tasks that require the component's inputs to be set, such as fetching data from a server or initializing a form.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"To summarize, the constructor is used for dependency injection and initialization tasks that don't require the component's inputs to be set, while ngOnInit is used for initialization tasks that require the component's inputs to be set.\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"4. How can you read full response\"),\"To read the full response, you can set the observe option of the HttpClient request to 'response' instead of the default 'body'. This tells HttpClient to return the full HTTP response, including the headers and status code, instead of just the response body.\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:fullResponse,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"5. How do you perform Error handling.\"),\"In Angular, error handling can be performed using a combination of techniques, including try-catch blocks, error handling functions, and observable error handling.\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:performError,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"5. What is Interceptor.\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Interceptor is a middleware that intercepts incoming or outgoing HTTP requests and responses. Interceptors can be used to modify or add headers to requests, handle errors, or perform other actions before or after a request or response is sent or received.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"Interceptors are defined as classes that implement the HttpInterceptor interface, which defines a handle method that intercepts HTTP requests and responses. Interceptors are registered with the HttpClientModule by adding them to the providers array of an Angular module.\"),React.createElement(\"br\",null),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:interceptor,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"li\",null,\"Interceptors are a powerful feature of Angular that can be used to implement common patterns such as authentication, caching, and error handling in a reusable and modular way.\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"How do you implement server-side rendering in Angular?\"),\"Server-side rendering (SSR) is a technique used to improve the initial load time and search engine optimization (SEO) of web applications by rendering the HTML on the server before sending it to the client.\",React.createElement(\"ol\",null,React.createElement(\"li\",null,React.createElement(\"b\",null,\"Install: \"),\"@nguniversal/express-engine @nguniversal/module-map-ngfactory-loader.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"Create a new file server.ts in the root of your project, which will contain the code for the server-side rendering logic.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"Modify app.module.ts file to include the ServerModule instead of the BrowserModule.\",\" \"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"Add \",React.createElement(\"b\",null,\"\\\"build:ssr\\\"\"),\" command in package.json\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"npm run build:ssr :\"),\"Run this command to build the server-side code:\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"node dist/server.js: \"),\"Start the server\"),React.createElement(\"br\",null)),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"How do you optimize the performance of an Angular application?\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,React.createElement(\"b\",null,\"Lazy loading: \"),\"Splitting the application into smaller feature modules and loading them on demand can improve initial load times and reduce the amount of code the user needs to download.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"AOT compilation: \"),\"Pre-compiling the application can improve the initial rendering speed and reduce the size of the bundle.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Change detection strategy: \"),\"Choosing the right change detection strategy (e.g. OnPush) can improve the performance of the application by reducing the number of unnecessary checks.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Optimizing network requests: \"),\"Minimizing the number of HTTP requests, compressing files, and using server-side caching can improve the performance of the application.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Optimizing rendering: \"),\"Avoiding unnecessary DOM manipulations and using pure pipes can improve the rendering performance of the application.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Production mode: \"),\"Enabling production mode can improve the performance of the application by disabling certain development-only features and enabling additional optimizations.\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"How do you implement authentication and authorization in Angular?.\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,React.createElement(\"b\",null,\"Send authentication request: \"),\"When a user submits the login form, send a request to the server to authenticate the user's credentials. The server should return a token if the user is authenticated.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Protect routes: \"),\"Use guards to protect routes that require authentication. A guard is a service that can prevent access to a route if certain conditions are not met.\")),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"How would you handle asynchronous data in Angular, such as HTTP requests or observables?\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,React.createElement(\"b\",null,\"Using the async pipe: \"),\"The async pipe is an Angular built-in pipe that subscribes to an observable or a promise and automatically handles the subscription and unsubscription. It is often used in the template to display asynchronous data.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Subscribing manually: \"),\"Instead of using the async pipe, you can subscribe to an observable or a promise manually and handle the data in the component.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Using RxJS operators: \")),React.createElement(\"br\",null),React.createElement(\"li\",null,React.createElement(\"b\",null,\"Using the HttpClient: \"))),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"Explain the concept of observables and how they are used in Angular.\"),React.createElement(\"ul\",null,React.createElement(\"li\",null,\"Observable is an entity that represents a stream of data that can be subscribed to, allowing the consumer to receive values emitted by the observable over time.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"In Angular, observables are often used for handling HTTP requests, user interactions, and other asynchronous events.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"Observables have a number of advantages over traditional callback-based approaches to handling asynchronous data. They provide better support for handling multiple events, allow for easy composition and transformation of data streams, and can be canceled or unsubscribed when no longer needed.\"),React.createElement(\"br\",null),React.createElement(\"li\",null,\"To use observables in Angular, you can create an observable using the RxJS library and then subscribe to it in your component.\"))))));}}]);return AngularLifeCycle;}(Component);export default withStyles(styles)(AngularLifeCycle);","map":{"version":3,"sources":["/home/mukeshs/Projects/edurights/src/components/angularjsd/angular 12/lifeCycleAng.js"],"names":["React","Component","Prism","Grid","Paper","withStyles","List","Sidebar","PrismCode","titles","backgroundColor","padding","fontSize","styles","theme","paper","margin","spacing","smMargin","actionDiv","textAlign","fullResponse","trim","performError","interceptor","AngularLifeCycle","setTimeout","highlightAll","classes","props"],"mappings":"6kBAAA,MAAOA,CAAAA,KAAP,EAAgBC,SAAhB,KAAiC,OAAjC,CACA,MAAOC,CAAAA,KAAP,KAAkB,SAAlB,CACA,OAASC,IAAT,CAAeC,KAAf,CAAsBC,UAAtB,CAAkCC,IAAlC,KAA8C,mBAA9C,CAEA,MAAO,0BAAP,CACA,MAAOC,CAAAA,OAAP,KAAoB,YAApB,CACA,MAAOC,CAAAA,SAAP,KAAsB,yBAAtB,CAEA,GAAMC,CAAAA,MAAM,CAAG,CAAEC,eAAe,CAAE,SAAnB,CAA8BC,OAAO,CAAE,KAAvC,CAA8CC,QAAQ,CAAE,MAAxD,CAAf,CAEA,GAAMC,CAAAA,MAAM,CAAG,QAATA,CAAAA,MAAS,CAACC,KAAD,QAAY,CACzBC,KAAK,CAAE,CACLC,MAAM,CAAEF,KAAK,CAACG,OAAN,CAAc,CAAd,CADH,CAELN,OAAO,CAAEG,KAAK,CAACG,OAAN,CAAc,CAAd,CAFJ,CADkB,CAKzBC,QAAQ,CAAE,CACRF,MAAM,CAAEF,KAAK,CAACG,OAAN,CAAc,CAAd,CADA,CALe,CAQzBE,SAAS,CAAE,CACTC,SAAS,CAAE,QADF,CARc,CAAZ,EAAf,CAaA,GAAMC,CAAAA,YAAY,CAAG,8aAYnBC,IAZmB,EAArB,CAcA,GAAMC,CAAAA,YAAY,CAAG,s7BAkCnBD,IAlCmB,EAArB,CAoCA,GAAME,CAAAA,WAAW,CAAG,knBAiBlBF,IAjBkB,EAApB,C,GAmBMG,CAAAA,gB,wUACgB,CAClBC,UAAU,CAAC,iBAAMxB,CAAAA,KAAK,CAACyB,YAAN,EAAN,EAAD,CAA6B,CAA7B,CAAV,CACD,C,uCACQ,IACCC,CAAAA,OADD,CACa,KAAKC,KADlB,CACCD,OADD,CAEP,MACE,qBAAC,IAAD,EAAM,SAAS,KAAf,EACE,oBAAC,IAAD,EAAM,IAAI,KAAV,CAAW,EAAE,CAAE,CAAf,EACE,oBAAC,KAAD,EAAO,SAAS,CAAEA,OAAO,CAACb,KAA1B,EACE,8BACE,oBAAC,OAAD,MADF,CADF,CADF,CADF,CAQE,oBAAC,IAAD,EAAM,IAAI,KAAV,CAAW,EAAE,CAAE,EAAf,EACE,oBAAC,KAAD,EAAO,SAAS,CAAEa,OAAO,CAACb,KAA1B,EACE,oBAAC,IAAD,MACE,kDADF,4OAME,8BANF,CAOE,8BAPF,CAQE,0CARF,uHAWE,8BAXF,CAYE,8BAZF,CAaE,kEAbF,CAcE,8BAdF,CAeE,8BACE,qDADF,CAEE,sDAFF,CAGE,2EAHF,CAIE,+DAJF,CAKE,kEALF,CAfF,CAsBE,8BAtBF,CAuBE,2CAvBF,8IA2BE,8BACE,uFADF,CAEE,yEAFF,CAGE,uEAHF,CAIE,yEAJF,CA3BF,CAiCE,8BAjCF,CAkCE,2CAlCF,oJAsCE,8BAtCF,wMA0CE,8BACE,4EADF,CAEE,wEAFF,CAGE,mGAHF,CAOE,kDAPF,CA1CF,CAmDE,8BAnDF,CAoDE,4CApDF,CAqDE,8BArDF,6FAwDE,8BAxDF,mQA8DE,8BA9DF,CA+DE,8BA/DF,2KAmEE,8BAnEF,CAoEE,8BApEF,CAqEE,8BACE,0EADF,CAEE,6FAFF,CArEF,CA2EE,8BA3EF,CA4EE,8BA5EF,CA6EE,qDA7EF,CA8EE,8BA9EF,CA+EE,8BACE,2GADF,CAKE,yEALF,CA/EF,CAsFE,8BAtFF,CAuFE,8BAvFF,CAwFE,wDAxFF,CAyFE,8BAzFF,CA0FE,8BACE,kHADF,CAKE,wGALF,CA1FF,CAoGE,8BApGF,CAqGE,8BArGF,CAsGE,kDAtGF,CAuGE,8BAvGF,CAwGE,8BACE,yGADF,CAKE,qFALF,CAxGF,CA+GE,8BA/GF,CAgHE,8BAhHF,CAiHE,qDAjHF,CAkHE,8BAlHF,CAmHE,8BACE,oGADF,CAKE,iHALF,CAnHF,CA6HE,8BA7HF,CA8HE,8BA9HF,CA+HE,8CA/HF,CAgIE,8BAhIF,CAiIE,8BACE,wKADF,CAME,8FANF,CAjIF,CA2IE,8BA3IF,CA4IE,8BA5IF,CA6IE,gEA7IF,CA8IE,8BACE,0QADF,CAQE,8BARF,CASE,sFATF,CA9IF,CAyJE,8BAzJF,CA0JE,iGA1JF,CA6JE,8BACE,iXADF,CASE,8BATF,CAUE,kSAVF,CAiBE,8BAjBF,CAkBE,4QAlBF,CA7JF,CAsLE,8BAtLF,CAuLE,kEAvLF,sQA4LE,2BAAK,KAAK,CAAEN,MAAZ,EACE,oBAAC,SAAD,EACE,IAAI,CAAEY,YADR,CAEE,QAAQ,CAAC,IAFX,CAGE,OAAO,CAAE,CAAC,cAAD,CAHX,EADF,CA5LF,CAmME,8BAnMF,CAoME,8BApMF,CAqME,sEArMF,uKAyME,2BAAK,KAAK,CAAEZ,MAAZ,EACE,oBAAC,SAAD,EACE,IAAI,CAAEc,YADR,CAEE,QAAQ,CAAC,IAFX,CAGE,OAAO,CAAE,CAAC,cAAD,CAHX,EADF,CAzMF,CAgNE,8BAhNF,CAiNE,wDAjNF,CAkNE,8BACE,gSADF,CAQE,8BARF,CASE,+SATF,CAiBE,8BAjBF,CAkBE,2BAAK,KAAK,CAAEd,MAAZ,EACE,oBAAC,SAAD,EACE,IAAI,CAAEe,WADR,CAEE,QAAQ,CAAC,IAFX,CAGE,OAAO,CAAE,CAAC,cAAD,CAHX,EADF,CAlBF,CAyBE,8BAzBF,CA0BE,gNA1BF,CAlNF,CAkPE,8BAlPF,CAmPE,uFAnPF,kNAwPE,8BACE,8BACE,yCADF,yEADF,CAKE,8BALF,CAME,0JANF,CAUE,8BAVF,CAWE,oHAEwB,GAFxB,CAXF,CAeE,8BAfF,CAgBE,qCACM,6CADN,4BAhBF,CAmBE,8BAnBF,CAoBE,8BACE,mDADF,mDApBF,CAwBE,8BAxBF,CAyBE,8BACE,qDADF,oBAzBF,CA4BE,8BA5BF,CAxPF,CAsRE,8BAtRF,CAuRE,+FAvRF,CA0RE,8BACE,8BACE,8CADF,8KADF,CAOE,8BAPF,CAQE,8BACE,iDADF,4GARF,CAaE,8BAbF,CAcE,8BACE,2DADF,2JAdF,CAoBE,8BApBF,CAqBE,8BACE,6DADF,4IArBF,CA0BE,8BA1BF,CA2BE,8BACE,sDADF,yHA3BF,CAgCE,8BAhCF,CAiCE,8BACE,iDADF,iKAjCF,CA1RF,CAkUE,8BAlUF,CAmUE,mGAnUF,CAuUE,8BACE,8BACE,6DADF,2KADF,CAOE,8BAPF,CAQE,8BACE,gDADF,wJARF,CAvUF,CAqVE,8BArVF,CAsVE,yHAtVF,CA0VE,8BACE,8BACE,sDADF,0NADF,CAOE,8BAPF,CAQE,8BACE,sDADF,mIARF,CAaE,8BAbF,CAcE,8BACE,sDADF,CAdF,CAiBE,8BAjBF,CAkBE,8BACE,sDADF,CAlBF,CA1VF,CAgXE,8BAhXF,CAiXE,qGAjXF,CAqXE,8BACE,iMADF,CAME,8BANF,CAOE,qJAPF,CAWE,8BAXF,CAYE,sUAZF,CAmBE,8BAnBF,CAoBE,+JApBF,CArXF,CADF,CADF,CARF,CADF,CA+ZD,C,8BAra4BvB,S,EAwa/B,cAAeI,CAAAA,UAAU,CAACQ,MAAD,CAAV,CAAmBY,gBAAnB,CAAf","sourcesContent":["import React, { Component } from \"react\";\nimport Prism from \"prismjs\";\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\n\nimport \"../../ReactJs/styles.css\";\nimport Sidebar from \"../sidebar\";\nimport PrismCode from \"../../ReactJs/prismCode\";\n\nconst titles = { backgroundColor: \"#F0F8FF\", padding: \"1px\", fontSize: \"16px\" };\n\nconst styles = (theme) => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1),\n  },\n  smMargin: {\n    margin: theme.spacing(1),\n  },\n  actionDiv: {\n    textAlign: \"center\",\n  },\n});\n\nconst fullResponse = `\nimport { HttpClient, HttpResponse } from '@angular/common/http';\n\n\nconstructor(private http: HttpClient) {}\n\nthis.http.get('https://example.com/api', { observe: 'response' })\n  .subscribe((response: HttpResponse<any>) => {\n    console.log(response.headers); // headers of the response\n    console.log(response.status); // status code of the response\n    console.log(response.body);   // body of the response\n  });\n`.trim();\n\nconst performError = `\n//html\n<p>{{errorMessage}}</p>\n\n\nimport { HttpClient, HttpErrorResponse } from '@angular/common/http';\nimport { catchError } from 'rxjs/operators';\nimport { throwError } from 'rxjs';\n\nexport class AppComponent {\n  public errorMessage: string;\n\n  constructor(private http: HttpClient) {\n    this.getData().subscribe((res) => console.log(res), (error: HttpErrorResponse) => {\n\n        if (error.error instanceof ErrorEvent) {\n          this.errorMessage = 'Error: '$'{error.error.message}';                            // client-side error\n        } \n        else {\n          this.errorMessage = 'Error Code: '$'{error.status} Message: '$'{error.message}';  // server-side error\n        }\n      }\n    );\n  }\n\n  private getData() {\n    const url = 'https://my-api.com/data';\n    return this.http.get(url).pipe(\n      catchError((error: HttpErrorResponse) => {\n        return throwError(error);\n      })\n    );\n  }\n}\n`.trim();\n\nconst interceptor = `\nimport { Injectable } from '@angular/core';\nimport { HttpInterceptor, HttpHandler, HttpRequest } from '@angular/common/http';\n\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n  intercept(request: HttpRequest<any>, next: HttpHandler) {\n    const authToken = localStorage.getItem('authToken');\n    \n    const authRequest = request.clone({\n      headers: request.headers.set('Authorization', 'Bearer '$'{authToken}')\n    });\n    \n    // Pass the auth request on to the next interceptor or to the HttpClient if there are no more interceptors\n    return next.handle(authRequest);\n  }\n}\n`.trim();\n\nclass AngularLifeCycle extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0);\n  }\n  render() {\n    const { classes } = this.props;\n    return (\n      <Grid container>\n        <Grid item xs={2}>\n          <Paper className={classes.paper}>\n            <h4>\n              <Sidebar />\n            </h4>\n          </Paper>\n        </Grid>\n        <Grid item xs={10}>\n          <Paper className={classes.paper}>\n            <List>\n              <h3>1. lifecycle hook</h3>\n              Constructor excuite first. If we need to inject any dependencies\n              into component, then Constructor is the best place to inject those\n              dependencies. After excuitiing Constructor angular excuites its\n              lifecycle hooks in a specific order.\n              <br />\n              <br />\n              <b>Sequeces: </b>\n              OnChange - OnInit - DoCheck - AfterContentInit -\n              AfterContentChecked - AfterViewInit - AfterViewChecked - OnDestry.\n              <br />\n              <br />\n              <b>Lifecycle of a component includes:</b>\n              <br />\n              <ul>\n                <li>Creating a component</li>\n                <li>Rendering a component</li>\n                <li>Creating And Rendering its child component</li>\n                <li>Checking data-bound properties</li>\n                <li>Checking and removing it from DOM</li>\n              </ul>\n              <br />\n              <b>ngOnChange:</b>\n              Respond when Angular sets data-bound input properties. The method\n              receives a SimpleChanges object of current and previous property\n              values.\n              <ul>\n                <li>Alwase called whenever one of our bound input changes.</li>\n                <li>Used in any component that has an input.</li>\n                <li>Called whenever an input value changes</li>\n                <li>Is called the first time before ngOnInit</li>\n              </ul>\n              <br />\n              <b>ngOnInit():</b>\n              Initialize the directive/ component after Angular first displays\n              the data-bound properties and sets the directive/ component's\n              input properties.\n              <br />\n              can be excuited once component has been initialize. This hook is\n              fired before any of the child directive properties are initialize.\n              This place we put logic related to initialization of properties.\n              <ul>\n                <li>Called once, after the first ngOnChanges().</li>\n                <li>Used to initialize data in a component.</li>\n                <li>\n                  called after input values are set when a component is\n                  initialized.\n                </li>\n                <li>Called only once.</li>\n              </ul>\n              <br />\n              <b>ngDoCheck():</b>\n              <br />\n              Called during every change detection run, immediately after\n              ngOnChanges() and ngOnInit().\n              <br />\n              whenever something changes on the template of a component or\n              inside component then it excuites. it called during every changes\n              detection run. This is similar to ngOnChanges() hook, but\n              ngOnChanges() not detect all the changes made to the input\n              properties.\n              <br />\n              <br />\n              It detects changes for those properties which passed by value.\n              However, ngDoCheck() detects changes for those properties also\n              which are passed reference such as array.\n              <br />\n              <br />\n              <ul>\n                <li>Called during all changes detection runs.</li>\n                <li>\n                  A run through the view by Angular to update/ detect changes.\n                </li>\n              </ul>\n              <br />\n              <br />\n              <b>ngAfterContentInit():</b>\n              <br />\n              <ul>\n                <li>\n                  Respond after Angular projects external content into the\n                  component's view.\n                </li>\n                <li>Called once after the first ngDoCheck().</li>\n              </ul>\n              <br />\n              <br />\n              <b>ngAfterContentChecked():</b>\n              <br />\n              <ul>\n                <li>\n                  Respond after Angular checks the content projected into the\n                  directive/ component.\n                </li>\n                <li>\n                  Called after the ngAfterContentInit() and every subsequent\n                  ngDoCheck().\n                </li>\n              </ul>\n              <br />\n              <br />\n              <b>ngAfterViewInit():</b>\n              <br />\n              <ul>\n                <li>\n                  Respond after Angular initializes the component's views and\n                  child views.\n                </li>\n                <li>Called once after the first ngAfterContentChecked().</li>\n              </ul>\n              <br />\n              <br />\n              <b>ngAfterViewChecked():</b>\n              <br />\n              <ul>\n                <li>\n                  Respond after Angular checks the component's views and child\n                  views.\n                </li>\n                <li>\n                  Called after the ngAfterViewInit() and every subsequent\n                  ngAfterContentChecked().\n                </li>\n              </ul>\n              <br />\n              <br />\n              <b>ngOnDestroy():</b>\n              <br />\n              <ul>\n                <li>\n                  Cleanup just before Angular destroys the directive/ component.\n                  Unsubscribe Observables and detach event handlers to avoid\n                  memory leaks.\n                </li>\n                <li>\n                  Called just before Angular destroys the directive/ component.\n                </li>\n              </ul>\n              <br />\n              <br />\n              <h3>2. What is the use of Codelyzer</h3>\n              <ul>\n                <li>\n                  Codelyzer provides a set of rules and guidelines for writing\n                  high-quality, maintainable code. It is built on top of TSLint,\n                  a popular static analysis tool for TypeScript, and is\n                  specifically designed to analyze Angular-specific code.\n                </li>\n\n                <br />\n                <li>Codelyzer can be run via angular cli or npm directly.</li>\n              </ul>\n              <br />\n              <h3>\n                3. Why should ngOnInit be used, if we already have a constructor\n              </h3>\n              <ul>\n                <li>\n                  The constructor is a special method that is called when an\n                  instance of a component is created. It's primarily used for\n                  dependency injection, where you inject services or other\n                  dependencies into the component's constructor parameters. You\n                  can also perform initialization tasks in the constructor, such\n                  as setting default property values.\n                </li>\n                <br />\n                <li>\n                  ngOnInit is a lifecycle hook that is called after the\n                  component's constructor is called and all its inputs are set.\n                  It's used for initialization tasks that require the\n                  component's inputs to be set, such as fetching data from a\n                  server or initializing a form.\n                </li>\n                <br />\n                <li>\n                  To summarize, the constructor is used for dependency injection\n                  and initialization tasks that don't require the component's\n                  inputs to be set, while ngOnInit is used for initialization\n                  tasks that require the component's inputs to be set.\n                </li>\n              </ul>\n              <br />\n              <h3>4. How can you read full response</h3>To read the full\n              response, you can set the observe option of the HttpClient request\n              to 'response' instead of the default 'body'. This tells HttpClient\n              to return the full HTTP response, including the headers and status\n              code, instead of just the response body.\n              <div style={titles}>\n                <PrismCode\n                  code={fullResponse}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <br />\n              <h3>5. How do you perform Error handling.</h3>\n              In Angular, error handling can be performed using a combination of\n              techniques, including try-catch blocks, error handling functions,\n              and observable error handling.\n              <div style={titles}>\n                <PrismCode\n                  code={performError}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <h3>5. What is Interceptor.</h3>\n              <ul>\n                <li>\n                  Interceptor is a middleware that intercepts incoming or\n                  outgoing HTTP requests and responses. Interceptors can be used\n                  to modify or add headers to requests, handle errors, or\n                  perform other actions before or after a request or response is\n                  sent or received.\n                </li>\n                <br />\n                <li>\n                  Interceptors are defined as classes that implement the\n                  HttpInterceptor interface, which defines a handle method that\n                  intercepts HTTP requests and responses. Interceptors are\n                  registered with the HttpClientModule by adding them to the\n                  providers array of an Angular module.\n                </li>\n\n                <br />\n                <div style={titles}>\n                  <PrismCode\n                    code={interceptor}\n                    language=\"js\"\n                    plugins={[\"line-numbers\"]}\n                  />\n                </div>\n                <br />\n                <li>\n                  Interceptors are a powerful feature of Angular that can be\n                  used to implement common patterns such as authentication,\n                  caching, and error handling in a reusable and modular way.\n                </li>\n              </ul>\n              <br />\n              <h3>How do you implement server-side rendering in Angular?</h3>\n              Server-side rendering (SSR) is a technique used to improve the\n              initial load time and search engine optimization (SEO) of web\n              applications by rendering the HTML on the server before sending it\n              to the client.\n              <ol>\n                <li>\n                  <b>Install: </b>@nguniversal/express-engine\n                  @nguniversal/module-map-ngfactory-loader.\n                </li>\n                <br />\n                <li>\n                  Create a new file server.ts in the root of your project, which\n                  will contain the code for the server-side rendering logic.\n                </li>\n                <br />\n                <li>\n                  Modify app.module.ts file to include the ServerModule instead\n                  of the BrowserModule.{\" \"}\n                </li>\n                <br />\n                <li>\n                  Add <b>\"build:ssr\"</b> command in package.json\n                </li>\n                <br />\n                <li>\n                  <b>npm run build:ssr :</b>Run this command to build the\n                  server-side code:\n                </li>\n                <br />\n                <li>\n                  <b>node dist/server.js: </b>Start the server\n                </li>\n                <br />\n              </ol>\n              <br />\n              <h3>\n                How do you optimize the performance of an Angular application?\n              </h3>\n              <ul>\n                <li>\n                  <b>Lazy loading: </b>Splitting the application into smaller\n                  feature modules and loading them on demand can improve initial\n                  load times and reduce the amount of code the user needs to\n                  download.\n                </li>\n                <br />\n                <li>\n                  <b>AOT compilation: </b>Pre-compiling the application can\n                  improve the initial rendering speed and reduce the size of the\n                  bundle.\n                </li>\n                <br />\n                <li>\n                  <b>Change detection strategy: </b>Choosing the right change\n                  detection strategy (e.g. OnPush) can improve the performance\n                  of the application by reducing the number of unnecessary\n                  checks.\n                </li>\n                <br />\n                <li>\n                  <b>Optimizing network requests: </b>Minimizing the number of\n                  HTTP requests, compressing files, and using server-side\n                  caching can improve the performance of the application.\n                </li>\n                <br />\n                <li>\n                  <b>Optimizing rendering: </b>Avoiding unnecessary DOM\n                  manipulations and using pure pipes can improve the rendering\n                  performance of the application.\n                </li>\n                <br />\n                <li>\n                  <b>Production mode: </b>Enabling production mode can improve\n                  the performance of the application by disabling certain\n                  development-only features and enabling additional\n                  optimizations.\n                </li>\n              </ul>\n              <br />\n              <h3>\n                How do you implement authentication and authorization in\n                Angular?.\n              </h3>\n              <ul>\n                <li>\n                  <b>Send authentication request: </b>When a user submits the\n                  login form, send a request to the server to authenticate the\n                  user's credentials. The server should return a token if the\n                  user is authenticated.\n                </li>\n                <br />\n                <li>\n                  <b>Protect routes: </b>Use guards to protect routes that\n                  require authentication. A guard is a service that can prevent\n                  access to a route if certain conditions are not met.\n                </li>\n              </ul>\n              <br />\n              <h3>\n                How would you handle asynchronous data in Angular, such as HTTP\n                requests or observables?\n              </h3>\n              <ul>\n                <li>\n                  <b>Using the async pipe: </b>The async pipe is an Angular\n                  built-in pipe that subscribes to an observable or a promise\n                  and automatically handles the subscription and unsubscription.\n                  It is often used in the template to display asynchronous data.\n                </li>\n                <br />\n                <li>\n                  <b>Subscribing manually: </b>Instead of using the async pipe,\n                  you can subscribe to an observable or a promise manually and\n                  handle the data in the component.\n                </li>\n                <br />\n                <li>\n                  <b>Using RxJS operators: </b>\n                </li>\n                <br />\n                <li>\n                  <b>Using the HttpClient: </b>\n                </li>\n              </ul>\n              <br />\n              <h3>\n                Explain the concept of observables and how they are used in\n                Angular.\n              </h3>\n              <ul>\n                <li>\n                  Observable is an entity that represents a stream of data that\n                  can be subscribed to, allowing the consumer to receive values\n                  emitted by the observable over time.\n                </li>\n                <br />\n                <li>\n                  In Angular, observables are often used for handling HTTP\n                  requests, user interactions, and other asynchronous events.\n                </li>\n                <br />\n                <li>\n                  Observables have a number of advantages over traditional\n                  callback-based approaches to handling asynchronous data. They\n                  provide better support for handling multiple events, allow for\n                  easy composition and transformation of data streams, and can\n                  be canceled or unsubscribed when no longer needed.\n                </li>\n                <br />\n                <li>\n                  To use observables in Angular, you can create an observable\n                  using the RxJS library and then subscribe to it in your\n                  component.\n                </li>\n              </ul>\n            </List>\n          </Paper>\n        </Grid>\n      </Grid>\n    );\n  }\n}\n\nexport default withStyles(styles)(AngularLifeCycle);\n"]},"metadata":{},"sourceType":"module"}