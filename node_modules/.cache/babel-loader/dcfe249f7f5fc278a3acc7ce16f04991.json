{"ast":null,"code":"var _jsxFileName = \"/home/mukeshs/Projects/edurights/src/components/algorithams/deepAlgorithams/topTech.js\";\nimport React, { Component } from \"react\";\nimport Prism from \"prismjs\";\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\nimport \"../../ReactJs/styles.css\";\nimport Sidebar from \"../sidebar\";\nimport PrismCode from \"../../ReactJs/prismCode\";\nconst titles = {\n  backgroundColor: \"#F0F8FF\",\n  padding: \"1px\",\n  fontSize: \"16px\"\n};\n\nconst styles = theme => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1)\n  },\n  smMargin: {\n    margin: theme.spacing(1)\n  },\n  actionDiv: {\n    textAlign: \"center\"\n  }\n});\n\nconst evalRPN = `\nfunction policeNotation(tokens) {\n  const stack = [];\n  for (const tok of tokens) {\n    if (!isNaN(tok)) {\n      stack.push(parseInt(tok));\n    } else {\n      const b = stack.pop();\n      const a = stack.pop();\n      switch (tok) {\n        case \"+\":\n          stack.push(a + b);\n          break;\n        case \"*\":\n          stack.push(a * b);\n          break;\n        case \"-\":\n          stack.push(a - b);\n          break;\n        case \"/\":\n          stack.push(a / b);\n          break;\n      }\n    }\n  }\n  return stack.pop();\n}\n\nconsole.log(policeNotation([\"2\", \"1\", \"+\", \"3\", \"*\"]));\n`.trim();\nconst convertToTitle = `\n//Iterative\nfunction fun(){\n  const arr=[\"flower\",\"flow\",\"flight\"];\n  let result = arr[0];\n\n  for(let i=0;i<arr.length;i++){\n    while(arr[i].indexOf(result) !==0){\n      result = result.substring(0, result.length-1)\n    }\n  }\n  return console.log(result)\n}\n\nfun()\n\n\n//Recursion\nfunction fun(arr, index=0, result=arr[0]) {\n  if (index === arr.length) {\n    console.log(result);\n    return;\n  }\n\n  while (arr[index].indexOf(result) !== 0) {\n    result = result.substring(0, result.length - 1);\n  }\n\n  fun(arr, index + 1, result);\n}\n\nfun([\"flower\", \"flow\", \"flight\"]);\n\n\n//Stack\nfunction fun(arr) {\n  if (arr.length === 0) {\n    return \"\";\n  }\n\n  const stack = [...arr[0]];\n\n  for (let i = 1; i < arr.length; i++) {\n    while (arr[i].indexOf(stack.join(\"\")) !== 0) {\n      stack.pop();\n    }\n  }\n\n  console.log(stack.join(\"\"));\n}\n\nfun([\"flower\", \"flow\", \"flight\"]);\n`.trim();\nconst combinationSum3 = `\nfunction fun(){\n  const arr=[-1,2,1,-4];\n  let sum=0;\n\n  for(let i=0;i<arr.length;i++){\n    sum +=arr[i];\n  }\n  console.log(sum)\n}\n\nfun()\n\n\n//Recursion\nfunction fun(arr, index = 0) {\n  if (arr.length==index) return 0; \n  return arr[index] + fun(arr, index + 1); \n}\n\nconsole.log(fun([-1, 2, 1, -4]));\n`.trim();\nconst closed3 = `\nfunction fun() {\n  const nums = [-1, 3, 2, 5, 10, 4, -2];\n  const target = 1;\n  let closestSum = 0;\n  let closestTriplet = [];\n\n  nums.sort((a,b)=>a-b)\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      for (let k = j + 1; k < nums.length; k++) {\n        const currentSum = nums[i] + nums[j] + nums[k];\n        \n        if (Math.abs(currentSum - target) < Math.abs(closestSum - target)) {\n          closestSum = currentSum;\n          closestTriplet = [nums[i], nums[j], nums[k]];\n        }\n      }\n    }\n  }\n\n  console.log(closestTriplet);\n}\n\nfun();\n`.trim();\nconst maxSlidingWindow = `\nfunction fun() {\n  const arr = {\n    '2': ['a', 'b', 'c'],\n    '3': ['d', 'e', 'f'],\n    '4': ['g', 'h', 'i'],\n    '5': ['j', 'k', 'l'],\n    '6': ['m', 'n', 'o'],\n    '7': ['p', 'q', 'r', 's'],\n    '8': ['t', 'u', 'v'],\n    '9': ['w', 'x', 'y', 'z'],\n  };\n\n  let digits = '23';\n  let result = [];\n\n  let newDigits = digits.split('');\n  let one = newDigits[0];\n  let two = newDigits[1];\n\n  let arrOne = arr[one];\n  let arrTwo = arr[two];\n\n  if (arrOne && arrTwo) {\n    for (let i = 0; i < arrOne.length; i++) {\n      for (let j = 0; j < arrTwo.length; j++) {\n        result.push(arrOne[i] + arrTwo[j]);\n      }\n    }\n  }\n\n  console.log(result);\n}\n\nfun();\n`.trim();\nconst parenthesis = `\nfunction fun(){\n  let left='(';\n  let right=')';\n  const result=[];\n\n  for(let i=0; i<4; i++){\n    if (i % 2 === 0) {\n      result.push(left);\n    } else {\n      result.push(right);\n    }\n  }\n\n  console.log(result.join('')); \n}\n\nfun();\n\n`.trim();\nconst generate = `\nfunction fun(n) {\n  const result = [];\n  const stack = [['', 0, 0]];\n\n  while (stack.length > 0) {\n    const [current, open, close] = stack.pop();\n\n    if (current.length === 2 * n) {\n      result.push(current);\n    } else {\n      if (open < n) {\n        stack.push([current + '(', open + 1, close]);\n      }\n\n      if (close < open) {\n        stack.push([current + ')', open, close + 1]);\n      }\n    }\n  }\n\n  return console.log(result);\n}\n\nfun(3);\n`.trim();\n\nclass TopTech extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0);\n  }\n\n  render() {\n    const {\n      classes\n    } = this.props;\n    return React.createElement(Grid, {\n      container: true,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 251\n      },\n      __self: this\n    }, React.createElement(Grid, {\n      item: true,\n      xs: 2,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 252\n      },\n      __self: this\n    }, React.createElement(Paper, {\n      className: classes.paper,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 253\n      },\n      __self: this\n    }, React.createElement(\"h4\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 254\n      },\n      __self: this\n    }, React.createElement(Sidebar, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 255\n      },\n      __self: this\n    })))), React.createElement(Grid, {\n      item: true,\n      xs: 10,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 259\n      },\n      __self: this\n    }, React.createElement(Paper, {\n      className: classes.paper,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 260\n      },\n      __self: this\n    }, React.createElement(List, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 261\n      },\n      __self: this\n    }, React.createElement(\"h2\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 262\n      },\n      __self: this\n    }, \"1. Iterative: \"), \"Iterative algorithms are algorithms that use loops to repeatedly execute a set of instructions until a specific condition is met.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 265\n      },\n      __self: this\n    }), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 267\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 268\n      },\n      __self: this\n    }, \"Advantages:\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 269\n      },\n      __self: this\n    }), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 270\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 270\n      },\n      __self: this\n    }, \"Efficiency: \"), \"Iterative algorithms can be more efficient than recursive algorithms in terms of both time and space complexity. They often require less memory because they don't create a new function call stack for each iteration.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 273\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 273\n      },\n      __self: this\n    }, \"Predictable Memory Usage: \"), \"Iterative algorithms usually have a fixed memory footprint, making them more predictable and less prone to stack overflow errors compared to recursion.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 275\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 275\n      },\n      __self: this\n    }, \"Faster Execution: \"), \"In many cases, iterative algorithms can execute faster than their recursive counterparts.\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 277\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 278\n      },\n      __self: this\n    }, \"Disadvantages:\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 279\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 279\n      },\n      __self: this\n    }, \"State Management: \"), \"In iterative algorithms, you often need to manage and update the state explicitly.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 280\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 280\n      },\n      __self: this\n    }, \"Inefficient Loops: \"), \"Inefficient loop structures or suboptimal loop conditions can lead to performance issues.\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 282\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 284\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 286\n      },\n      __self: this\n    }, \"2. Recursion\"), \"Is a programming technique where a function calls itself to solve a problem.\", React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 288\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 289\n      },\n      __self: this\n    }, \"Advantages:\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 290\n      },\n      __self: this\n    }), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 291\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 291\n      },\n      __self: this\n    }, \"Simplicity and Clarity: \")), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 292\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 292\n      },\n      __self: this\n    }, \"Divide and Conquer: \"), \"Recursive algorithms naturally follow the \\\"divide and conquer\\\" strategy, breaking a problem into smaller, more manageable parts. This can lead to efficient solutions for problems like sorting and searching.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 295\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 295\n      },\n      __self: this\n    }, \"Natural Fit for Certain Problems: \"), \"Include tree traversal, backtracking, and problems involving nested structures.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 297\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 297\n      },\n      __self: this\n    }, \"Dynamic Programming: \"), \"Recursion is often used in dynamic programming, a technique for solving complex problems by breaking them into smaller overlapping subproblems. Recursive functions can help memoize (store and reuse) the results of subproblems, leading to optimized solutions.\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 301\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 302\n      },\n      __self: this\n    }, \"Disadvantages:\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 303\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 303\n      },\n      __self: this\n    }, \"Performance Overhead: \"), \"Recursive function calls come with a performance overhead. Each function call requires additional memory on the call stack, and excessive recursion can lead to stack overflow errors or slow performance.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 306\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 306\n      },\n      __self: this\n    }, \"Memory Consumption: \"), \"Recursive algorithms can consume a significant amount of memory because each function call adds a new stack frame to the call stack. This can be a problem for deep or unoptimized recursion.\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 309\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 311\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 313\n      },\n      __self: this\n    }, \"3. Stack\"), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 314\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 315\n      },\n      __self: this\n    }, \"Advantages:\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 316\n      },\n      __self: this\n    }), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 317\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 317\n      },\n      __self: this\n    }, \"Memory Efficiency: \"), \"Stacks typically use a small, fixed amount of memory for each item pushed onto the stack, making them memory-efficient.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 319\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 319\n      },\n      __self: this\n    }, \"Predictable Behavior: \"), \"Stack-based algorithms are often more predictable and easier to reason about than more complex data structures.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 321\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 321\n      },\n      __self: this\n    }, \"Undo/Redo Functionality: \"), \"Stacks are useful for implementing undo and redo functionality in applications where users can perform a series of actions and then reverse or redo them one at a time.\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 324\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 325\n      },\n      __self: this\n    }, \"Disadvantages:\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 326\n      },\n      __self: this\n    }), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 327\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 327\n      },\n      __self: this\n    }, \"Limited Data Access: \"), \"Stacks have limited access patterns; you can only access the top element. This limitation can be a drawback for problems that require random access to data.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 329\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 329\n      },\n      __self: this\n    }, \"Additional Memory Overhead: \"), \"Stacks consume memory for each element pushed onto the stack. In situations with a large number of stack operations, this can result in additional memory overhead.\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 332\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 334\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 336\n      },\n      __self: this\n    }, \"4. Queue\"), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 337\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 338\n      },\n      __self: this\n    }, \"Advantages:\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 339\n      },\n      __self: this\n    }), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 340\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 340\n      },\n      __self: this\n    }, \"Synchronization: \"), \"In multithreading and multiprocessing environments, queues are often used to safely synchronize and exchange data between threads or processes. They help avoid race conditions and ensure orderly communication.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 343\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 343\n      },\n      __self: this\n    }, \"Buffering: \"), \"Queues can be used as buffers to manage the flow of data between producers and consumers.\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 344\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 345\n      },\n      __self: this\n    }, \"Disadvantages:\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 346\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 346\n      },\n      __self: this\n    }, \"Limited Random Access: \")), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 347\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 349\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 351\n      },\n      __self: this\n    }, \"5. Linked list\"), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 352\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 353\n      },\n      __self: this\n    }, \"Advantages:\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 354\n      },\n      __self: this\n    }), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 355\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 355\n      },\n      __self: this\n    }, \"Dynamic Memory Allocation: \")), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 356\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 356\n      },\n      __self: this\n    }, \"Insertion and Deletion: \"), \"Linked lists excel at inserting and deleting elements in constant time (O(1)) if you have a reference to the node where the operation should take place. This is in contrast to arrays, where inserting or deleting elements in the middle can be costly (O(n)).\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 360\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 360\n      },\n      __self: this\n    }, \"Memory Management: \"), \"Linked lists allocate memory for each node individually. This can lead to more efficient memory usage compared to arrays.\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 362\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 363\n      },\n      __self: this\n    }, \"Disadvantages:\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 364\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 364\n      },\n      __self: this\n    }, \"Not Random Access: \")), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 365\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 365\n      },\n      __self: this\n    }, \"Memory Overhead: \"), \"Each node in a linked list requires extra memory to store the data and a reference (pointer) to the next node. \"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 367\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 367\n      },\n      __self: this\n    }, \"Reversing Order: \"), \"Reversing a linked list or iterating in reverse order is not as straightforward as with arrays, especially in singly linked lists. It may require additional data structures or modifications to the list.\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 370\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 372\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 374\n      },\n      __self: this\n    }, \"6. Hash table \"), \"Store key-value pairs.\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 376\n      },\n      __self: this\n    }), React.createElement(\"ul\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 377\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 378\n      },\n      __self: this\n    }, \"Advantages:\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 379\n      },\n      __self: this\n    }), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 380\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 380\n      },\n      __self: this\n    }, \"Fast Retrieval: \"), \"Hash tables provide fast retrieval of values based on their keys. The hashing function allows for constant-time (O(1)) average-case access, making them ideal for scenarios where quick data retrieval is required.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 383\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 383\n      },\n      __self: this\n    }, \"Efficient Insertions and Deletions: \")), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 384\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 384\n      },\n      __self: this\n    }, \"Flexible Key Types: \"), \"Hash tables can be used with a wide range of key types, including numbers, strings, objects, and more. \"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 386\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 386\n      },\n      __self: this\n    }, \"Data Caching: \"), \"Hash tables are commonly used for caching data to speed up access to frequently used information. They can quickly determine whether a value is cached or not.\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 388\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 388\n      },\n      __self: this\n    }, \"Implementation in Standard Libraries: \")), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 389\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 390\n      },\n      __self: this\n    }, \"Disadvantages:\"), React.createElement(\"li\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 391\n      },\n      __self: this\n    }, \"Collisions: Hash collisions occur when two different keys hash to the same location in the table.\"), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 392\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 394\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 396\n      },\n      __self: this\n    }, \"1. Find the longest common prefix string amongst an array of strings.\"), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 397\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: convertToTitle,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 398\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 404\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 405\n      },\n      __self: this\n    }, \"2. Evaluate Reverse Polish Notation\"), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 406\n      },\n      __self: this\n    }, \"Input: \"), \"[\\\"2\\\", \\\"1\\\", \\\"+\\\", \\\"3\\\", \\\"*\\\"]\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 407\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 408\n      },\n      __self: this\n    }, \"Output: \"), \"9\", React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 408\n      },\n      __self: this\n    }), React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 409\n      },\n      __self: this\n    }, \"Explanation: \"), \"((2 + 1) * 3) = 9\", React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 410\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: evalRPN,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 411\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 417\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 418\n      },\n      __self: this\n    }, \"3. Find Sum of an array.\"), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 420\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: combinationSum3,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 421\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 427\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 429\n      },\n      __self: this\n    }, \"3. Close 3 sum.\"), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 430\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: closed3,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 431\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 437\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 439\n      },\n      __self: this\n    }, \"5. Letter Combinations of a Phone Number.\"), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 440\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: maxSlidingWindow,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 441\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 447\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 449\n      },\n      __self: this\n    }, \"6. Valid Parentheses.\"), React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 450\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: parenthesis,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 451\n      },\n      __self: this\n    })), React.createElement(\"br\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 458\n      },\n      __self: this\n    }), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 459\n      },\n      __self: this\n    }, \"7. Generate Parentheses.\"), \"Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\", React.createElement(\"div\", {\n      style: titles,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 461\n      },\n      __self: this\n    }, React.createElement(PrismCode, {\n      code: generate,\n      language: \"js\",\n      plugins: [\"line-numbers\"],\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 462\n      },\n      __self: this\n    }))))));\n  }\n\n}\n\nexport default withStyles(styles)(TopTech);","map":{"version":3,"sources":["/home/mukeshs/Projects/edurights/src/components/algorithams/deepAlgorithams/topTech.js"],"names":["React","Component","Prism","Grid","Paper","withStyles","List","Sidebar","PrismCode","titles","backgroundColor","padding","fontSize","styles","theme","paper","margin","spacing","smMargin","actionDiv","textAlign","evalRPN","trim","convertToTitle","combinationSum3","closed3","maxSlidingWindow","parenthesis","generate","TopTech","componentDidMount","setTimeout","highlightAll","render","classes","props"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport Prism from \"prismjs\";\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\n\nimport \"../../ReactJs/styles.css\";\nimport Sidebar from \"../sidebar\";\nimport PrismCode from \"../../ReactJs/prismCode\";\n\nconst titles = { backgroundColor: \"#F0F8FF\", padding: \"1px\", fontSize: \"16px\" };\n\nconst styles = (theme) => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1),\n  },\n  smMargin: {\n    margin: theme.spacing(1),\n  },\n  actionDiv: {\n    textAlign: \"center\",\n  },\n});\n\nconst evalRPN = `\nfunction policeNotation(tokens) {\n  const stack = [];\n  for (const tok of tokens) {\n    if (!isNaN(tok)) {\n      stack.push(parseInt(tok));\n    } else {\n      const b = stack.pop();\n      const a = stack.pop();\n      switch (tok) {\n        case \"+\":\n          stack.push(a + b);\n          break;\n        case \"*\":\n          stack.push(a * b);\n          break;\n        case \"-\":\n          stack.push(a - b);\n          break;\n        case \"/\":\n          stack.push(a / b);\n          break;\n      }\n    }\n  }\n  return stack.pop();\n}\n\nconsole.log(policeNotation([\"2\", \"1\", \"+\", \"3\", \"*\"]));\n`.trim();\n\nconst convertToTitle = `\n//Iterative\nfunction fun(){\n  const arr=[\"flower\",\"flow\",\"flight\"];\n  let result = arr[0];\n\n  for(let i=0;i<arr.length;i++){\n    while(arr[i].indexOf(result) !==0){\n      result = result.substring(0, result.length-1)\n    }\n  }\n  return console.log(result)\n}\n\nfun()\n\n\n//Recursion\nfunction fun(arr, index=0, result=arr[0]) {\n  if (index === arr.length) {\n    console.log(result);\n    return;\n  }\n\n  while (arr[index].indexOf(result) !== 0) {\n    result = result.substring(0, result.length - 1);\n  }\n\n  fun(arr, index + 1, result);\n}\n\nfun([\"flower\", \"flow\", \"flight\"]);\n\n\n//Stack\nfunction fun(arr) {\n  if (arr.length === 0) {\n    return \"\";\n  }\n\n  const stack = [...arr[0]];\n\n  for (let i = 1; i < arr.length; i++) {\n    while (arr[i].indexOf(stack.join(\"\")) !== 0) {\n      stack.pop();\n    }\n  }\n\n  console.log(stack.join(\"\"));\n}\n\nfun([\"flower\", \"flow\", \"flight\"]);\n`.trim();\n\nconst combinationSum3 = `\nfunction fun(){\n  const arr=[-1,2,1,-4];\n  let sum=0;\n\n  for(let i=0;i<arr.length;i++){\n    sum +=arr[i];\n  }\n  console.log(sum)\n}\n\nfun()\n\n\n//Recursion\nfunction fun(arr, index = 0) {\n  if (arr.length==index) return 0; \n  return arr[index] + fun(arr, index + 1); \n}\n\nconsole.log(fun([-1, 2, 1, -4]));\n`.trim();\n\nconst closed3 = `\nfunction fun() {\n  const nums = [-1, 3, 2, 5, 10, 4, -2];\n  const target = 1;\n  let closestSum = 0;\n  let closestTriplet = [];\n\n  nums.sort((a,b)=>a-b)\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      for (let k = j + 1; k < nums.length; k++) {\n        const currentSum = nums[i] + nums[j] + nums[k];\n        \n        if (Math.abs(currentSum - target) < Math.abs(closestSum - target)) {\n          closestSum = currentSum;\n          closestTriplet = [nums[i], nums[j], nums[k]];\n        }\n      }\n    }\n  }\n\n  console.log(closestTriplet);\n}\n\nfun();\n`.trim();\n\nconst maxSlidingWindow = `\nfunction fun() {\n  const arr = {\n    '2': ['a', 'b', 'c'],\n    '3': ['d', 'e', 'f'],\n    '4': ['g', 'h', 'i'],\n    '5': ['j', 'k', 'l'],\n    '6': ['m', 'n', 'o'],\n    '7': ['p', 'q', 'r', 's'],\n    '8': ['t', 'u', 'v'],\n    '9': ['w', 'x', 'y', 'z'],\n  };\n\n  let digits = '23';\n  let result = [];\n\n  let newDigits = digits.split('');\n  let one = newDigits[0];\n  let two = newDigits[1];\n\n  let arrOne = arr[one];\n  let arrTwo = arr[two];\n\n  if (arrOne && arrTwo) {\n    for (let i = 0; i < arrOne.length; i++) {\n      for (let j = 0; j < arrTwo.length; j++) {\n        result.push(arrOne[i] + arrTwo[j]);\n      }\n    }\n  }\n\n  console.log(result);\n}\n\nfun();\n`.trim();\n\nconst parenthesis = `\nfunction fun(){\n  let left='(';\n  let right=')';\n  const result=[];\n\n  for(let i=0; i<4; i++){\n    if (i % 2 === 0) {\n      result.push(left);\n    } else {\n      result.push(right);\n    }\n  }\n\n  console.log(result.join('')); \n}\n\nfun();\n\n`.trim();\n\nconst generate = `\nfunction fun(n) {\n  const result = [];\n  const stack = [['', 0, 0]];\n\n  while (stack.length > 0) {\n    const [current, open, close] = stack.pop();\n\n    if (current.length === 2 * n) {\n      result.push(current);\n    } else {\n      if (open < n) {\n        stack.push([current + '(', open + 1, close]);\n      }\n\n      if (close < open) {\n        stack.push([current + ')', open, close + 1]);\n      }\n    }\n  }\n\n  return console.log(result);\n}\n\nfun(3);\n`.trim();\n\nclass TopTech extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0);\n  }\n  render() {\n    const { classes } = this.props;\n    return (\n      <Grid container>\n        <Grid item xs={2}>\n          <Paper className={classes.paper}>\n            <h4>\n              <Sidebar />\n            </h4>\n          </Paper>\n        </Grid>\n        <Grid item xs={10}>\n          <Paper className={classes.paper}>\n            <List>\n              <h2>1. Iterative: </h2>\n              Iterative algorithms are algorithms that use loops to \n              repeatedly execute a set of instructions until a specific condition is met.\n              <br/>\n                \n                <ul>\n                <b>Advantages:</b>\n                <br/>\n                  <li><b>Efficiency: </b>Iterative algorithms can be more efficient than recursive algorithms in terms of both time \n              and space complexity. They often require less memory because they don't create \n              a new function call stack for each iteration.</li>\n                  <li><b>Predictable Memory Usage: </b>Iterative algorithms usually have a fixed memory footprint, making them more \n                            predictable and less prone to stack overflow errors compared to recursion.</li>\n                  <li><b>Faster Execution: </b>In many cases, iterative algorithms can execute faster than their recursive \n                    counterparts.</li>\n                  <br/>\n                  <b>Disadvantages:</b>\n                  <li><b>State Management: </b>In iterative algorithms, you often need to manage and update the state explicitly.</li>\n                  <li><b>Inefficient Loops: </b>Inefficient loop structures or suboptimal loop conditions can lead to performance \n                      issues.</li>\n                <br/>\n                </ul>\n                <br/>\n\n                <h3>2. Recursion</h3>\n                Is a programming technique where a function calls itself to solve a problem. \n                <ul>\n                <b>Advantages:</b>\n                <br/>\n                  <li><b>Simplicity and Clarity: </b></li>\n                  <li><b>Divide and Conquer: </b>Recursive algorithms naturally follow the \"divide and conquer\" strategy, \n                      breaking a problem into smaller, more manageable parts. This can lead to efficient \n                      solutions for problems like sorting and searching.</li>\n                  <li><b>Natural Fit for Certain Problems: </b>Include tree traversal, backtracking, and problems involving nested \n                                    structures.</li>\n                  <li><b>Dynamic Programming: </b>Recursion is often used in dynamic programming, a technique for solving complex \n                        problems by breaking them into smaller overlapping subproblems. Recursive \n                        functions can help memoize (store and reuse) the results of subproblems, \n                        leading to optimized solutions.</li>\n                  <br/>\n                  <b>Disadvantages:</b>\n                  <li><b>Performance Overhead: </b>Recursive function calls come with a performance overhead. Each function call \n                        requires additional memory on the call stack, and excessive recursion can lead to \n                        stack overflow errors or slow performance.</li>\n                  <li><b>Memory Consumption: </b>Recursive algorithms can consume a significant amount of memory because each \n                      function call adds a new stack frame to the call stack. This can be a problem \n                      for deep or unoptimized recursion.</li>\n                <br/>\n                </ul>\n                <br/>\n\n                <h3>3. Stack</h3>\n                <ul>\n                <b>Advantages:</b>\n                <br/>\n                  <li><b>Memory Efficiency: </b>Stacks typically use a small, fixed amount of memory for each item pushed onto the \n                      stack, making them memory-efficient.</li>\n                  <li><b>Predictable Behavior: </b>Stack-based algorithms are often more predictable and easier to reason about than \n                        more complex data structures.</li>\n                  <li><b>Undo/Redo Functionality: </b>Stacks are useful for implementing undo and redo functionality in applications \n                            where users can perform a series of actions and then reverse or redo them one\n                            at a time.</li>\n                  <br/>\n                  <b>Disadvantages:</b>\n                  <br/>\n                  <li><b>Limited Data Access: </b>Stacks have limited access patterns; you can only access the top element. This \n                        limitation can be a drawback for problems that require random access to data.</li>\n                  <li><b>Additional Memory Overhead: </b>Stacks consume memory for each element pushed onto the stack. In situations \n                              with a large number of stack operations, this can result in additional \n                              memory overhead.</li>\n                <br/>\n                </ul>\n                <br/>\n\n                <h3>4. Queue</h3>\n                <ul>\n                <b>Advantages:</b>\n                <br/>\n                  <li><b>Synchronization: </b>In multithreading and multiprocessing environments, queues are often used to safely \n                    synchronize and exchange data between threads or processes. They help avoid race \n                    conditions and ensure orderly communication.</li>\n                  <li><b>Buffering: </b>Queues can be used as buffers to manage the flow of data between producers and consumers.</li>\n                  <br/>\n                  <b>Disadvantages:</b>\n                  <li><b>Limited Random Access: </b></li>\n                <br/>\n                </ul>\n                <br/>\n\n                <h3>5. Linked list</h3>\n                <ul>\n                <b>Advantages:</b>\n                <br/>\n                  <li><b>Dynamic Memory Allocation: </b></li>\n                  <li><b>Insertion and Deletion: </b>Linked lists excel at inserting and deleting elements in constant time (O(1)) \n                          if you have a reference to the node where the operation should take place. This \n                          is in contrast to arrays, where inserting or deleting elements in the middle \n                          can be costly (O(n)).</li>\n                  <li><b>Memory Management: </b>Linked lists allocate memory for each node individually. This can lead to more \n                      efficient memory usage compared to arrays.</li>\n                  <br/>\n                  <b>Disadvantages:</b>\n                  <li><b>Not Random Access: </b></li>\n                  <li><b>Memory Overhead: </b>Each node in a linked list requires extra memory to store the data and a reference \n                    (pointer) to the next node. </li>\n                  <li><b>Reversing Order: </b>Reversing a linked list or iterating in reverse order is not as straightforward as \n                   with arrays, especially in singly linked lists. It may require additional data \n                   structures or modifications to the list.</li>\n                <br/>\n                </ul>\n                <br/>\n\n                <h3>6. Hash table </h3>\n                Store key-value pairs.\n                <br/>\n                <ul>\n                <b>Advantages:</b>\n                <br/>\n                  <li><b>Fast Retrieval: </b>Hash tables provide fast retrieval of values based on their keys. The hashing function \n                  allows for constant-time (O(1)) average-case access, making them ideal for scenarios \n                  where quick data retrieval is required.</li>\n                  <li><b>Efficient Insertions and Deletions: </b></li>\n                  <li><b>Flexible Key Types: </b>Hash tables can be used with a wide range of key types, including numbers, strings, \n                      objects, and more. </li>\n                  <li><b>Data Caching: </b>Hash tables are commonly used for caching data to speed up access to frequently used \n                information. They can quickly determine whether a value is cached or not.</li>\n                  <li><b>Implementation in Standard Libraries: </b></li>\n                  <br/>\n                  <b>Disadvantages:</b>\n                  <li>Collisions: Hash collisions occur when two different keys hash to the same location in the table.</li>\n                <br/>\n                </ul>\n                <br/>\n\n              <h3>1. Find the longest common prefix string amongst an array of strings.</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={convertToTitle}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <h3>2. Evaluate Reverse Polish Notation</h3>\n              <b>Input: </b>[\"2\", \"1\", \"+\", \"3\", \"*\"]\n              <br />\n              <b>Output: </b>9<br />\n              <b>Explanation: </b>((2 + 1) * 3) = 9\n              <div style={titles}>\n                <PrismCode\n                  code={evalRPN}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              <h3>3. Find Sum of an array.</h3>\n              \n              <div style={titles}>\n                <PrismCode\n                  code={combinationSum3}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n              \n              <h3>3. Close 3 sum.</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={closed3}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3>5. Letter Combinations of a Phone Number.</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={maxSlidingWindow}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br />\n\n              <h3>6. Valid Parentheses.</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={parenthesis}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n\n              <br />\n              <h3>7. Generate Parentheses.</h3>\n              Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n              <div style={titles}>\n                <PrismCode\n                  code={generate}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n            </List>\n          </Paper>\n        </Grid>\n      </Grid>\n    );\n  }\n}\n\nexport default withStyles(styles)(TopTech);\n"]},"metadata":{},"sourceType":"module"}