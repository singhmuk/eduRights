{"ast":null,"code":"import _classCallCheck from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/createClass\";import _possibleConstructorReturn from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";import _getPrototypeOf from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";import _inherits from\"/home/mukeshs/Projects/edurights/node_modules/@babel/runtime/helpers/esm/inherits\";import React,{Component}from'react';import Prism from\"prismjs\";import{Grid,Paper,withStyles,List}from\"@material-ui/core\";import'../../ReactJs/styles.css';import Sidebar from'../sidebar';import PrismCode from'../../ReactJs/prismCode';import Stcksval from'../../../assets/stcks.png';var titles={backgroundColor:'#F0F8FF',padding:'1px',fontSize:'16px'};var redesign={height:200,width:500};var styles=function styles(theme){return{paper:{margin:theme.spacing(1),padding:theme.spacing(1)},smMargin:{margin:theme.spacing(1)},actionDiv:{textAlign:\"center\"}};};var threeSumClosest=\"\\nfunction threeSumClosest(nums, target) {\\n  let diff = Infinity;\\n  let result = 0;\\n  nums.sort((a, b) => a - b);\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    let left = i + 1;\\n    let right = nums.length - 1;\\n    while (left < right) {\\n      const sum = nums[i] + nums[left] + nums[right];\\n      const currentDiff = sum - target;\\n\\n      if (currentDiff > 0) {\\n        right -= 1;\\n      } else {\\n        left += 1;\\n      }\\n      if (Math.abs(currentDiff) < diff) {\\n        result = sum;\\n      }\\n      diff = Math.min(Math.abs(currentDiff), diff);\\n    }\\n  }\\n  return result;\\n}\\n\\nconsole.log(threeSumClosest([-1,2,1,-4]))\\n\".trim();var firstMissingPositive=\"\\nfunction firstMissingPositive(nums = []){\\n  function swap(a, b){\\n    const temp = nums[a]\\n    nums[a] = nums[b]\\n    nums[b] = temp\\n  }\\n\\n  let index = 0\\n  while (index < nums.length) {\\n    if (nums[index] !== nums[nums[index] - 1] && nums[index] > 0 && nums[index] <= nums.length){\\n          swap(index, nums[index] - 1)\\n      } else {\\n          index += 1\\n      }\\n   }\\n\\n  for (let i=0; i<nums.length; i++) {\\n    if (nums[i] !== i + 1) return i + 1;\\n  }\\n  return nums.length + 1\\n}\\n\\nconsole.log(firstMissingPositive([3,4,-1,1]))\\n\".trim();var largestNumber=\"\\nfunction largestNumber(nums = []) {\\n  nums.sort((a, b) => {\\n    const digitsA = a.toString(10) + b.toString(10);\\n    const digitsB = b.toString(10) + a.toString(10);\\n\\n    for (let i = 0; i < digitsA.length; i++) {\\n      const digitB = parseInt(digitsB[i], 10);\\n      const digitA = parseInt(digitsA[i], 10);\\n\\n      if (digitB > digitA || digitB < digitA) return digitB - digitA;\\n    }\\n    return 0\\n  })\\n  \\n  const result = nums.join('')\\n  return result[0] === '0' ? '0' : result\\n}\\n\\nconsole.log(largestNumber([10,2]))\\n\".trim();var maxSubArray=\"\\nfunction maxSubArray(nums){\\n  let max = -Infinity;\\n  let currentMax = -Infinity;\\n\\n  for (let i=0; i<nums.length; i++) {\\n    currentMax = Math.max(\\n      currentMax + nums[i],\\n      nums[i],\\n    )\\n    max = Math.max(max, currentMax)\\n  }\\n  return max\\n}\\n\\nconsole.log(maxSubArray([-2,1,-3,4,-1,2,1,-5,4]))\\n\".trim();var searchInsert=\"\\nfunction searchInsert(nums, target){\\n  function aux(low, high){\\n    if (low > high) return low;\\n\\n    const middle = Math.floor((low + high) / 2)\\n    \\n    if (target === nums[middle]) {\\n      return middle\\n    } if (target > nums[middle]) {\\n      return aux(middle + 1, high)\\n    }\\n    return aux(low, middle - 1)\\n  }\\n  return aux(0, nums.length - 1)\\n}\\n\\nconsole.log(searchInsert([1,3,5,6], 5))\\n\".trim();var maximumGap=\"\\nfunction maximumGap(nums = []) {\\n  const maxValue = Math.max(...nums)\\n\\n  function countingSort(place){\\n    const count = []\\n    nums.forEach((num) => {\\n      const index = Math.floor(num / place) % 10\\n      count[index] = count[index] || []\\n      count[index].push(num)\\n    })\\n    return count.reduce((acc, v) => {\\n      if (v !== undefined) {\\n        acc = acc.concat(v)\\n      }\\n      return acc\\n    }, [])\\n  }\\n\\n  let place = 1\\n  while (Math.floor(maxValue / place) > 0) {\\n    nums = countingSort(place)\\n    place *= 10\\n  }\\n  let max = 0\\n  for (let i = 1; i < nums.length; i++) {\\n    max = Math.max(max, nums[i] - nums[i - 1])\\n  }\\n  return max\\n}\\n\\nconsole.log(maximumGap([3,6,9,1]))\\n\".trim();var getFactors=\"\\nfunction getFactors(n){\\n  const result = [];\\n\\n  function aux(remain, start = 2, current = []){\\n    if (remain === 1) {\\n      if (current.length > 1) {\\n        result.push([...current])\\n      }\\n      return\\n    }\\n    \\n    for (let i = start; i <= remain; i++) {\\n      if (remain % i === 0) {\\n        current.push(i)\\n        aux(remain / i, i, current)\\n        current.pop()\\n      }\\n    }\\n  }\\n  aux(n)\\n  return result\\n}\\n\\nconsole.log(getFactors(345))\\n\".trim();var addTwoNumbers=\"\\nfunction ListNode(val) {\\n  this.val = val\\n  this.next = null\\n}\\n\\nconst addTwoNumbers = (l1, l2) => {\\n  let h1 = l1\\n  let h2 = l2\\n  let digit = 0\\n  let head = null\\n  let current = null\\n  while (h1 || h2) {\\n    const num1 = h1 ? h1.val : 0\\n    const num2 = h2 ? h2.val : 0\\n    let value = num1 + num2 + digit\\n    if (value >= 10) {\\n      value -= 10\\n      digit = 1\\n    } else {\\n      digit = 0\\n    }\\n    h1 = h1 ? h1.next : null\\n    h2 = h2 ? h2.next : null\\n    const node = new ListNode(value)\\n    if (!head) {\\n      head = node\\n      current = node\\n    } else {\\n      current.next = node\\n      current = node\\n    }\\n  }\\n  if (digit === 1) {\\n    current.next = new ListNode(1)\\n  }\\n  return head\\n}\\n\\nconsole.log(addTwoNumbers())\".trim();var DSLogic7=/*#__PURE__*/function(_Component){_inherits(DSLogic7,_Component);function DSLogic7(){_classCallCheck(this,DSLogic7);return _possibleConstructorReturn(this,_getPrototypeOf(DSLogic7).apply(this,arguments));}_createClass(DSLogic7,[{key:\"componentDidMount\",value:function componentDidMount(){setTimeout(function(){return Prism.highlightAll();},0);}},{key:\"render\",value:function render(){var classes=this.props.classes;return React.createElement(Grid,{container:true},React.createElement(Grid,{item:true,xs:2},React.createElement(Paper,{className:classes.paper},React.createElement(\"h4\",null,React.createElement(Sidebar,null)))),React.createElement(Grid,{item:true,xs:10},React.createElement(Paper,{className:classes.paper},React.createElement(List,null,React.createElement(\"h3\",null,\"1. 3 Sum Closest\"),\"Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Ex. \"),React.createElement(\"b\",null,\"Input: \"),\"nums = [-1,2,1,-4], target = 1\",React.createElement(\"br\",null),React.createElement(\"b\",null,\"Output: \"),\"2\",React.createElement(\"br\",null),React.createElement(\"b\",null,\"Explanation: \"),\"The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:threeSumClosest,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"2. First Missing Positive.\"),React.createElement(\"b\",null,\"Input: \"),\"[3,4,-1,1]\",React.createElement(\"br\",null),React.createElement(\"b\",null,\"Output: \"),\"2\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:firstMissingPositive,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"3. Largest Number.\"),\"Given a list of non negative integers, arrange them such that they form the largest number.\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:largestNumber,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"4. Maximum Subarray.\"),React.createElement(\"b\",null,\"Input: \"),\"nums = [-2,1,-3,4,-1,2,1,-5,4]\",React.createElement(\"br\",null),React.createElement(\"b\",null,\"Output: \"),\"6\",React.createElement(\"br\",null),React.createElement(\"b\",null,\"Explanation: \"),\"[4,-1,2,1] has the largest sum = 6.\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:maxSubArray,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"5. Search Insert Position.\"),\"Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\",React.createElement(\"br\",null),React.createElement(\"b\",null,\"Input: \"),\"[1,3,5,6], 5\",React.createElement(\"br\",null),React.createElement(\"b\",null,\"Output: \"),\"2\",React.createElement(\"br\",null),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Example 2:\"),React.createElement(\"br\",null),React.createElement(\"b\",null,\"Input: \"),\"[1,3,5,6], 2\",React.createElement(\"br\",null),React.createElement(\"b\",null,\"Output: \"),\"1\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:searchInsert,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"6. Maximum Gap.\"),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:maximumGap,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"7. Factor Combinations.\"),React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:getFactors,language:\"js\",plugins:[\"line-numbers\"]})),React.createElement(\"br\",null),React.createElement(\"h3\",null,\"8. Add Two Numbers.\"),\"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\",React.createElement(\"br\",null),\"You may assume the two numbers do not contain any leading zero, except the number 0 itself.\",React.createElement(\"br\",null),React.createElement(\"b\",null,\"Example: \"),React.createElement(\"b\",null,\"Input: \"),\"(2  4  3) + (5  6  4)\",React.createElement(\"br\",null),React.createElement(\"b\",null,\"Output: \"),\"7  0  8\",React.createElement(\"br\",null),React.createElement(\"b\",null,\"Explanation: \"),\"342 + 465 = 807.\",React.createElement(\"div\",{style:titles},React.createElement(PrismCode,{code:addTwoNumbers,language:\"js\",plugins:[\"line-numbers\"]}))))));}}]);return DSLogic7;}(Component);export default withStyles(styles)(DSLogic7);","map":{"version":3,"sources":["/home/mukeshs/Projects/edurights/src/components/algorithams/deepAlgorithams/arrayNumAlgo.js"],"names":["React","Component","Prism","Grid","Paper","withStyles","List","Sidebar","PrismCode","Stcksval","titles","backgroundColor","padding","fontSize","redesign","height","width","styles","theme","paper","margin","spacing","smMargin","actionDiv","textAlign","threeSumClosest","trim","firstMissingPositive","largestNumber","maxSubArray","searchInsert","maximumGap","getFactors","addTwoNumbers","DSLogic7","setTimeout","highlightAll","classes","props"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport Prism from \"prismjs\"\nimport { Grid, Paper, withStyles, List } from \"@material-ui/core\";\n\nimport '../../ReactJs/styles.css'\nimport Sidebar from '../sidebar';\nimport PrismCode from '../../ReactJs/prismCode';\n\nimport Stcksval from '../../../assets/stcks.png';\n\nconst titles = { backgroundColor: '#F0F8FF', padding: '1px', fontSize: '16px' }\n\nconst redesign = {\n  height: 200,\n  width: 500\n}\n\nconst styles = theme => ({\n  paper: {\n    margin: theme.spacing(1),\n    padding: theme.spacing(1)\n  },\n  smMargin: {\n    margin: theme.spacing(1)\n  },\n  actionDiv: {\n    textAlign: \"center\"\n  }\n})\n\n\n\n\nconst threeSumClosest = `\nfunction threeSumClosest(nums, target) {\n  let diff = Infinity;\n  let result = 0;\n  nums.sort((a, b) => a - b);\n\n  for (let i = 0; i < nums.length; i++) {\n    let left = i + 1;\n    let right = nums.length - 1;\n    while (left < right) {\n      const sum = nums[i] + nums[left] + nums[right];\n      const currentDiff = sum - target;\n\n      if (currentDiff > 0) {\n        right -= 1;\n      } else {\n        left += 1;\n      }\n      if (Math.abs(currentDiff) < diff) {\n        result = sum;\n      }\n      diff = Math.min(Math.abs(currentDiff), diff);\n    }\n  }\n  return result;\n}\n\nconsole.log(threeSumClosest([-1,2,1,-4]))\n`.trim();\n\nconst firstMissingPositive = `\nfunction firstMissingPositive(nums = []){\n  function swap(a, b){\n    const temp = nums[a]\n    nums[a] = nums[b]\n    nums[b] = temp\n  }\n\n  let index = 0\n  while (index < nums.length) {\n    if (nums[index] !== nums[nums[index] - 1] && nums[index] > 0 && nums[index] <= nums.length){\n          swap(index, nums[index] - 1)\n      } else {\n          index += 1\n      }\n   }\n\n  for (let i=0; i<nums.length; i++) {\n    if (nums[i] !== i + 1) return i + 1;\n  }\n  return nums.length + 1\n}\n\nconsole.log(firstMissingPositive([3,4,-1,1]))\n`.trim();\n\nconst largestNumber = `\nfunction largestNumber(nums = []) {\n  nums.sort((a, b) => {\n    const digitsA = a.toString(10) + b.toString(10);\n    const digitsB = b.toString(10) + a.toString(10);\n\n    for (let i = 0; i < digitsA.length; i++) {\n      const digitB = parseInt(digitsB[i], 10);\n      const digitA = parseInt(digitsA[i], 10);\n\n      if (digitB > digitA || digitB < digitA) return digitB - digitA;\n    }\n    return 0\n  })\n  \n  const result = nums.join('')\n  return result[0] === '0' ? '0' : result\n}\n\nconsole.log(largestNumber([10,2]))\n`.trim();\n\nconst maxSubArray = `\nfunction maxSubArray(nums){\n  let max = -Infinity;\n  let currentMax = -Infinity;\n\n  for (let i=0; i<nums.length; i++) {\n    currentMax = Math.max(\n      currentMax + nums[i],\n      nums[i],\n    )\n    max = Math.max(max, currentMax)\n  }\n  return max\n}\n\nconsole.log(maxSubArray([-2,1,-3,4,-1,2,1,-5,4]))\n`.trim();\n\nconst searchInsert = `\nfunction searchInsert(nums, target){\n  function aux(low, high){\n    if (low > high) return low;\n\n    const middle = Math.floor((low + high) / 2)\n    \n    if (target === nums[middle]) {\n      return middle\n    } if (target > nums[middle]) {\n      return aux(middle + 1, high)\n    }\n    return aux(low, middle - 1)\n  }\n  return aux(0, nums.length - 1)\n}\n\nconsole.log(searchInsert([1,3,5,6], 5))\n`.trim();\n\nconst maximumGap = `\nfunction maximumGap(nums = []) {\n  const maxValue = Math.max(...nums)\n\n  function countingSort(place){\n    const count = []\n    nums.forEach((num) => {\n      const index = Math.floor(num / place) % 10\n      count[index] = count[index] || []\n      count[index].push(num)\n    })\n    return count.reduce((acc, v) => {\n      if (v !== undefined) {\n        acc = acc.concat(v)\n      }\n      return acc\n    }, [])\n  }\n\n  let place = 1\n  while (Math.floor(maxValue / place) > 0) {\n    nums = countingSort(place)\n    place *= 10\n  }\n  let max = 0\n  for (let i = 1; i < nums.length; i++) {\n    max = Math.max(max, nums[i] - nums[i - 1])\n  }\n  return max\n}\n\nconsole.log(maximumGap([3,6,9,1]))\n`.trim();\n\nconst getFactors = `\nfunction getFactors(n){\n  const result = [];\n\n  function aux(remain, start = 2, current = []){\n    if (remain === 1) {\n      if (current.length > 1) {\n        result.push([...current])\n      }\n      return\n    }\n    \n    for (let i = start; i <= remain; i++) {\n      if (remain % i === 0) {\n        current.push(i)\n        aux(remain / i, i, current)\n        current.pop()\n      }\n    }\n  }\n  aux(n)\n  return result\n}\n\nconsole.log(getFactors(345))\n`.trim();\n\nconst addTwoNumbers = `\nfunction ListNode(val) {\n  this.val = val\n  this.next = null\n}\n\nconst addTwoNumbers = (l1, l2) => {\n  let h1 = l1\n  let h2 = l2\n  let digit = 0\n  let head = null\n  let current = null\n  while (h1 || h2) {\n    const num1 = h1 ? h1.val : 0\n    const num2 = h2 ? h2.val : 0\n    let value = num1 + num2 + digit\n    if (value >= 10) {\n      value -= 10\n      digit = 1\n    } else {\n      digit = 0\n    }\n    h1 = h1 ? h1.next : null\n    h2 = h2 ? h2.next : null\n    const node = new ListNode(value)\n    if (!head) {\n      head = node\n      current = node\n    } else {\n      current.next = node\n      current = node\n    }\n  }\n  if (digit === 1) {\n    current.next = new ListNode(1)\n  }\n  return head\n}\n\nconsole.log(addTwoNumbers())`.trim();\n\n\nclass DSLogic7 extends Component {\n  componentDidMount() {\n    setTimeout(() => Prism.highlightAll(), 0)\n  }\n  render() {\n    const { classes } = this.props;\n    return (\n      <Grid container>\n        <Grid item xs={2}>\n          <Paper className={classes.paper}>\n            <h4><Sidebar /></h4>\n          </Paper>\n        </Grid>\n        <Grid item xs={10}>\n          <Paper className={classes.paper}>\n            <List>\n              <h3>1. 3 Sum Closest</h3>\n              Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n              <br/>\n              <br/>\n              <b>Ex. </b>\n              <b>Input: </b>nums = [-1,2,1,-4], target = 1<br/>\n              <b>Output: </b>2<br/>\n              <b>Explanation: </b>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n              <div style={titles}>\n                <PrismCode\n                  code={threeSumClosest}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>2. First Missing Positive.</h3>\n              <b>Input: </b>[3,4,-1,1]<br/>\n              <b>Output: </b>2\n              <div style={titles}>\n                <PrismCode\n                  code={firstMissingPositive}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>3. Largest Number.</h3>\n              Given a list of non negative integers, arrange them such that they form the largest number.\n              <div style={titles}>\n                <PrismCode\n                  code={largestNumber}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>4. Maximum Subarray.</h3>\n              <b>Input: </b>nums = [-2,1,-3,4,-1,2,1,-5,4]<br/>\n              <b>Output: </b>6<br/>\n              <b>Explanation: </b>[4,-1,2,1] has the largest sum = 6.\n              <div style={titles}>\n                <PrismCode\n                  code={maxSubArray}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>5. Search Insert Position.</h3>\n              Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n              <br/>\n              <b>Input: </b>[1,3,5,6], 5<br/>\n              <b>Output: </b>2<br/><br/>\n              <b>Example 2:</b><br/>\n\n              <b>Input: </b>[1,3,5,6], 2<br/>\n              <b>Output: </b>1\n              <div style={titles}>\n                <PrismCode\n                  code={searchInsert}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>6. Maximum Gap.</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={maximumGap}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>7. Factor Combinations.</h3>\n              <div style={titles}>\n                <PrismCode\n                  code={getFactors}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n              <br/>\n\n              <h3>8. Add Two Numbers.</h3>\n              You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\n              <br/>\n              You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n              <br/>\n              <b>Example: </b>\n              <b>Input: </b>(2  4  3) + (5  6  4)<br/>\n              <b>Output: </b>7  0  8<br/>\n              <b>Explanation: </b>342 + 465 = 807.\n              <div style={titles}>\n                <PrismCode\n                  code={addTwoNumbers}\n                  language=\"js\"\n                  plugins={[\"line-numbers\"]}\n                />\n              </div>\n            </List>\n          </Paper>\n        </Grid>\n      </Grid>\n    )\n  }\n}\n\nexport default (withStyles(styles)(DSLogic7));\n"]},"metadata":{},"sourceType":"module"}