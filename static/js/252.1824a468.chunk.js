(this["webpackJsonpmern-stack-client"]=this["webpackJsonpmern-stack-client"]||[]).push([[252],{140:function(e,t,a){"use strict";a.d(t,"a",(function(){return h}));var n=a(45),l=a(28),r=a(136),s=a(137),i=a(139),o=a(0),c=a.n(o),u=a(138),m=a.n(u),h=(a(59),function(e){function t(e){var a;return Object(n.a)(this,t),(a=Object(r.a)(this,Object(s.a)(t).call(this,e))).highlight=function(){a.ref&&a.ref.current&&m.a.highlightElement(a.ref.current)},a.ref=c.a.createRef(),a}return Object(i.a)(t,e),Object(l.a)(t,[{key:"componentDidMount",value:function(){this.highlight()}},{key:"componentDidUpdate",value:function(){this.highlight()}},{key:"render",value:function(){var e=this.props,t=e.code,a=(e.plugins,e.language);return c.a.createElement("pre",{className:"code-prism"},c.a.createElement("code",{ref:this.ref,className:"language-".concat(a)},t.trim()))}}]),t}(c.a.Component))},141:function(e,t,a){},147:function(e,t,a){"use strict";a.d(t,"a",(function(){return u}));var n=a(0),l=a.n(n),r=a(26),s=a(297),i=a(295),o=a(114),c=Object(o.a)((function(e){return{root:{display:"flex"},paper:{marginRight:e.spacing(2)},line:{textDecoration:"none"}}}));function u(){var e=c();return l.a.createElement("div",{className:e.root},l.a.createElement(i.a,null,l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/introPython",className:e.line},"intro Python")),l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/tuples",className:e.line},"Tuples")),l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/stringPy",className:e.line},"Strings")),l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/iteratorsPy",className:e.line},"Iterators")),l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/json",className:e.line},"Json")),l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/mathematics",className:e.line},"Mathematics")),l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/oops_",className:e.line},"Oops")),l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/abstract",className:e.line},"Abstract")),l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/exceptionsPy",className:e.line},"ExceptionsHandling")),l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/pyIntro",className:e.line},"Pickle")),l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/threadings",className:e.line},"Thread")),l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/collections",className:e.line},"Collections")),l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/logging",className:e.line},"Logging")),l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/regex",className:e.line},"Regex")),l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/tkinter",className:e.line},"TKinter")),l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/logicalspy",className:e.line},"Logicals")),l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/pyLogic",className:e.line},"PyLogic")),l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/csv",className:e.line},"CsvPython")),l.a.createElement("br",null),"Flask",l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/conroutes",className:e.line},"routes")),l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/httpsMethods",className:e.line},"Https")),l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/flasksIn",className:e.line},"Interviews")),l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/flask_signUp",className:e.line},"Flask_signUp")),l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/get_search",className:e.line},"Get_Search")),l.a.createElement(s.a,null,l.a.createElement(r.b,{to:"/load_search",className:e.line},"Load_Search"))),l.a.createElement("div",null))}},423:function(e,t,a){"use strict";a.r(t);var n=a(45),l=a(28),r=a(136),s=a(137),i=a(139),o=a(0),c=a.n(o),u=a(138),m=a.n(u),h=a(120),d=a(57),p=a(296),b=a(5),E=(a(141),a(147)),f=a(140),g={backgroundColor:"#F0F8FF",padding:"1px",fontSize:"16px"},y='\nfrom time import  sleep\nfrom threading import *\n\nclass Hello(Thread):\n    def run(self):\n        for i in range(500):\n            print("Hello")\n            sleep(1)\n\nclass Hi(Thread):\n    def run(self):\n        for i in range(500):\n            print("Hi")\n            sleep(1)\n\nt1=Hello()\nt2=Hi()\n\nt1.start()\nsleep(0.2)\nt2.start()\n\nt1.join()\nt2.join()\n\nprint(\'By\')\n'.trim(),w="\nfrom threading import Thread\nimport time\n\ndatabase_value = 0\n\ndef increase():\n    global database_value                                           # needed to modify the global value\n    \n    local_copy = database_value                                     # get a local copy (simulate data retrieving)\n        \n    local_copy += 1                                                 # simulate some modifying operation\n    time.sleep(0.1)\n        \n    database_value = local_copy                                     # write the calculated new value into the global variable\n\n\nif __name__ == \"__main__\":\n\n    print('Start value: ', database_value)\n\n    t1 = Thread(target=increase)\n    t2 = Thread(target=increase)\n\n    t1.start()\n    t2.start()\n\n    t1.join()\n    t2.join()\n\n    print('End value:', database_value)\n\n    print('end main')".trim(),k="\nfrom queue import Queue\n\nq = Queue()                                                               # create queue\n\nq.put(1)                                                                  \nq.put(2)                                                                \nq.put(3)                                                                  \n\nfirst = q.get()                                                           \nprint(first)                                                              \n".trim(),v="\nfrom threading import Thread, Lock, current_thread\nfrom queue import Queue\n\ndef worker(q, lock):\n    while True:\n        value = q.get()                                                         # blocks until the item is available\n\n        # do stuff...\n        with lock:\n            print(f\"in {current_thread().name} got {value}\")            # prevent printing at the same time with this lock  \n\n        q.task_done()\n\n\nif __name__ == '__main__':\n    q = Queue()\n    num_threads = 10\n    lock = Lock()\n\n    for i in range(num_threads):\n        t = Thread(name=f\"Thread{i+1}\", target=worker, args=(q, lock))\n        t.daemon = True                                                           # dies when the main thread dies\n        t.start()\n    \n    for x in range(20):                                                           # fill the queue with items\n        q.put(x)\n\n    q.join()                                      # Blocks until all items in the queue have been gotten and processed.\n    print('main done')".trim(),_='\nfrom multiprocessing import Process\nimport os\n\ndef square_numbers():\n    for i in range(1000):\n        result = i * i\n\n        \nif __name__ == "__main__":        \n    processes = []\n    num_processes = os.cpu_count()                                            # number of CPUs on the machine.\n     \n    for i in range(num_processes):                                  # create processes and asign a function for each process\n        process = Process(target=square_numbers)\n        processes.append(process)\n\n    for process in processes:                                                 # start all processes\n        process.start()\n                                                          # wait for all processes to finish\n                                                          # block the main programm until these processes are finished\n    for process in processes:\n        process.join()'.trim(),j="\nfrom multiprocessing import Process, Value, Array\nimport time\n\ndef add_100(number):\n    for _ in range(100):\n        time.sleep(0.01)\n        number.value += 1\n\ndef add_100_array(numbers):\n    for _ in range(100):\n        time.sleep(0.01)\n        for i in range(len(numbers)):\n            numbers[i] += 1\n\n\nif __name__ == \"__main__\":\n\n    shared_number = Value('i', 0) \n    print('Value at beginning:', shared_number.value)\n\n    shared_array = Array('d', [0.0, 100.0, 200.0])\n    print('Array at beginning:', shared_array[:])\n\n    process1 = Process(target=add_100, args=(shared_number,))\n    process2 = Process(target=add_100, args=(shared_number,))\n\n    process3 = Process(target=add_100_array, args=(shared_array,))\n    process4 = Process(target=add_100_array, args=(shared_array,))\n\n    process1.start()\n    process2.start()\n    process3.start()\n    process4.start()\n\n    process1.join()\n    process2.join()\n    process3.join()\n    process4.join()\n\n    print('Value at end:', shared_number.value)\n    print('Array at end:', shared_array[:])\n\n    print('end main')".trim(),q="\ndef add_100(number, lock):\n    for _ in range(100):\n        time.sleep(0.01)\n        with lock:\n            number.value += 1".trim(),T='\nfrom multiprocessing import Pool \n\ndef cube(number):\n    return number * number * number\n    \nif __name__ == "__main__":\n    numbers = range(10)\n    p = Pool()                                          # by default this allocates the maximum number of available \n                                                        # processors for this task --\x3e os.cpu_count().\n    result = p.map(cube,  numbers)\n    \n    p.close()                                           \n    p.join()                                                            \n    print(result)                                       # result = [p.apply(cube, args=(i,)) for i in numbers].\n    '.trim(),P=function(e){function t(){return Object(n.a)(this,t),Object(r.a)(this,Object(s.a)(t).apply(this,arguments))}return Object(i.a)(t,e),Object(l.a)(t,[{key:"componentDidMount",value:function(){setTimeout((function(){return m.a.highlightAll()}),0)}},{key:"render",value:function(){var e=this.props.classes;return c.a.createElement(h.a,{container:!0},c.a.createElement(h.a,{item:!0,xs:2},c.a.createElement(d.a,{className:e.paper},c.a.createElement("h4",null,c.a.createElement(E.a,null)))),c.a.createElement(h.a,{item:!0,xs:10},c.a.createElement(d.a,{className:e.paper},c.a.createElement(p.a,null,c.a.createElement("h3",null,"Threading vs Multiprocessing"),"We have two common approaches to run code in parallel (achieve multitasking)",c.a.createElement("ul",null,c.a.createElement("li",null,"threads"),c.a.createElement("li",null,"multiple processes")),c.a.createElement("br",null),c.a.createElement("h3",null,"Process"),"A Process is an instance of a program. They are independent from each other and do not share the same memory.",c.a.createElement("br",null),c.a.createElement("br",null),c.a.createElement("b",null,"Key facts:"),c.a.createElement("ul",null,c.a.createElement("li",null,"A new process is started independently from the first process."),c.a.createElement("li",null,"Takes advantage of multiple CPUs and cores."),c.a.createElement("li",null,"Separate memory space."),c.a.createElement("li",null,"Memory is not shared between processes."),c.a.createElement("li",null,"One GIL (Global interpreter lock) for each process, i.e. avoids GIL limitation."),c.a.createElement("li",null,"Great for CPU-bound processing."),c.a.createElement("li",null,"Child processes are interruptable/ killable."),c.a.createElement("li",null,"Starting a process is slower than starting a thread."),c.a.createElement("li",null,"Larger memory footprint."),c.a.createElement("li",null,"IPC (inter-process communication) is more complicated.")),c.a.createElement("br",null),c.a.createElement("h3",null,"Threads"),"A thread is an entity within a process that can be scheduled for execution. A Process can spawn multiple threads. The main difference is that all threads within a process share the same memory.",c.a.createElement("br",null),c.a.createElement("br",null),c.a.createElement("b",null,"Key facts:"),c.a.createElement("br",null),c.a.createElement("ul",null,c.a.createElement("li",null,"Multiple threads can be spawned within one process."),c.a.createElement("li",null,"Memory is shared between all threads."),c.a.createElement("li",null,"Starting a thread is faster than starting a process."),c.a.createElement("li",null,"Great for I/O-bound tasks."),c.a.createElement("li",null,"Leightweight - low memory footprint."),c.a.createElement("li",null,"One GIL for all threads, i.e. threads are limited by GIL."),c.a.createElement("li",null,"Multithreading has no effect for CPU-bound tasks due to the GIL."),c.a.createElement("li",null,"Not interruptible/ killable - be careful with memory leaks."),c.a.createElement("li",null,"increased potential for race conditions.")),c.a.createElement("br",null),c.a.createElement("h3",null,"Threading in Python"),"Use the threading module.",c.a.createElement("br",null),"Note: The following example usually won't benefit from multiple threads since it is CPU-bound. It should just show the example of how to use threads.",c.a.createElement("div",{style:g},c.a.createElement(f.a,{code:y,language:"js",plugins:["line-numbers"]})),c.a.createElement("br",null),c.a.createElement("h3",null,"When is Threading useful"),c.a.createElement("ul",null,c.a.createElement("li",null,"Useful for I/O-bound tasks when program has to talk to slow devices like a hard drive or a network connection."),c.a.createElement("li",null,"With threading the program can use the time waiting for these devices and do other tasks in the meantime.")),c.a.createElement("br",null),c.a.createElement("h3",null,"Multiprocessing"),"Create a process with ",c.a.createElement("b",null,"multiprocessing.Process()"),". It takes two important arguments:",c.a.createElement("br",null),c.a.createElement("ul",null,c.a.createElement("li",null,c.a.createElement("b",null,"target:")," a callable object (function) for this process to be invoked when the process starts"),c.a.createElement("li",null,c.a.createElement("b",null,"args:")," the (function) arguments for the target function. This must be a tuple")),c.a.createElement("br",null),c.a.createElement("ul",null,c.a.createElement("li",null,"Start a process with process.start()."),c.a.createElement("li",null,"Call process.join() to tell the program that it should wait for this process to complete before it continues with the rest of the code.")),c.a.createElement("br",null),c.a.createElement("div",{style:g},c.a.createElement(f.a,{code:_,language:"js",plugins:["line-numbers"]})),c.a.createElement("br",null),c.a.createElement("h3",null,"When is Multiprocessing useful"),"It is useful for CPU-bound tasks that have to do a lot of CPU operations for a large amount of data and require a lot of computation time. With multiprocessing we can split the data into equal parts and do parallel computing on different CPUs.",c.a.createElement("br",null),c.a.createElement("br",null),c.a.createElement("b",null,"Ex. ")," Calculate the square numbers for all numbers from 1 to 1000000. Divide the numbers into equal sized parts and use a process for each subset.",c.a.createElement("br",null),c.a.createElement("h3",null,"GIL - Global interpreter lock"),"This is a mutex (or a lock) that allows only one thread to hold control of the Python interpreter. This means that the GIL allows only one thread to execute at a time even in a multi-threaded architecture.",c.a.createElement("h3",null,"Why is it needed?"),"It is needed because CPython's memory management is not thread-safe. Python uses reference counting for memory management. It means that objects created in Python have a reference count variable that keeps track of the number of references that point to the object. When this count reaches zero, the memory occupied by the object is released. The problem was that this reference count variable needed protection from race conditions where two threads increase/ decrease its value simultaneously. If this happens, it can cause either leaked memory that is never released or incorrectly release the memory while a reference to that object still exists.",c.a.createElement("br",null),c.a.createElement("h3",null,"How to avoid the GIL"),c.a.createElement("ul",null,c.a.createElement("li",null,"Avoid GIL by using multiprocessing instead of threading. "),c.a.createElement("li",null,"Avoid the CPython implementation and use a free-threaded Python implementation like Jython or IronPython."),c.a.createElement("li",null,"Move parts of the application out into binary extensions modules, i.e. use Python as a wrapper for third party libraries (e.g. in C/C++). This is the path taken by numypy and scipy.")),c.a.createElement("br",null),c.a.createElement("h3",null,"Share data between threads"),"Task: Create two threads, each thread should access the current database value, modify it, and write the new value back into the database value. Each thread should do this operation 10 times.",c.a.createElement("br",null),c.a.createElement("br",null),c.a.createElement("div",{style:g},c.a.createElement(f.a,{code:w,language:"js",plugins:["line-numbers"]})),c.a.createElement("br",null),c.a.createElement("h3",null,"Share data between processes"),"Since processes don't live in the same memory space, they do not have access to the same (public) data. Thus, they need special shared memory objects to share data.",c.a.createElement("br",null),c.a.createElement("br",null),"Data can be stored in a shared memory variable using Value or Array.",c.a.createElement("br",null),c.a.createElement("ul",null,c.a.createElement("li",null,c.a.createElement("b",null,"Value(type, value):")," Create a ctypes object of type type. Access the value with .target."),c.a.createElement("li",null,c.a.createElement("b",null,"Array(type, value):")," Create a ctypes array with elements of type type. Access the values with [].")),c.a.createElement("br",null),"Task: Create two processes, each process should have access to a shared variable and modify it (Only increase it repeatedly by 1 for 100 times). Create another two processes that share an array and modify all the elements in the array.",c.a.createElement("div",{style:g},c.a.createElement(f.a,{code:j,language:"js",plugins:["line-numbers"]})),c.a.createElement("br",null),c.a.createElement("h3",null,"How to use Locks"),"In the above example (Share data between threads), the 2 threads should increment the value by 1, so 2 increment operations are performed. But why is the end value 1 and not 2?",c.a.createElement("br",null),c.a.createElement("br",null),c.a.createElement("b",null,"Race condition: "),c.a.createElement("br",null),"A race condition happened here. A race condition occurs when two/ more threads can access shared data and they try to change it at the same time. Because the thread scheduling algorithm can swap between threads at any time, we don't know the order in which the threads will attempt to access the shared data. In our case, the first thread accesses the database_value (0) and stores it in a local copy. It then increments it (local_copy is now 1). With our time.sleep() function that just simulates some time consuming operations, the programm will swap to the second thread in the meantime. This will also retrieve the current database_value (still 0) and increment the local_copy to 1. Now both threads have a local copy with value 1, so both will write the 1 into the global database_value. This is why the end value is 1 and not 2.",c.a.createElement("br",null),c.a.createElement("br",null),c.a.createElement("b",null,"Avoid race conditions with Locks"),c.a.createElement("br",null),"A lock (mutex) is a synchronization mechanism for enforcing limits on access to a resource in an environment where there are many threads of execution.",c.a.createElement("br",null),c.a.createElement("b",null,"A Lock has two states: "),c.a.createElement("ul",null,c.a.createElement("li",null,"Locked"),c.a.createElement("li",null,"Unlocked")),"If the state is locked, it does not allow other concurrent threads to enter this code section until the state is unlocked again.",c.a.createElement("br",null),c.a.createElement("br",null),"Two functions are important:",c.a.createElement("ul",null,c.a.createElement("li",null,c.a.createElement("b",null,"lock.acquire():")," This will lock the state and block"),c.a.createElement("li",null,c.a.createElement("b",null,"lock.release():")," This will unlock the state again.")),c.a.createElement("br",null),c.a.createElement("b",null,"N:")," We should always release the block again after it was acquired!.",c.a.createElement("br",null),c.a.createElement("h3",null,"Using Queues in Python"),"Queues can be used for thread-safe/ process-safe data exchanges and data processing both in a multithreaded and a multiprocessing environment.",c.a.createElement("br",null),c.a.createElement("br",null),c.a.createElement("b",null,"The queue"),c.a.createElement("br",null),"A queue is a linear data structure that follows the FIFO principle.",c.a.createElement("div",{style:g},c.a.createElement(f.a,{code:k,language:"js",plugins:["line-numbers"]})),c.a.createElement("br",null),c.a.createElement("h3",null,"Using a queue in multithreading"),"Operations with a queue are thread-safe.",c.a.createElement("br",null),c.a.createElement("ul",null,c.a.createElement("li",null,c.a.createElement("b",null,"q.get():")," Remove and return the first item. By default, it blocks until the item is available."),c.a.createElement("li",null,c.a.createElement("b",null,"q.put(item):")," Puts element at the end of the queue. By default, it blocks until a free slot is available."),c.a.createElement("li",null,c.a.createElement("b",null,"q.task_done():")," Indicate that a formerly enqueued task is complete. For each get() we should call this after we are done with our task for this item."),c.a.createElement("br",null),c.a.createElement("li",null,c.a.createElement("b",null,"q.join():")," Blocks until all items in the queue have been gotten and proccessed (task_done() has been called for each item)."),c.a.createElement("li",null,c.a.createElement("b",null,"q.empty():")," Return True if the queue is empty.")),c.a.createElement("br",null),"The following example uses a queue to exchange numbers from 0...19. Each thread invokes the worker method. Inside the infinite loop the thread is waiting until items are available due to the blocking q.get() call. When items are available, they are processed and then q.task_done() tells the queue that processing is complete.",c.a.createElement("br",null),"In the main thread, 10 daemon threads are created. This means that they automatically die when the main thread dies, and thus the worker method and infinite loop is no longer invoked. Then the queue is filled with items and the worker method can continue with available items.",c.a.createElement("br",null),"At the end q.join() is necessary to block the main thread until all items have been gotten and proccessed.",c.a.createElement("br",null),c.a.createElement("br",null),c.a.createElement("i",null,"If all tasks are done, q.join() can unblock"),c.a.createElement("div",{style:g},c.a.createElement(f.a,{code:v,language:"js",plugins:["line-numbers"]})),c.a.createElement("br",null),c.a.createElement("h3",null,"Daemon threads"),"Daemon threads are background threads that automatically die when the main program ends. This is why the infinite loops inside the worker methods can be exited. Without a daemon process we would have to use a signalling mechanism such as a threading.Event to stop the worker.",c.a.createElement("br",null),"Daemon thread abruptly stopped and their resources (e.g. open files or database transactions) may not be released/ completed properly.",c.a.createElement("br",null),c.a.createElement("br",null),c.a.createElement("h3",null,"Use the lock as a context manager"),"After ",c.a.createElement("b",null,"lock.acquire()")," we should never forget to call ",c.a.createElement("b",null,"lock.release()")," to unblock the code. We can also use a lock as a context manager, wich will safely lock and unlock our code. It is recommended to use a lock this way:",c.a.createElement("div",{style:g},c.a.createElement(f.a,{code:q,language:"js",plugins:["line-numbers"]})),c.a.createElement("br",null),c.a.createElement("h3",null,"Process Pools"),"A process pool object controls a pool of worker processes to which jobs can be submitted It supports asynchronous results with timeouts and callbacks and has a parallel map implementation. It can automatically manage the available processors and split data into smaller chunks which can then be processed in parallel by different processes.",c.a.createElement("br",null),c.a.createElement("br",null),c.a.createElement("ul",null,c.a.createElement("li",null,c.a.createElement("b",null,"map(func, iterable[, chunksize]):")," This method chops the iterable into a number of chunks which it submits to the process pool as separate tasks. The size of these chunks can be specified by setting chunk size to a positive integer. It blocks until the result is ready."),c.a.createElement("li",null,c.a.createElement("b",null,"close():")," Prevents any more tasks from being submitted to the pool. Once all the tasks have been completed the worker processes will exit."),c.a.createElement("li",null,c.a.createElement("b",null,"join():")," Wait for the worker processes to exit. One must call close() or terminate() before using join()."),c.a.createElement("li",null,c.a.createElement("b",null,"apply(func, args):")," Call func with arguments args. It blocks until the result is ready. func is only executed in ONE of the workers of the pool.")),c.a.createElement("br",null),c.a.createElement("b",null,"Note: "),"There are also asynchronous variants map_async() and apply_async() that will not block. They can execute callbacks when the results are ready.",c.a.createElement("div",{style:g},c.a.createElement(f.a,{code:T,language:"js",plugins:["line-numbers"]}))))))}}]),t}(o.Component);t.default=Object(b.a)((function(e){return{paper:{margin:e.spacing(1),padding:e.spacing(1)},smMargin:{margin:e.spacing(1)},actionDiv:{textAlign:"center"}}}))(P)}}]);
//# sourceMappingURL=252.1824a468.chunk.js.map