(this["webpackJsonpmern-stack-client"]=this["webpackJsonpmern-stack-client"]||[]).push([[142],{140:function(e,n,t){"use strict";t.d(n,"a",(function(){return h}));var a=t(45),o=t(28),c=t(136),r=t(137),s=t(139),l=t(0),i=t.n(l),m=t(138),u=t.n(m),h=(t(59),function(e){function n(e){var t;return Object(a.a)(this,n),(t=Object(c.a)(this,Object(r.a)(n).call(this,e))).highlight=function(){t.ref&&t.ref.current&&u.a.highlightElement(t.ref.current)},t.ref=i.a.createRef(),t}return Object(s.a)(n,e),Object(o.a)(n,[{key:"componentDidMount",value:function(){this.highlight()}},{key:"componentDidUpdate",value:function(){this.highlight()}},{key:"render",value:function(){var e=this.props,n=e.code,t=(e.plugins,e.language);return i.a.createElement("pre",{className:"code-prism"},i.a.createElement("code",{ref:this.ref,className:"language-".concat(t)},n.trim()))}}]),n}(i.a.Component))},141:function(e,n,t){},156:function(e,n,t){"use strict";t.d(n,"a",(function(){return m}));var a=t(0),o=t.n(a),c=t(26),r=t(297),s=t(295),l=t(114),i=Object(l.a)((function(e){return{root:{display:"flex"},paper:{marginRight:e.spacing(2)},line:{textDecoration:"none"}}}));function m(){var e=i();return o.a.createElement("div",{className:e.root},o.a.createElement(s.a,null,o.a.createElement(r.a,null,o.a.createElement(c.b,{to:"/devtools",className:e.line},"Devtools")),o.a.createElement(r.a,null,o.a.createElement(c.b,{to:"/cssbasics",className:e.line},"CSS")),o.a.createElement(r.a,null,o.a.createElement(c.b,{to:"/sass",className:e.line},"SASS")),o.a.createElement(r.a,null,o.a.createElement(c.b,{to:"/html_1",className:e.line},"html 1")),o.a.createElement(r.a,null,o.a.createElement(c.b,{to:"/restApi",className:e.line},"RestApi")),o.a.createElement(r.a,null,o.a.createElement(c.b,{to:"/jest",className:e.line},"Jest")),o.a.createElement(r.a,null,o.a.createElement(c.b,{to:"/matchers",className:e.line},"Matchers")),o.a.createElement(r.a,null,o.a.createElement(c.b,{to:"/enzymes",className:e.line},"Enzymes")),o.a.createElement(r.a,null,o.a.createElement(c.b,{to:"/enzyme2",className:e.line},"Enzymes2")),o.a.createElement(r.a,null,o.a.createElement(c.b,{to:"/enzyme3",className:e.line},"Enzymes3"))),o.a.createElement("div",null))}},326:function(e,n,t){"use strict";t.r(n);var a=t(45),o=t(28),c=t(136),r=t(137),s=t(139),l=t(0),i=t.n(l),m=t(138),u=t.n(m),h=t(120),p=t(57),d=t(296),g=t(5),f=(t(141),t(156)),k=t(140),b={backgroundColor:"#F0F8FF",padding:"1px",fontSize:"16px"},w='\ntest("two plus two is four", () => {\n  expect(2 + 2).toBe(4);\n});\n\ntest("object assignment", () => {\n  const data = { one: 1 };\n  data["two"] = 2;\n  expect(data).toEqual({ one: 1, two: 2 });\n});\n\ntest("array assignment", () => {\n  const data = [1];\n  data.push(2);\n  expect(data).toEqual([1, 2]);\n});\n\ntest("adding positive numbers is not zero", () => {\n  for (let a = 1; a < 10; a++) {\n    for (let b = 1; b < 10; b++) {\n      expect(a + b).not.toBe(0);\n    }\n  }\n});\n\ntest("null", () => {\n  const n = null;\n  expect(n).toBeNull();\n  expect(n).toBeDefined();\n  expect(n).not.toBeUndefined();\n  expect(n).not.toBeTruthy();\n  expect(n).toBeFalsy();\n});\n\ntest("zero", () => {\n  const z = 0;\n  expect(z).not.toBeNull();\n  expect(z).toBeDefined();\n  expect(z).not.toBeUndefined();\n  expect(z).not.toBeTruthy();\n  expect(z).toBeFalsy();\n});\n\ntest("two plus two", () => {\n  const value = 2 + 2;\n  expect(value).toBeGreaterThan(3);\n  expect(value).toBeGreaterThanOrEqual(3.5);\n  expect(value).toBeLessThan(5);\n  expect(value).toBeLessThanOrEqual(4.5);\n\n  // toBe and toEqual are equivalent for numbers\n  expect(value).toBe(4);\n  expect(value).toEqual(4);\n});\n\ntest("adding floating point numbers", () => {\n  const value = 0.1 + 0.2;\n  // expect(value).toBe(0.3);\n  expect(value).toBeCloseTo(0.3);\n});\n\ntest("there is no I in team", () => {\n  expect("team").not.toMatch(/I/);\n});\n\ntest(\'but there is a "stop" in Christoph\', () => {\n  expect("Christoph").toMatch(/stop/);\n});\n\nconst shoppingList = [\n  "diapers",\n  "kleenex",\n  "trash bags",\n  "paper towels",\n  "beer"\n];\n\ntest("the shopping list has beer on it", () => {\n  expect(shoppingList).toContain("beer");\n  expect(new Set(shoppingList)).toContain("beer");\n});\n\nclass ConfigError extends Error {}\n\nfunction compileAndroidCode() {\n  throw new ConfigError("you are using the wrong JDK");\n}\n\ntest("compiling android goes as expected", () => {\n  expect(compileAndroidCode).toThrow();\n  expect(compileAndroidCode).toThrow(ConfigError);\n\n  // You can also use the exact error message or a regexp\n  expect(compileAndroidCode).toThrow("you are using the wrong JDK");\n  expect(compileAndroidCode).toThrow(/JDK/);\n});\n'.trim(),x='\nfunction fetchData(callback) {\n  setTimeout(() => {\n    callback("peanut butter");\n  }, 100);\n}\n\nfunction fetchDataPromise() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve("peanut butter");\n    }, 100);\n  });\n}\n\nfunction fetchDataPromiseWithErrorMessage() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      reject("error");\n    }, 100);\n  });\n}\n\nfunction fetchDataPromiseWithError() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      reject(new Error("error"));\n    }, 100);\n  });\n}\n\n// Don\'t do this!\n// test("the data is peanut butter", () => {\n//   function callback(data) {\n//     expect(data).toBe("peanut butter");\n//   }\n\n//   fetchData(callback);\n// });\n\ntest("the data is peanut butter", (done) => {\n  function callback(data) {\n    expect(data).toBe("peanut butter");\n    done();\n  }\n\n  fetchData(callback);\n});\n\ntest("the data is peanut butter", () => {\n  return fetchDataPromise().then(data => {\n    expect(data).toBe("peanut butter");\n  });\n});\n\ntest("the fetch fails with an error", () => {\n  expect.assertions(1);\n  return fetchDataPromiseWithErrorMessage().catch(e =>\n    expect(e).toMatch("error")\n  );\n});\n\ntest("the data is peanut butter", () => {\n  return expect(fetchDataPromise()).resolves.toBe("peanut butter");\n});\n\ntest("the fetch fails with an error", () => {\n  return expect(fetchDataPromiseWithErrorMessage()).rejects.toMatch("error");\n});\n\ntest("the data is peanut butter", async () => {\n  const data = await fetchDataPromise();\n  expect(data).toBe("peanut butter");\n});\n\ntest("the fetch fails with an error", async () => {\n  expect.assertions(1);\n  try {\n    await fetchDataPromiseWithErrorMessage();\n  } catch (e) {\n    expect(e).toMatch("error");\n  }\n});\n\ntest("the data is peanut butter", async () => {\n  await expect(fetchDataPromise()).resolves.toBe("peanut butter");\n});\n\ntest("the fetch fails with an error", async () => {\n  await expect(fetchDataPromiseWithError()).rejects.toThrow("error");\n});\n'.trim(),y='\nlet cities = [];\n\nfunction initializeCityDatabase() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      cities.push("Vienna");\n      cities.push("San Juan");\n      resolve();\n    }, 100);\n  });\n}\n\nfunction clearCityDatabase() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      cities = [];\n      resolve();\n    }, 100);\n  });\n}\n\nfunction isCity(name) {\n  return cities.includes(name);\n}\n\nbeforeAll(() => {\n  return initializeCityDatabase();\n});\n\nafterAll(() => {\n  return clearCityDatabase();\n});\n\ntest("city database has Vienna", () => {\n  expect(isCity("Vienna")).toBeTruthy();\n});\n\ntest("city database has San Juan", () => {\n  expect(isCity("San Juan")).toBeTruthy();\n});\n\ntest("has only 2 cities", () => {\n  expect(cities.length).toBe(2);\n});\n'.trim(),E='\nfunction forEach(items, callback) {\n  for (let index = 0; index < items.length; index++) {\n    callback(items[index]);\n  }\n}\n\ntest("mockFunctions", () => {\n  const mockCallback = jest.fn(x => 42 + x);\n  forEach([0, 1], mockCallback);\n\n  // The mock function is called twice\n  expect(mockCallback.mock.calls.length).toBe(2);\n\n  // The first argument of the first call to the function was 0\n  expect(mockCallback.mock.calls[0][0]).toBe(0);\n\n  // The first argument of the second call to the function was 1\n  expect(mockCallback.mock.calls[1][0]).toBe(1);\n\n  // The return value of the first call to the function was 42\n  expect(mockCallback.mock.results[0].value).toBe(42);\n});\n\ntest("this", () => {\n  const myMock = jest.fn();\n\n  const a = new myMock();\n  a.name = "a";\n  const b = {};\n  b.name = "b";\n  const bound = myMock.bind(b);\n  bound();\n\n  console.log(myMock.mock.instances);\n  // > [ <a>, <b> ]\n});\n\ntest("someMockFunction", () => {\n  const someMockFunction = jest.fn(() => "return value");\n\n  someMockFunction("first arg", "second arg");\n\n  // The function was called exactly once\n  expect(someMockFunction.mock.calls.length).toBe(1);\n\n  // The first arg of the first call to the function was \'first arg\'\n  expect(someMockFunction.mock.calls[0][0]).toBe("first arg");\n\n  // The second arg of the first call to the function was \'second arg\'\n  expect(someMockFunction.mock.calls[0][1]).toBe("second arg");\n\n  // The return value of the first call to the function was \'return value\'\n  expect(someMockFunction.mock.results[0].value).toBe("return value");\n\n  const SomeMockConstructor = jest.fn();\n  const a = new SomeMockConstructor();\n  a.name = "test";\n  const b = new SomeMockConstructor();\n\n  // This function was instantiated exactly twice\n  expect(SomeMockConstructor.mock.instances.length).toBe(2);\n\n  // The object returned by the first instantiation of this function\n  // had a \'name\' property whose value was set to \'test\'\n  expect(SomeMockConstructor.mock.instances[0].name).toEqual("test");\n});\n\ntest("mockReturnValueOnce", () => {\n  const myMock = jest.fn();\n  console.log(myMock());\n  // > undefined\n\n  myMock\n    .mockReturnValue(true)\n    .mockReturnValueOnce(10)\n    .mockReturnValueOnce("x");\n\n  console.log(myMock(), myMock(), myMock(), myMock());\n});\n\ntest("filterTest", () => {\n  const filterTestFn = jest.fn();\n\n  // Make the mock return \'true\' for the first call, and \'false\' for the second call\n  filterTestFn.mockReturnValueOnce(true).mockReturnValueOnce(false);\n\n  const result = [11, 12].filter(filterTestFn);\n\n  console.log(result);\n  // > [11]\n  console.log(filterTestFn.mock.calls);\n  // > [ [11], [12] ]\n});\n\ntest("mockImplementation", () => {\n  const myMockFn = jest.fn(cb => cb(null, true));\n\n  myMockFn((err, val) => console.log(val));\n  // > true\n});\n\ntest("mockImplementationOnce", () => {\n  const myMockFn = jest\n    .fn(() => "default")\n    .mockImplementationOnce(() => "first call")\n    .mockImplementationOnce(() => "second call");\n\n  console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());\n  // > \'first call\', \'second call\', \'default\', \'default\'\n});\n\ntest("return this", () => {\n  const myObj = {\n    myMethod: jest.fn().mockReturnThis()\n  };\n\n  // is the same as\n  const otherObj = {\n    myMethod: jest.fn(function() {\n      return this;\n    })\n  };\n\n  console.log(myObj.myMethod());\n  console.log(otherObj.myMethod());\n});\n\ntest("mockName", () => {\n  const myMockFn = jest\n    .fn()\n    .mockReturnValue("default")\n    .mockImplementation(scalar => 42 + scalar)\n    .mockName("add42");\n\n  // expect(myMockFn).toBeCalled();\n});\n\ntest("custom matchers", () => {\n  const mockFunc = jest.fn();\n\n  const arg1 = "arg1";\n  const arg2 = "arg2";\n\n  mockFunc(arg1, arg2);\n\n  // The mock function was called at least once\n  expect(mockFunc).toBeCalled();\n\n  // The mock function was called at least once with the specified args\n  expect(mockFunc).toBeCalledWith(arg1, arg2);\n\n  // The last call to the mock function was called with the specified args\n  expect(mockFunc).lastCalledWith(arg1, arg2);\n\n  // All calls and the name of the mock is written as a snapshot\n  expect(mockFunc).toMatchSnapshot();\n});\n\ntest("common matchers", () => {\n  const mockFunc = jest.fn().mockName("a mock name");\n\n  const arg1 = 42;\n  const arg2 = "arg2";\n\n  mockFunc(arg1, arg2);\n\n  // The mock function was called at least once\n  expect(mockFunc.mock.calls.length).toBeGreaterThan(0);\n\n  // The mock function was called at least once with the specified args\n  expect(mockFunc.mock.calls).toContainEqual([arg1, arg2]);\n\n  // The last call to the mock function was called with the specified args\n  expect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1]).toEqual([\n    arg1,\n    arg2\n  ]);\n\n  // The first arg of the last call to the mock function was \'42\'\n  // (note that there is no sugar helper for this specific of an assertion)\n  expect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1][0]).toBe(42);\n\n  // A snapshot will check that a mock was invoked the same number of times,\n  // in the same order, with the same arguments. It will also assert on the name.\n  expect(mockFunc.mock.calls).toEqual([[arg1, arg2]]);\n  expect(mockFunc.getMockName()).toBe("a mock name");\n});\n'.trim(),v="\nimport React from 'react';\nimport { render, cleanup, fireEvent, wait, getByPlaceholderText } from '@testing-library/react';\nimport '@testing-library/jest-dom/extend-expect';\nimport { shallow, configure, mount, simulate } from 'enzyme';\nimport Adapter from 'enzyme-adapter-react-16';\nimport renderer from \"react-test-renderer\";\nimport Login from '../../App/Login';\n\n// https://www.apollographql.com/docs/react/recipes/testing/\n\n\nafterEach(cleanup);\n\nconfigure({ adapter: new Adapter() });\n  let wrapper = shallow(<Login />);\n  \nlet location = {\n  href: '/login',\n};\n\ndescribe('Render the login page',() =>{\nit('shows the login page', () => {\n  const asFragment = renderer.create(<Login />).toJSON();\n  expect(asFragment).toMatchSnapshot();\n  });\n})\n\n// it('logs in as admin', async () => {\n//   let setSession = (param) => {\n//     window.localStorage.setItem('graphql_session', JSON.stringify(param));\n//   };\n//   const { getByLabelText, getByText, getByPlaceholderText } = render(\n//     <Login location={location} setSession={setSession} />\n//   );\n//   })\n  \n  // fill out the form\n  it('check username', () => {\n  fireEvent.change(getByPlaceholderText(/Email/i), {\n    target: { name: 'username', value: 'andre@nivoda.net' },\n  });\n  expect(wrapper.state('username')).toEqual('andre@nivoda.net');\n})\n\n  it('check user password', () => {\n  fireEvent.change(getByPlaceholderText(/Password/i), {\n    target: { name: 'password', value: 'test' },\n  });\n  expect(wrapper.state('password')).toEqual('test');\n})\n\n/* NOTE: Test needed for error handling case where if users don't enter anything, error \nmessage is present on the screen.\nlogin check with right data\n*/\ntest('login check with right data',()=>{\n  wrapper = shallow(<Login/>);\n  wrapper.find('input[type=\"text\"]').simulate('change', {target: {\n    name: 'username', value: 'andre@nivoda.net'}\n  });\n  \n  wrapper.find('input[type=\"password\"]').simulate('change', {\n    target: {name: 'password', value: 'test'}\n  });\n  \n  wrapper.find('button').simulate('click');\n  expect(wrapper.state('isLogined')).toBe(true);\n  /* Also, check if the function is being called\n   on submit check if loader present on the screen\n  */\n  })\n  \n//login check with wrong data\n/* \n message - username of passwrod not correct (error: this.setState({\"error_msg\":\"not correct\"}))\n user entered wrong username of password - UI-> check if error message is present on th the Ui\n*/\n test('login check with wrong data',()=>{\n  wrapper = shallow(<Login/>);\n  wrapper.find('input[type=\"text\"]').simulate('change', {\n    target: {name: 'username', value: 'andre@nivoda123.net'}\n  });\n  // console.log(wrapper.debug())\n  \n  wrapper.find('input[type=\"password\"]').simulate('change', {\n    target: {name: 'password', value: 'test123'}\n  });\n  \n    wrapper.find('button').simulate('click');\n    expect(wrapper.state('isLogined')).toBe(false);\n  })\n\n  it('click login button', () => {\n    const { getByLabelText } = render(<Login location={location} />);\n  fireEvent.click(getByLabelText(/login-button/i));\n  wrapper.find('button').simulate('click');\n  expect(wrapper.state('isLogined')).toBe();\n})\n  // await wait(() => getByText(/admin/i));\n\n  // expect(getByText(/admin/i).textContent).toMatchSnapshot();\n  // let session = window.localStorage.getItem('graphql_session');\n  // expect(session).toMatchSnapshot();\n".trim(),B=function(e){function n(){return Object(a.a)(this,n),Object(c.a)(this,Object(r.a)(n).apply(this,arguments))}return Object(s.a)(n,e),Object(o.a)(n,[{key:"componentDidMount",value:function(){setTimeout((function(){return u.a.highlightAll()}),0)}},{key:"render",value:function(){var e=this.props.classes;return i.a.createElement(h.a,{container:!0},i.a.createElement(h.a,{item:!0,xs:2},i.a.createElement(p.a,{className:e.paper},i.a.createElement("h4",null,i.a.createElement(f.a,null)))),i.a.createElement(h.a,{item:!0,xs:10},i.a.createElement(p.a,{className:e.paper},i.a.createElement(d.a,null,i.a.createElement("h3",null,"Matchers"),i.a.createElement("div",{style:b},i.a.createElement(k.a,{code:w,language:"js",plugins:["line-numbers"]})),i.a.createElement("br",null),i.a.createElement("h3",null,"3-testing-asynchronous-code"),i.a.createElement("div",{style:b},i.a.createElement(k.a,{code:x,language:"js",plugins:["line-numbers"]})),i.a.createElement("br",null),i.a.createElement("h3",null,"4-setup-and-teardown"),i.a.createElement("div",{style:b},i.a.createElement(k.a,{code:y,language:"js",plugins:["line-numbers"]})),i.a.createElement("br",null),i.a.createElement("h3",null,"5-mock-functions"),i.a.createElement("div",{style:b},i.a.createElement(k.a,{code:E,language:"js",plugins:["line-numbers"]})),i.a.createElement("br",null),i.a.createElement("h3",null,"Login"),i.a.createElement("div",{style:b},i.a.createElement(k.a,{code:v,language:"js",plugins:["line-numbers"]}))))))}}]),n}(l.Component);n.default=Object(g.a)((function(e){return{paper:{margin:e.spacing(1),padding:e.spacing(1)},smMargin:{margin:e.spacing(1)},actionDiv:{textAlign:"center"}}}))(B)}}]);
//# sourceMappingURL=142.db1c4467.chunk.js.map