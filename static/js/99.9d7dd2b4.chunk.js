(this["webpackJsonpmern-stack-client"]=this["webpackJsonpmern-stack-client"]||[]).push([[99],{140:function(e,n,t){"use strict";t.d(n,"a",(function(){return h}));var a=t(45),r=t(28),l=t(136),o=t(137),s=t(139),c=t(0),i=t.n(c),u=t(138),m=t.n(u),h=(t(59),function(e){function n(e){var t;return Object(a.a)(this,n),(t=Object(l.a)(this,Object(o.a)(n).call(this,e))).highlight=function(){t.ref&&t.ref.current&&m.a.highlightElement(t.ref.current)},t.ref=i.a.createRef(),t}return Object(s.a)(n,e),Object(r.a)(n,[{key:"componentDidMount",value:function(){this.highlight()}},{key:"componentDidUpdate",value:function(){this.highlight()}},{key:"render",value:function(){var e=this.props,n=e.code,t=(e.plugins,e.language);return i.a.createElement("pre",{className:"code-prism"},i.a.createElement("code",{ref:this.ref,className:"language-".concat(t)},n.trim()))}}]),n}(i.a.Component))},141:function(e,n,t){},150:function(e,n,t){"use strict";t.d(n,"a",(function(){return u}));var a=t(0),r=t.n(a),l=t(26),o=t(297),s=t(295),c=t(114),i=Object(c.a)((function(e){return{root:{display:"flex"},paper:{marginRight:e.spacing(2)},line:{textDecoration:"none"}}}));function u(){var e=i();return r.a.createElement("div",{className:e.root},r.a.createElement(s.a,null,r.a.createElement(o.a,null,r.a.createElement(l.b,{to:"/introAngular",className:e.line},"AI")),r.a.createElement(o.a,null,r.a.createElement(l.b,{to:"/tensorflow",className:e.line},"Tensorflow")),r.a.createElement(o.a,null,r.a.createElement(l.b,{to:"/tensors",className:e.line},"Tensorboards")),r.a.createElement(o.a,null,r.a.createElement(l.b,{to:"/angCompiler",className:e.line},"Compiler")),r.a.createElement(o.a,null,r.a.createElement(l.b,{to:"/neural",className:e.line},"NeuralKeras")),r.a.createElement(o.a,null,r.a.createElement(l.b,{to:"/activationFunctions",className:e.line},"activationFuncs")),r.a.createElement(o.a,null,r.a.createElement(l.b,{to:"/loss",className:e.line},"Loss")),r.a.createElement(o.a,null,r.a.createElement(l.b,{to:"/gradientNeural",className:e.line},"GradientNeural")),r.a.createElement(o.a,null,r.a.createElement(l.b,{to:"/stochastic",className:e.line},"Stochastic")),r.a.createElement(o.a,null,r.a.createElement(l.b,{to:"/benchmarking",className:e.line},"Benchmarking")),r.a.createElement(o.a,null,r.a.createElement(l.b,{to:"/customer",className:e.line},"Customer")),r.a.createElement(o.a,null,r.a.createElement(l.b,{to:"/regularizationDeep",className:e.line},"Regularization Deep")),r.a.createElement(o.a,null,r.a.createElement(l.b,{to:"/imbalanced",className:e.line},"Imbalanced")),r.a.createElement(o.a,null,r.a.createElement(l.b,{to:"/imbalanced2",className:e.line},"Imbalanced2")),r.a.createElement(o.a,null,r.a.createElement(l.b,{to:"/convolutionals",className:e.line},"Convolutionals")),r.a.createElement(o.a,null,r.a.createElement(l.b,{to:"/data_augmentation",className:e.line},"data Augmentation")),r.a.createElement(o.a,null,r.a.createElement(l.b,{to:"/transfer",className:e.line},"Transfer")),r.a.createElement(o.a,null,r.a.createElement(l.b,{to:"/word_embedding",className:e.line},"Embedding")),r.a.createElement(o.a,null,r.a.createElement(l.b,{to:"/datatypests",className:e.line},"Datatypes")),r.a.createElement(o.a,null,r.a.createElement(l.b,{to:"/typeScript_2",className:e.line},"TS Function")),r.a.createElement(o.a,null,r.a.createElement(l.b,{to:"/typeScript_4",className:e.line},"Type Assertion"))),r.a.createElement("div",null))}},450:function(e,n,t){"use strict";t.r(n);var a=t(45),r=t(28),l=t(136),o=t(137),s=t(139),c=t(0),i=t.n(c),u=t(138),m=t.n(u),h=t(120),g=t(57),b=t(296),d=t(5),p=(t(141),t(150)),E=t(140),y={backgroundColor:"#F0F8FF",padding:"1px",fontSize:"16px"},f="\nnpm install -g typescript\ntsc --version\ntsc --help\ntsc app.ts                                             #to run app.ts file.                                             \n\nlet doLog = (msg) => {console.log(msg)}\n".trim(),v="\nclass Point{\n  x: number;\n  y: number;\n\n  constructor(x?: number, y?:number){\n    this.x = x;\n    this.y = y\n  }\n\n  getVal(){\n    console.log(this.x, this.y)\n  }\n}\n\nlet obj = Point();\nobj.getVal();\n\n\n//Access modifier\nclass Point{\n  constructor(private x?: number, private y?:number){ }\n // constructor(public x?: number, public y?:number){ }\n\n  getVal(){\n    console.log(this.x, this.y)\n  }\n}\n\nlet obj = Point();\nobj.getVal();\n".trim(),j="\ninterface User {\n  name: string;\n  id: number;\n}\n\nconst user: User = {\n  username: \"Hayes\",\n  Type '{username: string; id: number;}' is not assignable to type 'User'.\n  Object literal may only specify known properties, and 'username' does not exist in type 'User'.\n  id: 0,\n};".trim(),w='\ninterface User {\n  name: string;\n  id: number;\n}\n\nclass UserAccount {\n  name: string;\n  id: number;\n\n  constructor(name: string, id: number) {\n    this.name = name;\n    this.id = id;\n  }\n}\n\nconst user: User = new UserAccount("Murphy", 1);\nconsole.log(user)'.trim(),C="\nclass Player{\n  name:string;\n  id:number;\n  \n  greet(){\n     console.log(My name is '$'{this.name})\n  }\n}\n\nconst obj = new Player();\nobj.name='Mukesh';\nobj.id=1;\n\nconst obj2 = new Player();\nobj2.name='Rakesh';\n\nobj.greet()\nobj2.greet()\n".trim(),H="\nclass Player{\n  private name:string;\n  private id:number;\n  \n  setName(name:string){\n     if(name.length<3){\n        console.log('Please write full name')\n        return;\n     }\n     this.name=name;\n  }\n  \n  getName(){\n     return this.name;\n  }\n}\n\nconst obj=new Player()\nobj.setName('Rakesh');\n\nconsole.log(obj.getName())\n".trim(),N="\nclass Animal{\n  hunger:number;\n  health:number;\n  \n  eat(){\n     console.log('Eating')\n  }\n  sleep(){\n     console.log('Sleeping')\n  }\n  move(){\n     console.log('Moving')\n  }\n  makeNoise(){\n     console.log('Make noise')\n  }\n  \n}\n\nclass Dog extends Animal{\n  makeNoise(){\n     console.log('Bark')\n  }\n}\n\nclass Cat extends Animal{}\n\nconst dog = new Dog();\nconst cat = new Cat();\ndog.makeNoise()\ncat.makeNoise()\n\n".trim(),x='\nclass Animal {\n    eat():void {\n        console.log("Eating")\n     }\n}\n\nclass Dog extends Animal {\n   bark():void {\n      console.log("Barking")\n   }\n}\n\nclass BabyDog extends Dog{\n    weep():void {\n        console.log("Weeping")\n     }\n}\nlet obj = new BabyDog();\nobj.eat();\nobj.bark();\nobj.weep()\n'.trim(),I='\ntype Point = {\n  x: number;\n  y: number;\n};\n\nfunction printCoord(pt: Point) {\n  console.log("The coordinate\'s x value is " + pt.x);\n  console.log("The coordinate\'s y value is " + pt.y);\n}\n\nprintCoord({ x: 100, y: 100 });\n'.trim(),k='\ninterface Point {\n  x: number;\n  y: number;\n}\n\nfunction printCoord(pt: Point) {\n  console.log("The coordinate\'s x value is " + pt.x);\n  console.log("The coordinate\'s y value is " + pt.y);\n}\n\nprintCoord({x: 100, y: 100});\n'.trim(),T="\nabstract class Character{\n  hunger:number;\n  health:number;\n  \n  abstract eat(): void\n}\n\ninterface Hero extends Character{\n  heroId:number;\n}\n\ninterface Enemy extends Character{\n  enemyId:number\n}\n\nclass Spy implements Hero, Enemy{\n  hunger:number;\n  health:number;\n  heroId:number;\n  enemyId:number;\n  \n  eat() {\n      this.hunger -= 1\n  }\n} \n\nconst hero: Hero = new Spy();\nconst enemy: Enemy = new Spy();\n".trim(),A='\nclass A {\n    public foo(s: string): number;\n    public foo(n: number): string;\n\n    public foo(arg: any): any {\n        if (typeof(arg) === \'number\')\n            return arg.toString();\n        if (typeof(arg) === \'string\')\n            return arg.length;\n    }\n}\n\nlet obj = new A();\nconsole.log("Result: " +obj.foo(101));\nconsole.log("Length of String: " +obj.foo("JavaTpoint"));\n'.trim(),S="\nclass Hero{\n  hunger:number;\n  health:number;\n  \n  attack(){\n     console.log('Attacking')\n  }\n  move(){\n     console.log('Moving')\n  }\n  eat(){\n     console.log('Eating')\n  }\n}\n\nclass Archer extends Hero{\n  arrows:number;\n  attack(){\n     super.attack()\n     console.log('Firing an Arrow')\n     this.arrows -= 1\n  }\n}\n\nclass Mage extends Hero{\n  mana:number\n  \n  attack(): void {\n      super.attack()\n      console.log('Throwing a portion')\n      this.mana -= 1\n  }\n}\n\nclass Knight extends Hero{\n  shield:number\n  attack(){\n     console.log('Knight')\n  }\n}\n\nconst archer:Hero=new Archer();\nconst mage:Hero=new Mage();\nconst knight:Hero=new Knight();\n\narcher.attack();\nmage.attack();\nknight.attack();\n\nclass Tribe{\n  private heros:Hero[];\n  setHeros(heros:Hero[]){\n     this.heros = heros;\n  }\n  \n  attack(): void{\n     for(let hero of this.heros){\n        hero.attack();\n     }\n  }\n}\n\nconst heros: Hero[] = [archer, mage, knight];\nconst tribe = new Tribe();\ntribe.setHeros(heros);\ntribe.attack()\n".trim(),D="\nclass Character{\n  private hunger:number;\n  private health:number;\n  \n  constructor(hunger: number, health: number){\n     this.hunger=hunger;\n     this.health=health;\n  }\n   \n  setHunger(hunger: number): void{\n     this.hunger = hunger;\n  }\n  \n  setHealth(health: number): void {\n     this.health = health;\n  }\n  \n  getHunger():number{\n     return this.hunger;\n  }\n  \n  getHealth():number{\n   return this.health;\n}\n}\n\nclass Hero extends Character{\n  private heroId: number;\n  \n  setHeroId(heroId: number): void{\n     this.heroId = heroId;\n  }\n}\n\n\nconst obj = new Hero(10,100)\nconsole.log(obj.getHunger())\nconsole.log(obj.getHealth())\n".trim(),P="\nclass Character{\n  private hunger:number;\n  private health:number;\n  \n  constructor(hunger: number, health: number){\n     this.hunger=hunger;\n     this.health=health;\n  }\n   \n  setHunger(hunger: number): void{\n     this.hunger = hunger;\n  }\n  \n  setHealth(health: number): void {\n     this.health = health;\n  }\n  \n  getHunger():number{\n     return this.hunger;\n  }\n  \n  getHealth():number{\n   return this.health;\n}\n}\n\nclass Hero extends Character{\n  private heroId: number;\n  \n  constructor(heroId: number, hunger: number, health: number){\n     super(hunger, health)\n     this.heroId=heroId;\n  }\n  \n  setHeroId(heroId: number): void{\n     this.heroId = heroId;\n  }\n}\n\n\nconst obj = new Hero(10,30,100)\nconsole.log(obj.getHunger())\nconsole.log(obj.getHealth())\n".trim(),O="\nclass Character{\n  static characterCount = 0;\n  private hunger:number;\n  private health:number;\n  \n  constructor(hunger: number, health: number){\n     Character.characterCount +=1;\n     console.log(Character.characterCount)\n     this.hunger=hunger;\n     this.health=health;\n  }\n   \n  setHunger(hunger: number): void{\n     this.hunger = hunger;\n  }\n  \n  setHealth(health: number): void {\n     this.health = health;\n  }\n  \n  getHunger():number{\n     return this.hunger;\n  }\n  \n  getHealth():number{\n   return this.health;\n}\n}\n\nclass Hero extends Character{\n  private heroId: number;\n  \n  constructor(heroId: number, hunger: number, health: number){\n     super(hunger, health)\n     this.heroId=heroId;\n  }\n  \n  setHeroId(heroId: number): void{\n     this.heroId = heroId;\n  }\n}\n\nconst obj = new Hero(10,30,100)\nconst obj2 = new Hero(10,30,100)\nconst obj3 = new Hero(10,30,100)\n".trim(),R="\nclass Character{\n  static characterCount = 0;\n  private hunger:number;\n  private health:number;\n  \n  constructor(hunger: number, health: number){\n     Character.characterCount +=1;\n     console.log(Character.characterCount)\n     this.hunger=hunger;\n     this.health=health;\n  }\n   \n  setHunger(hunger: number): void{\n     this.hunger = hunger;\n  }\n  \n  setHealth(health: number): void {\n     this.health = health;\n  }\n  \n  getHunger():number{\n     return this.hunger;\n  }\n  \n  getHealth():number{\n   return this.health;\n}\n}\n\nclass Hero extends Character{\n  readonly heroId: number;                                                              //cannot mutate after initialize\n  \n  constructor(heroId: number, hunger: number, health: number){\n     super(hunger, health)\n     this.heroId=heroId;\n  }\n}\n\n\nconst obj = new Hero(10,30,100)\nconst obj2 = new Hero(10,30,100)\nconst obj3 = new Hero(10,30,100)\n".trim(),M='\nfunction padLeft(padding: number | string, input: string) {\n  if (typeof padding === "number") {\n    return new Array(padding + 1).join(" ") + input;\n  }\n  return padding + input;\n}\n\npadLeft({padding:\'1\'},{input:\'input\'})\n\n\n2. Function Type Expressions\nfunction greeter(fn: (a: string) => void) {\n  fn("Hello, World");\n}\n\nfunction printToConsole(s: string) {\n  console.log(s);\n}\n\ngreeter(printToConsole);'.trim(),F="\nArray:\nvar list : number[] = [1, 3, 5];\nvar list : Array<number> = [1, 3, 5]; \n\n\n//2\nlet a: [string, number];\n\n\n//3\ninterface Calc {\n    subtract (first: number, second: number): any;\n}\n\nlet Calculator: Calc = {\n    subtract(first: number, second: number) {\n        return first - second;\n    }\n}\n\n\n\n//4\nclass Student {\n    RollNo: number;\n    Name: string;\n    constructor(RollNo: number, Name: string)  {\n        this.RollNo = RollNo;\n        this.Name = Name;\n    }\n    showDetails() {\n        console.log(this.RollNo + \" : \" + this.Name);\n    }\n}\n\n\nconst obj=new Student(1, 'aaa');\nobj.showDetails()\n\n\n//5\nenum Color {\n        Red, Green, Blue\n};\nlet c: Color;\nColorColor = Color.Green;\n\n\n\nFunctions:\nfunction add(a: number, b: number): number {\n            return a + b;\n}\n".trim(),U='\nfunction f() {\n    console.log("f(): evaluated");\n    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {\n        console.log("f(): called");\n    }\n}\n\nclass C {\n    @f()\n    method() {}\n} \n'.trim(),B=function(e){function n(){return Object(a.a)(this,n),Object(l.a)(this,Object(o.a)(n).apply(this,arguments))}return Object(s.a)(n,e),Object(r.a)(n,[{key:"componentDidMount",value:function(){setTimeout((function(){return m.a.highlightAll()}),0)}},{key:"render",value:function(){var e=this.props.classes;return i.a.createElement(h.a,{container:!0},i.a.createElement(h.a,{item:!0,xs:2},i.a.createElement(g.a,{className:e.paper},i.a.createElement("h4",null,i.a.createElement(p.a,null)))),i.a.createElement(h.a,{item:!0,xs:10},i.a.createElement(g.a,{className:e.paper},i.a.createElement(b.a,null,i.a.createElement("h3",null,"1. Cohesion And Coupling Principle"),i.a.createElement("ul",null,i.a.createElement("li",null,"Component connection inside modules is Cohesion."),i.a.createElement("li",null,"Connection b/w model is coupling."),i.a.createElement("li",null,"High Cohesion and Low Coupling.")),i.a.createElement("p",null),i.a.createElement("h3",null,"2. Arrow function"),i.a.createElement("div",{style:y},i.a.createElement(E.a,{code:f,language:"js",plugins:["line-numbers"]})),i.a.createElement("br",null),i.a.createElement("h3",null,"3. How without passing constructor parameter run ts"),i.a.createElement("div",{style:y},i.a.createElement(E.a,{code:v,language:"js",plugins:["line-numbers"]})),i.a.createElement("br",null),i.a.createElement("h3",null,"npm install -g typescript / tsc test.ts"),"TypeScript can build a type-system that accepts JavaScript code but has types. This offers a type-system without needing to add extra characters to make types explicit in our code.",i.a.createElement("ul",null,i.a.createElement("li",null,"We can then declare that a JavaScript object conforms to the shape of our new interface by using syntax : ",i.a.createElement("b",null,"TypeName after a variable declaration"),"."),i.a.createElement("li",null,"If provide an object that doesn\u2019t match the interface we have provided, TypeScript will warn.")),i.a.createElement("div",{style:y},i.a.createElement(E.a,{code:j,language:"js",plugins:["line-numbers"]})),i.a.createElement("br",null),i.a.createElement("br",null),i.a.createElement("div",{style:y},i.a.createElement(E.a,{code:w,language:"js",plugins:["line-numbers"]})),i.a.createElement("br",null),i.a.createElement("h3",null,"4. Object"),i.a.createElement("div",{style:y},i.a.createElement(E.a,{code:C,language:"js",plugins:["line-numbers"]})),i.a.createElement("br",null),i.a.createElement("h3",null,"5. Encapsulation, and private variables"),i.a.createElement("div",{style:y},i.a.createElement(E.a,{code:H,language:"js",plugins:["line-numbers"]})),i.a.createElement("br",null),i.a.createElement("h3",null,"6. Inheritance"),i.a.createElement("div",{style:y},i.a.createElement(E.a,{code:N,language:"js",plugins:["line-numbers"]})),i.a.createElement("br",null),i.a.createElement("h3",null,"7. Multi level Inheritance"),i.a.createElement("div",{style:y},i.a.createElement(E.a,{code:x,language:"js",plugins:["line-numbers"]})),i.a.createElement("br",null),i.a.createElement("h3",null,"8. Type Alias"),i.a.createElement("ul",null,i.a.createElement("li",null,"type alias is exactly that - a name for any type."),i.a.createElement("li",null,i.a.createElement("b",null,"N: "),"aliases are only aliases - you cannot use type aliases to create different/ distinct \u201cversions\u201d of the same type.")),i.a.createElement("div",{style:y},i.a.createElement(E.a,{code:I,language:"js",plugins:["line-numbers"]})),i.a.createElement("br",null),i.a.createElement("h3",null,"9. Interface Declaration"),"interface declaration is another way to name an object type.",i.a.createElement("br",null),i.a.createElement("br",null),"Type aliases and interfaces are very similar, and in many cases we can choose between them freely. Almost all features of an interface are available in type, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.",i.a.createElement("div",{style:y},i.a.createElement(E.a,{code:k,language:"js",plugins:["line-numbers"]})),i.a.createElement("br",null),i.a.createElement("h3",null,"10. Multiple Inheritance, and Interfaces"),i.a.createElement("div",{style:y},i.a.createElement(E.a,{code:T,language:"js",plugins:["line-numbers"]})),i.a.createElement("br",null),i.a.createElement("h3",null,"11. Polymorphism"),i.a.createElement("div",{style:y},i.a.createElement(E.a,{code:S,language:"js",plugins:["line-numbers"]})),i.a.createElement("br",null),i.a.createElement("h3",null,"12. Function Overloading"),i.a.createElement("div",{style:y},i.a.createElement(E.a,{code:A,language:"js",plugins:["line-numbers"]})),i.a.createElement("br",null),i.a.createElement("h3",null,"13. Constructors, Static, Parameter, and Readonly Properties"),i.a.createElement("div",{style:y},i.a.createElement(E.a,{code:D,language:"js",plugins:["line-numbers"]})),i.a.createElement("br",null),i.a.createElement("h3",null,"14. Parameter"),i.a.createElement("div",{style:y},i.a.createElement(E.a,{code:P,language:"js",plugins:["line-numbers"]})),i.a.createElement("br",null),i.a.createElement("h3",null,"15. Static"),i.a.createElement("div",{style:y},i.a.createElement(E.a,{code:O,language:"js",plugins:["line-numbers"]})),i.a.createElement("br",null),i.a.createElement("h3",null,"16. Readonly"),i.a.createElement("div",{style:y},i.a.createElement(E.a,{code:R,language:"js",plugins:["line-numbers"]})),i.a.createElement("br",null),i.a.createElement("h3",null,"17. Narrowing"),i.a.createElement("div",{style:y},i.a.createElement(E.a,{code:M,language:"js",plugins:["line-numbers"]})),i.a.createElement("br",null),i.a.createElement("h3",null,"18. Static Types"),'static types mean "at compile time".',i.a.createElement("br",null),"Static types can be further divided into two sub-categories:",i.a.createElement("br",null),i.a.createElement("b",null,"1. Built-in or Primitive Type: "),"Number, String, Boolean, Void, Null.",i.a.createElement("br",null),i.a.createElement("br",null),i.a.createElement("b",null,"2. User-Defined DataType: "),"Array, Touple, Enum, Functions, Class, Interface.",i.a.createElement("ul",null,i.a.createElement("li",null,i.a.createElement("b",null,"Touple: "),"Tuple is a data type which includes two sets of values of different data types."),i.a.createElement("li",null,i.a.createElement("b",null,"Interface: "),"It cannot be instantiated but can be referenced by the class which implements it."),i.a.createElement("li",null,i.a.createElement("b",null,"Class: "),"Classes are used to create reusable components and acts as a template for creating objects. It is a logical entity which store variables and functions to perform operations."),i.a.createElement("li",null,i.a.createElement("b",null,"Enums: "),"Define a set of named constant. TypeScript provides both string-based and numeric-based enums. By default, enums begin numbering their elements starting from 0, but we can also change this by manually setting the value to one of its elements.")),i.a.createElement("div",{style:y},i.a.createElement(E.a,{code:F,language:"js",plugins:["line-numbers"]})),i.a.createElement("br",null),i.a.createElement("h3",null,"19. Decorators"),"A decorator is a special of data type which can be attached to a class declaration, method, property, accessor, and parameter. It provides a way to add both annotations and a meta-programing syntax for classes and functions. It is used with ",i.a.createElement("b",null,"@")," symbol.",i.a.createElement("div",{style:y},i.a.createElement(E.a,{code:U,language:"js",plugins:["line-numbers"]}))))))}}]),n}(c.Component);n.default=Object(d.a)((function(e){return{paper:{margin:e.spacing(1),padding:e.spacing(1)},smMargin:{margin:e.spacing(1)},actionDiv:{textAlign:"center"}}}))(B)}}]);
//# sourceMappingURL=99.9d7dd2b4.chunk.js.map